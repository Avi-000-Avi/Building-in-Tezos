import { OperationContents, OperationContentsAndResult, OperationObject, PreapplyResponse, RpcClient, RPCRunOperationParam } from '@taquito/rpc';
import { Context } from '../context';
import { Estimate } from '../contract/estimate';
import { ForgedBytes, ParamsWithKind, PrepareOperationParams, RPCOperation } from './types';
export declare const SIGNATURE_STUB = "edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg";
export interface PreparedOperation {
    opOb: {
        branch: string;
        contents: OperationContents[];
        protocol: string;
    };
    counter: number;
}
export interface PreparedOperationSimulation {
    opOb: {
        branch: string;
        contents: OperationContents[];
    };
    counter: number;
}
export interface PreparedOpAndSimulation {
    preparedOp: PreparedOperation;
    preparedOpSimulation?: PreparedOperationSimulation;
}
export declare abstract class OperationEmitter {
    protected context: Context;
    get rpc(): RpcClient;
    get signer(): import("../taquito").Signer;
    constructor(context: Context);
    protected isRevealOpNeeded(op: RPCOperation[] | ParamsWithKind[], pkh: string): Promise<boolean>;
    protected isAccountRevealRequired(publicKeyHash: string): Promise<boolean>;
    protected isRevealRequiredForOpType(op: RPCOperation[] | ParamsWithKind[]): boolean;
    private constructOps;
    private getFee;
    private getSource;
    protected prepareOpAndSimulation({ operation, source }: PrepareOperationParams): Promise<PreparedOpAndSimulation>;
    private getCounterHashAndProtocol;
    private getContextCounter;
    private getScopeCounter;
    protected prepareOperationEstimation({ operation, source }: PrepareOperationParams): Promise<PreparedOperationSimulation>;
    protected preValidate(prepared: PreparedOpAndSimulation, forgedOperation: ForgedBytes): Promise<OperationContentsAndResult[]>;
    protected forgeOperation({ opOb: { branch, contents }, }: PreparedOperation | PreparedOperationSimulation): Promise<string>;
    protected forge({ opOb: { branch, contents, protocol }, counter, }: PreparedOperation): Promise<ForgedBytes>;
    protected simulate(op: RPCRunOperationParam): Promise<{
        opResponse: PreapplyResponse;
        op: RPCRunOperationParam;
        context: Context;
    }>;
    protected estimate<T extends {
        fee?: number;
        gasLimit?: number;
        storageLimit?: number;
    }>({ fee, gasLimit, storageLimit, ...rest }: T, estimator: (param: T) => Promise<Estimate>): Promise<{
        fee: number;
        gasLimit: number;
        storageLimit: number;
    }>;
    protected signOperation(forgedBytes: ForgedBytes): Promise<ForgedBytes>;
    protected runOperation(op: RPCRunOperationParam): Promise<OperationContentsAndResult[]>;
    protected preapplyOperation(opOb: OperationObject): Promise<OperationContentsAndResult[]>;
    protected injectOperation(signedOperationBytes: string): Promise<string>;
}
