{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Logger } from '../utils/Logger';\nimport { TransportType, TransportStatus } from '..';\nconst logger = new Logger('Transport');\n/**\n * @internalapi\n *\n *\n */\n\nexport class Transport {\n  constructor(name, client, peerManager) {\n    /**\n     * The type of the transport\n     */\n    this.type = TransportType.POST_MESSAGE;\n    /**\n     * The status of the transport\n     */\n\n    this._isConnected = TransportStatus.NOT_CONNECTED;\n    /**\n     * The listeners that will be notified when new messages are coming in\n     */\n\n    this.listeners = [];\n    this.name = name;\n    this.client = client;\n    this.peerManager = peerManager;\n  }\n  /**\n   * Return the status of the connection\n   */\n\n\n  get connectionStatus() {\n    return this._isConnected;\n  }\n  /**\n   * Returns a promise that resolves to true if the transport is available, false if it is not\n   */\n\n\n  static isAvailable() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return Promise.resolve(false);\n    });\n  }\n  /**\n   * Connect the transport\n   */\n\n\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('connect');\n      this._isConnected = TransportStatus.CONNECTED;\n      return;\n    });\n  }\n  /**\n   * Disconnect the transport\n   */\n\n\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('disconnect');\n      this._isConnected = TransportStatus.NOT_CONNECTED;\n      return;\n    });\n  }\n  /**\n   * Send a message through the transport\n   *\n   * @param message The message to send\n   * @param recipient The recipient of the message\n   */\n\n\n  send(message, peer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (peer) {\n        return this.client.sendMessage(message, peer);\n      } else {\n        const knownPeers = yield this.getPeers(); // A broadcast request has to be sent everywhere.\n\n        const promises = knownPeers.map(peerEl => this.client.sendMessage(message, peerEl));\n        return (yield Promise.all(promises))[0];\n      }\n    });\n  }\n  /**\n   * Add a listener to be called when a new message is received\n   *\n   * @param listener The listener that will be registered\n   */\n\n\n  addListener(listener) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.debug('addListener', listener);\n      this.listeners.push(listener);\n      return;\n    });\n  }\n  /**\n   * Remove a listener\n   *\n   * @param listener\n   */\n\n\n  removeListener(listener) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('removeListener');\n      this.listeners = this.listeners.filter(element => element !== listener);\n      return;\n    });\n  }\n\n  getPeers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.peerManager.getPeers(); // TODO: Fix type\n    });\n  }\n\n  addPeer(newPeer, _sendPairingResponse = true) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('addPeer', 'adding peer', newPeer);\n      yield this.peerManager.addPeer(newPeer); // TODO: Fix type\n\n      yield this.listen(newPeer.publicKey);\n    });\n  }\n\n  removePeer(peerToBeRemoved) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('removePeer', 'removing peer', peerToBeRemoved);\n      yield this.peerManager.removePeer(peerToBeRemoved.publicKey);\n\n      if (this.client) {\n        yield this.client.unsubscribeFromEncryptedMessage(peerToBeRemoved.publicKey);\n      }\n    });\n  }\n\n  removeAllPeers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('removeAllPeers');\n      yield this.peerManager.removeAllPeers();\n\n      if (this.client) {\n        yield this.client.unsubscribeFromEncryptedMessages();\n      }\n    });\n  }\n  /**\n   * Notify the listeners when a new message comes in\n   *\n   * @param message Message\n   * @param connectionInfo Context info about the connection\n   */\n\n\n  notifyListeners(message, connectionInfo) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.listeners.length === 0) {\n        logger.warn('notifyListeners', '0 listeners notified!', this);\n      } else {\n        logger.log('notifyListeners', `Notifying ${this.listeners.length} listeners`, this);\n      }\n\n      this.listeners.forEach(listener => {\n        listener(message, connectionInfo);\n      });\n      return;\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/transports/Transport.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Logger } from '../utils/Logger';\nimport { TransportType, TransportStatus } from '..';\nconst logger = new Logger('Transport');\n/**\n * @internalapi\n *\n *\n */\nexport class Transport {\n    constructor(name, client, peerManager) {\n        /**\n         * The type of the transport\n         */\n        this.type = TransportType.POST_MESSAGE;\n        /**\n         * The status of the transport\n         */\n        this._isConnected = TransportStatus.NOT_CONNECTED;\n        /**\n         * The listeners that will be notified when new messages are coming in\n         */\n        this.listeners = [];\n        this.name = name;\n        this.client = client;\n        this.peerManager = peerManager;\n    }\n    /**\n     * Return the status of the connection\n     */\n    get connectionStatus() {\n        return this._isConnected;\n    }\n    /**\n     * Returns a promise that resolves to true if the transport is available, false if it is not\n     */\n    static isAvailable() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return Promise.resolve(false);\n        });\n    }\n    /**\n     * Connect the transport\n     */\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('connect');\n            this._isConnected = TransportStatus.CONNECTED;\n            return;\n        });\n    }\n    /**\n     * Disconnect the transport\n     */\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('disconnect');\n            this._isConnected = TransportStatus.NOT_CONNECTED;\n            return;\n        });\n    }\n    /**\n     * Send a message through the transport\n     *\n     * @param message The message to send\n     * @param recipient The recipient of the message\n     */\n    send(message, peer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (peer) {\n                return this.client.sendMessage(message, peer);\n            }\n            else {\n                const knownPeers = yield this.getPeers();\n                // A broadcast request has to be sent everywhere.\n                const promises = knownPeers.map((peerEl) => this.client.sendMessage(message, peerEl));\n                return (yield Promise.all(promises))[0];\n            }\n        });\n    }\n    /**\n     * Add a listener to be called when a new message is received\n     *\n     * @param listener The listener that will be registered\n     */\n    addListener(listener) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.debug('addListener', listener);\n            this.listeners.push(listener);\n            return;\n        });\n    }\n    /**\n     * Remove a listener\n     *\n     * @param listener\n     */\n    removeListener(listener) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('removeListener');\n            this.listeners = this.listeners.filter((element) => element !== listener);\n            return;\n        });\n    }\n    getPeers() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.peerManager.getPeers(); // TODO: Fix type\n        });\n    }\n    addPeer(newPeer, _sendPairingResponse = true) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('addPeer', 'adding peer', newPeer);\n            yield this.peerManager.addPeer(newPeer); // TODO: Fix type\n            yield this.listen(newPeer.publicKey);\n        });\n    }\n    removePeer(peerToBeRemoved) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('removePeer', 'removing peer', peerToBeRemoved);\n            yield this.peerManager.removePeer(peerToBeRemoved.publicKey);\n            if (this.client) {\n                yield this.client.unsubscribeFromEncryptedMessage(peerToBeRemoved.publicKey);\n            }\n        });\n    }\n    removeAllPeers() {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('removeAllPeers');\n            yield this.peerManager.removeAllPeers();\n            if (this.client) {\n                yield this.client.unsubscribeFromEncryptedMessages();\n            }\n        });\n    }\n    /**\n     * Notify the listeners when a new message comes in\n     *\n     * @param message Message\n     * @param connectionInfo Context info about the connection\n     */\n    notifyListeners(message, connectionInfo) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.listeners.length === 0) {\n                logger.warn('notifyListeners', '0 listeners notified!', this);\n            }\n            else {\n                logger.log('notifyListeners', `Notifying ${this.listeners.length} listeners`, this);\n            }\n            this.listeners.forEach((listener) => {\n                listener(message, connectionInfo);\n            });\n            return;\n        });\n    }\n}\n//# sourceMappingURL=Transport.js.map"]},"metadata":{},"sourceType":"module"}