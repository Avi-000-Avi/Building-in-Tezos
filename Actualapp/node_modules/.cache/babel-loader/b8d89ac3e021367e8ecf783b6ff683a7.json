{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Logger } from '../utils/Logger';\nimport { ExposedPromise } from '../utils/exposed-promise';\nimport { MatrixClientStore } from './MatrixClientStore';\nimport { MatrixHttpClient } from './MatrixHttpClient';\nimport { MatrixRoom, MatrixRoomStatus } from './models/MatrixRoom';\nimport { MatrixRoomService } from './services/MatrixRoomService';\nimport { MatrixUserService } from './services/MatrixUserService';\nimport { MatrixEventService } from './services/MatrixEventService';\nimport { MatrixClientEventEmitter } from './MatrixClientEventEmitter';\nconst logger = new Logger('MatrixClient');\nconst IMMEDIATE_POLLING_RETRIES = 3;\nconst RETRY_INTERVAL = 5000;\n/**\n * The matrix client used to connect to the matrix network\n */\n\nexport class MatrixClient {\n  constructor(store, eventEmitter, userService, roomService, eventService, httpClient) {\n    this.store = store;\n    this.eventEmitter = eventEmitter;\n    this.userService = userService;\n    this.roomService = roomService;\n    this.eventService = eventService;\n    this.httpClient = httpClient;\n    this.isActive = true;\n    this._isReady = new ExposedPromise();\n    this.store.onStateChanged((oldState, newState, stateChange) => {\n      this.eventEmitter.onStateChanged(oldState, newState, stateChange);\n    }, 'rooms');\n  }\n  /**\n   * Create a matrix client based on the options provided\n   *\n   * @param config\n   */\n\n\n  static create(config) {\n    const store = new MatrixClientStore(config.storage);\n    const eventEmitter = new MatrixClientEventEmitter();\n    const httpClient = new MatrixHttpClient(config.baseUrl);\n    const accountService = new MatrixUserService(httpClient);\n    const roomService = new MatrixRoomService(httpClient);\n    const eventService = new MatrixEventService(httpClient);\n    return new MatrixClient(store, eventEmitter, accountService, roomService, eventService, httpClient);\n  }\n  /**\n   * Return all the rooms we are currently part of\n   */\n\n\n  get joinedRooms() {\n    return new Promise(resolve => __awaiter(this, void 0, void 0, function* () {\n      yield this.isConnected();\n      resolve(Object.values(this.store.get('rooms')).filter(room => room.status === MatrixRoomStatus.JOINED));\n    }));\n  }\n  /**\n   * Return all the rooms to which we have received invitations\n   */\n\n\n  get invitedRooms() {\n    return new Promise(resolve => __awaiter(this, void 0, void 0, function* () {\n      yield this.isConnected();\n      resolve(Object.values(this.store.get('rooms')).filter(room => room.status === MatrixRoomStatus.INVITED));\n    }));\n  }\n  /**\n   * Return all the rooms that we left\n   */\n\n\n  get leftRooms() {\n    return new Promise(resolve => __awaiter(this, void 0, void 0, function* () {\n      yield this.isConnected();\n      resolve(Object.values(this.store.get('rooms')).filter(room => room.status === MatrixRoomStatus.LEFT));\n    }));\n  }\n  /**\n   * Initiate the connection to the matrix node and log in\n   *\n   * @param user\n   */\n\n\n  start(user) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const response = yield this.userService.login(user.id, user.password, user.deviceId);\n      yield this.store.update({\n        accessToken: response.access_token\n      });\n      const initialPollingResult = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n        yield this.poll(0, pollingResponse => __awaiter(this, void 0, void 0, function* () {\n          if (!this.store.get('isRunning')) {\n            resolve();\n          }\n\n          yield this.store.update({\n            isRunning: true,\n            syncToken: pollingResponse.next_batch,\n            pollingTimeout: 30000,\n            pollingRetries: 0,\n            rooms: MatrixRoom.fromSync(pollingResponse.rooms)\n          });\n        }), error => __awaiter(this, void 0, void 0, function* () {\n          if (!this.store.get('isRunning')) {\n            reject(error);\n          }\n\n          yield this.store.update({\n            isRunning: false,\n            pollingRetries: this.store.get('pollingRetries') + 1\n          });\n        }));\n      }));\n      initialPollingResult.then(() => {\n        this._isReady.resolve();\n      }).catch(console.error);\n      return initialPollingResult;\n    });\n  }\n\n  isConnected() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this._isReady.promise;\n    });\n  }\n  /**\n   * Stop all running requests\n   */\n\n\n  stop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log(`MATRIX CLIENT STOPPED`);\n      this.isActive = false;\n      this._isReady = new ExposedPromise();\n      return this.httpClient.cancelAllRequests();\n    });\n  }\n  /**\n   * Subscribe to new matrix events\n   *\n   * @param event\n   * @param listener\n   */\n\n\n  subscribe(event, listener) {\n    this.eventEmitter.on(event, listener);\n  }\n  /**\n   * Unsubscribe from matrix events\n   *\n   * @param event\n   * @param listener\n   */\n\n\n  unsubscribe(event, listener) {\n    if (listener) {\n      this.eventEmitter.removeListener(event, listener);\n    }\n  }\n  /**\n   * Unsubscribe from all matrix events of this type\n   *\n   * @param event\n   * @param listener\n   */\n\n\n  unsubscribeAll(event) {\n    this.eventEmitter.removeAllListeners(event);\n  }\n\n  getRoomById(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.isConnected();\n      return this.store.getRoom(id);\n    });\n  }\n  /**\n   * Create a private room with the supplied members\n   *\n   * @param members Members that will be in the room\n   */\n\n\n  createTrustedPrivateRoom(...members) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.isConnected();\n      return this.requiresAuthorization('createRoom', accessToken => __awaiter(this, void 0, void 0, function* () {\n        const response = yield this.roomService.createRoom(accessToken, {\n          room_version: '5',\n          invite: members,\n          preset: 'public_chat',\n          is_direct: true\n        });\n        return response.room_id;\n      }));\n    });\n  }\n  /**\n   * Invite user to rooms\n   *\n   * @param user The user to be invited\n   * @param roomsOrIds The rooms the user will be invited to\n   */\n\n\n  inviteToRooms(user, ...roomsOrIds) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.isConnected();\n      yield this.requiresAuthorization('invite', accessToken => Promise.all(roomsOrIds.map(roomOrId => {\n        const room = this.store.getRoom(roomOrId);\n        this.roomService.inviteToRoom(accessToken, user, room).catch(error => logger.warn('inviteToRooms', error));\n      })));\n    });\n  }\n  /**\n   * Join rooms\n   *\n   * @param roomsOrIds\n   */\n\n\n  joinRooms(...roomsOrIds) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.isConnected();\n      yield this.requiresAuthorization('join', accessToken => Promise.all(roomsOrIds.map(roomOrId => {\n        const room = this.store.getRoom(roomOrId);\n        return this.roomService.joinRoom(accessToken, room);\n      })));\n    });\n  }\n  /**\n   * Send a text message\n   *\n   * @param roomOrId\n   * @param message\n   */\n\n\n  sendTextMessage(roomId, message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.isConnected();\n      yield this.requiresAuthorization('send', accessToken => __awaiter(this, void 0, void 0, function* () {\n        const txnId = yield this.createTxnId();\n        return this.eventService.sendMessage(accessToken, roomId, {\n          msgtype: 'm.text',\n          body: message\n        }, txnId);\n      }));\n    });\n  }\n  /**\n   * Poll the server to get the latest data and get notified of changes\n   *\n   * @param interval\n   * @param onSyncSuccess\n   * @param onSyncError\n   */\n\n\n  poll(interval, onSyncSuccess, onSyncError) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const store = this.store;\n      const sync = this.sync.bind(this);\n\n      const pollSync = (resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n        let syncingRetries = 0;\n\n        try {\n          const response = yield sync();\n          onSyncSuccess(response);\n        } catch (error) {\n          onSyncError(error);\n          syncingRetries = store.get('pollingRetries'); // console.warn('Could not sync:', error)\n\n          if (this.isActive) {\n            logger.log(`Retry syncing... ${syncingRetries} retries so far`);\n          }\n        } finally {\n          if (this.isActive) {\n            setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n              yield pollSync(resolve, reject);\n            }), syncingRetries > IMMEDIATE_POLLING_RETRIES ? RETRY_INTERVAL + interval : interval);\n          } else {\n            reject(new Error(`Syncing stopped manually.`));\n          }\n        }\n      });\n\n      return new Promise(pollSync);\n    });\n  }\n  /**\n   * Get state from server\n   */\n\n\n  sync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.requiresAuthorization('sync', accessToken => __awaiter(this, void 0, void 0, function* () {\n        return this.eventService.sync(accessToken, {\n          pollingTimeout: this.store.get('pollingTimeout'),\n          syncToken: this.store.get('syncToken')\n        });\n      }));\n    });\n  }\n  /**\n   * A helper method that makes sure an access token is provided\n   *\n   * @param name\n   * @param action\n   */\n\n\n  requiresAuthorization(name, action) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const storedToken = this.store.get('accessToken');\n\n      if (!storedToken) {\n        return Promise.reject(`${name} requires authorization but no access token has been provided.`);\n      }\n\n      return action(storedToken);\n    });\n  }\n  /**\n   * Create a transaction ID\n   */\n\n\n  createTxnId() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const timestamp = new Date().getTime();\n      const counter = this.store.get('txnNo');\n      yield this.store.update({\n        txnNo: counter + 1\n      });\n      return `m${timestamp}.${counter}`;\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/matrix-client/MatrixClient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Logger } from '../utils/Logger';\nimport { ExposedPromise } from '../utils/exposed-promise';\nimport { MatrixClientStore } from './MatrixClientStore';\nimport { MatrixHttpClient } from './MatrixHttpClient';\nimport { MatrixRoom, MatrixRoomStatus } from './models/MatrixRoom';\nimport { MatrixRoomService } from './services/MatrixRoomService';\nimport { MatrixUserService } from './services/MatrixUserService';\nimport { MatrixEventService } from './services/MatrixEventService';\nimport { MatrixClientEventEmitter } from './MatrixClientEventEmitter';\nconst logger = new Logger('MatrixClient');\nconst IMMEDIATE_POLLING_RETRIES = 3;\nconst RETRY_INTERVAL = 5000;\n/**\n * The matrix client used to connect to the matrix network\n */\nexport class MatrixClient {\n    constructor(store, eventEmitter, userService, roomService, eventService, httpClient) {\n        this.store = store;\n        this.eventEmitter = eventEmitter;\n        this.userService = userService;\n        this.roomService = roomService;\n        this.eventService = eventService;\n        this.httpClient = httpClient;\n        this.isActive = true;\n        this._isReady = new ExposedPromise();\n        this.store.onStateChanged((oldState, newState, stateChange) => {\n            this.eventEmitter.onStateChanged(oldState, newState, stateChange);\n        }, 'rooms');\n    }\n    /**\n     * Create a matrix client based on the options provided\n     *\n     * @param config\n     */\n    static create(config) {\n        const store = new MatrixClientStore(config.storage);\n        const eventEmitter = new MatrixClientEventEmitter();\n        const httpClient = new MatrixHttpClient(config.baseUrl);\n        const accountService = new MatrixUserService(httpClient);\n        const roomService = new MatrixRoomService(httpClient);\n        const eventService = new MatrixEventService(httpClient);\n        return new MatrixClient(store, eventEmitter, accountService, roomService, eventService, httpClient);\n    }\n    /**\n     * Return all the rooms we are currently part of\n     */\n    get joinedRooms() {\n        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n            yield this.isConnected();\n            resolve(Object.values(this.store.get('rooms')).filter((room) => room.status === MatrixRoomStatus.JOINED));\n        }));\n    }\n    /**\n     * Return all the rooms to which we have received invitations\n     */\n    get invitedRooms() {\n        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n            yield this.isConnected();\n            resolve(Object.values(this.store.get('rooms')).filter((room) => room.status === MatrixRoomStatus.INVITED));\n        }));\n    }\n    /**\n     * Return all the rooms that we left\n     */\n    get leftRooms() {\n        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n            yield this.isConnected();\n            resolve(Object.values(this.store.get('rooms')).filter((room) => room.status === MatrixRoomStatus.LEFT));\n        }));\n    }\n    /**\n     * Initiate the connection to the matrix node and log in\n     *\n     * @param user\n     */\n    start(user) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.userService.login(user.id, user.password, user.deviceId);\n            yield this.store.update({\n                accessToken: response.access_token\n            });\n            const initialPollingResult = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                yield this.poll(0, (pollingResponse) => __awaiter(this, void 0, void 0, function* () {\n                    if (!this.store.get('isRunning')) {\n                        resolve();\n                    }\n                    yield this.store.update({\n                        isRunning: true,\n                        syncToken: pollingResponse.next_batch,\n                        pollingTimeout: 30000,\n                        pollingRetries: 0,\n                        rooms: MatrixRoom.fromSync(pollingResponse.rooms)\n                    });\n                }), (error) => __awaiter(this, void 0, void 0, function* () {\n                    if (!this.store.get('isRunning')) {\n                        reject(error);\n                    }\n                    yield this.store.update({\n                        isRunning: false,\n                        pollingRetries: this.store.get('pollingRetries') + 1\n                    });\n                }));\n            }));\n            initialPollingResult\n                .then(() => {\n                this._isReady.resolve();\n            })\n                .catch(console.error);\n            return initialPollingResult;\n        });\n    }\n    isConnected() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._isReady.promise;\n        });\n    }\n    /**\n     * Stop all running requests\n     */\n    stop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log(`MATRIX CLIENT STOPPED`);\n            this.isActive = false;\n            this._isReady = new ExposedPromise();\n            return this.httpClient.cancelAllRequests();\n        });\n    }\n    /**\n     * Subscribe to new matrix events\n     *\n     * @param event\n     * @param listener\n     */\n    subscribe(event, listener) {\n        this.eventEmitter.on(event, listener);\n    }\n    /**\n     * Unsubscribe from matrix events\n     *\n     * @param event\n     * @param listener\n     */\n    unsubscribe(event, listener) {\n        if (listener) {\n            this.eventEmitter.removeListener(event, listener);\n        }\n    }\n    /**\n     * Unsubscribe from all matrix events of this type\n     *\n     * @param event\n     * @param listener\n     */\n    unsubscribeAll(event) {\n        this.eventEmitter.removeAllListeners(event);\n    }\n    getRoomById(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.isConnected();\n            return this.store.getRoom(id);\n        });\n    }\n    /**\n     * Create a private room with the supplied members\n     *\n     * @param members Members that will be in the room\n     */\n    createTrustedPrivateRoom(...members) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.isConnected();\n            return this.requiresAuthorization('createRoom', (accessToken) => __awaiter(this, void 0, void 0, function* () {\n                const response = yield this.roomService.createRoom(accessToken, {\n                    room_version: '5',\n                    invite: members,\n                    preset: 'public_chat',\n                    is_direct: true\n                });\n                return response.room_id;\n            }));\n        });\n    }\n    /**\n     * Invite user to rooms\n     *\n     * @param user The user to be invited\n     * @param roomsOrIds The rooms the user will be invited to\n     */\n    inviteToRooms(user, ...roomsOrIds) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.isConnected();\n            yield this.requiresAuthorization('invite', (accessToken) => Promise.all(roomsOrIds.map((roomOrId) => {\n                const room = this.store.getRoom(roomOrId);\n                this.roomService\n                    .inviteToRoom(accessToken, user, room)\n                    .catch((error) => logger.warn('inviteToRooms', error));\n            })));\n        });\n    }\n    /**\n     * Join rooms\n     *\n     * @param roomsOrIds\n     */\n    joinRooms(...roomsOrIds) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.isConnected();\n            yield this.requiresAuthorization('join', (accessToken) => Promise.all(roomsOrIds.map((roomOrId) => {\n                const room = this.store.getRoom(roomOrId);\n                return this.roomService.joinRoom(accessToken, room);\n            })));\n        });\n    }\n    /**\n     * Send a text message\n     *\n     * @param roomOrId\n     * @param message\n     */\n    sendTextMessage(roomId, message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.isConnected();\n            yield this.requiresAuthorization('send', (accessToken) => __awaiter(this, void 0, void 0, function* () {\n                const txnId = yield this.createTxnId();\n                return this.eventService.sendMessage(accessToken, roomId, {\n                    msgtype: 'm.text',\n                    body: message\n                }, txnId);\n            }));\n        });\n    }\n    /**\n     * Poll the server to get the latest data and get notified of changes\n     *\n     * @param interval\n     * @param onSyncSuccess\n     * @param onSyncError\n     */\n    poll(interval, onSyncSuccess, onSyncError) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const store = this.store;\n            const sync = this.sync.bind(this);\n            const pollSync = (resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                let syncingRetries = 0;\n                try {\n                    const response = yield sync();\n                    onSyncSuccess(response);\n                }\n                catch (error) {\n                    onSyncError(error);\n                    syncingRetries = store.get('pollingRetries');\n                    // console.warn('Could not sync:', error)\n                    if (this.isActive) {\n                        logger.log(`Retry syncing... ${syncingRetries} retries so far`);\n                    }\n                }\n                finally {\n                    if (this.isActive) {\n                        setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                            yield pollSync(resolve, reject);\n                        }), syncingRetries > IMMEDIATE_POLLING_RETRIES ? RETRY_INTERVAL + interval : interval);\n                    }\n                    else {\n                        reject(new Error(`Syncing stopped manually.`));\n                    }\n                }\n            });\n            return new Promise(pollSync);\n        });\n    }\n    /**\n     * Get state from server\n     */\n    sync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.requiresAuthorization('sync', (accessToken) => __awaiter(this, void 0, void 0, function* () {\n                return this.eventService.sync(accessToken, {\n                    pollingTimeout: this.store.get('pollingTimeout'),\n                    syncToken: this.store.get('syncToken')\n                });\n            }));\n        });\n    }\n    /**\n     * A helper method that makes sure an access token is provided\n     *\n     * @param name\n     * @param action\n     */\n    requiresAuthorization(name, action) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const storedToken = this.store.get('accessToken');\n            if (!storedToken) {\n                return Promise.reject(`${name} requires authorization but no access token has been provided.`);\n            }\n            return action(storedToken);\n        });\n    }\n    /**\n     * Create a transaction ID\n     */\n    createTxnId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const timestamp = new Date().getTime();\n            const counter = this.store.get('txnNo');\n            yield this.store.update({\n                txnNo: counter + 1\n            });\n            return `m${timestamp}.${counter}`;\n        });\n    }\n}\n//# sourceMappingURL=MatrixClient.js.map"]},"metadata":{},"sourceType":"module"}