{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { StorageKey, P2PTransport } from '..'; // const logger = new Logger('DappP2PTransport')\n\n/**\n * @internalapi\n *\n *\n */\n\nexport class WalletP2PTransport extends P2PTransport {\n  constructor(name, keyPair, storage, matrixNodes, iconUrl, appUrl) {\n    super(name, keyPair, storage, matrixNodes, StorageKey.TRANSPORT_P2P_PEERS_WALLET, iconUrl, appUrl);\n  }\n\n  addPeer(newPeer, sendPairingResponse = true) {\n    const _super = Object.create(null, {\n      addPeer: {\n        get: () => super.addPeer\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield _super.addPeer.call(this, newPeer);\n\n      if (sendPairingResponse) {\n        yield this.client.sendPairingResponse(newPeer); // TODO: Should we have a confirmation here?\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/transports/WalletP2PTransport.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SAAkB,UAAlB,EAA8B,YAA9B,QAAqE,IAArE,C,CAEA;;AAEA;;;;AAIG;;AACH,OAAM,MAAO,kBAAP,SAAkC,YAAlC,CAGL;AACC,EAAA,WAAA,CACE,IADF,EAEE,OAFF,EAGE,OAHF,EAIE,WAJF,EAKE,OALF,EAME,MANF,EAMiB;AAEf,UACE,IADF,EAEE,OAFF,EAGE,OAHF,EAIE,WAJF,EAKE,UAAU,CAAC,0BALb,EAME,OANF,EAOE,MAPF;AASD;;AAEY,EAAA,OAAO,CAClB,OADkB,EAElB,mBAAA,GAA+B,IAFb,EAEiB;;;;;;;;AAEnC,YAAM,MAAA,CAAM,OAAN,CAAa,IAAb,CAAa,IAAb,EAAc,OAAd,CAAN;;AACA,UAAI,mBAAJ,EAAyB;AACvB,cAAM,KAAK,MAAL,CAAY,mBAAZ,CAAgC,OAAhC,CAAN,CADuB,CACwB;AAChD;AACF,K;AAAA;;AA5BF","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { StorageKey, P2PTransport } from '..';\n// const logger = new Logger('DappP2PTransport')\n/**\n * @internalapi\n *\n *\n */\nexport class WalletP2PTransport extends P2PTransport {\n    constructor(name, keyPair, storage, matrixNodes, iconUrl, appUrl) {\n        super(name, keyPair, storage, matrixNodes, StorageKey.TRANSPORT_P2P_PEERS_WALLET, iconUrl, appUrl);\n    }\n    addPeer(newPeer, sendPairingResponse = true) {\n        const _super = Object.create(null, {\n            addPeer: { get: () => super.addPeer }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.addPeer.call(this, newPeer);\n            if (sendPairingResponse) {\n                yield this.client.sendPairingResponse(newPeer); // TODO: Should we have a confirmation here?\n            }\n        });\n    }\n}\n//# sourceMappingURL=WalletP2PTransport.js.map"]},"metadata":{},"sourceType":"module"}