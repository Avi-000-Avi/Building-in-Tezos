{"ast":null,"code":"import { prefix, Prefix, b58cencode } from '@taquito/utils';\nimport sodium from 'libsodium-wrappers';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\n/*\r\n * Some code in this file is adapted from sotez\r\n * Copyright (c) 2018 Andrew Kishino\r\n */\n\n\nvar MAX_CHUNK_SIZE = 230;\n/**\r\n *\r\n * @description Convert the path to a buffer that will be used as LC and CDATA in the APDU send to the ledger device (https://github.com/obsidiansystems/ledger-app-tezos/blob/master/APDUs.md)\r\n *\r\n * @param path The ledger derivation path (default is \"44'/1729'/0'/0'\")\r\n * @returns A buffer where the first element is the length of the path (default is 4), then 3 bytes for each number of the path to which is added 0x8000000\r\n */\n\nfunction transformPathToBuffer(path) {\n  var result = [];\n  var components = path.split('/');\n  components.forEach(function (element) {\n    var toNumber = parseInt(element, 10);\n\n    if (Number.isNaN(toNumber)) {\n      return;\n    }\n\n    if (element.length > 1 && element[element.length - 1] === \"'\") {\n      toNumber += 0x80000000;\n    }\n\n    result.push(toNumber);\n  });\n  var buffer = Buffer.alloc(1 + result.length * 4);\n  buffer[0] = result.length;\n  result.forEach(function (element, index) {\n    buffer.writeUInt32BE(element, 1 + 4 * index);\n  });\n  return buffer;\n}\n/**\r\n *\r\n * @description Converts uncompressed ledger key to standard tezos binary representation\r\n */\n\n\nfunction compressPublicKey(publicKey, curve) {\n  if (curve === 0x00) {\n    publicKey = publicKey.slice(1);\n  } else {\n    publicKey[0] = 0x02 + (publicKey[64] & 0x01);\n    publicKey = publicKey.slice(0, 33);\n  }\n\n  return publicKey;\n}\n\nfunction appendWatermark(bytes, watermark) {\n  var transactionHex = bytes;\n\n  if (typeof watermark !== 'undefined') {\n    var hexWatermark = Buffer.from(watermark).toString('hex');\n    transactionHex = hexWatermark.concat(bytes);\n  }\n\n  return transactionHex;\n}\n/**\r\n *\r\n * @description In order not to exceed the data length allowed by the Ledger device, split the operation into buffers of 230 bytes (max) and add them to the message to send to the Ledger\r\n * @param messageToSend The message to send to the Ledger device\r\n * @param operation The operation which will be chunk if its length is over 230 bytes\r\n * @returns The instruction to send to the Ledger device\r\n */\n\n\nfunction chunkOperation(messageToSend, operation) {\n  var offset = 0;\n\n  while (offset !== operation.length) {\n    var chunkSize = offset + MAX_CHUNK_SIZE >= operation.length ? operation.length - offset : MAX_CHUNK_SIZE;\n    var buff = Buffer.alloc(chunkSize);\n    operation.copy(buff, 0, offset, offset + chunkSize);\n    messageToSend.push(buff);\n    offset += chunkSize;\n  }\n\n  return messageToSend;\n}\n/**\r\n *\r\n * @description Verify if the signature returned by the ledger for tz2 and tz3 is valid\r\n * @param response The signature returned by the Ledger (return from the signWithLedger function)\r\n * @returns True if valid, false otherwise\r\n */\n\n\nfunction validateResponse(response) {\n  var valid = true;\n\n  if (response[0] !== 0x31 && response[0] !== 0x30) {\n    valid = false;\n  }\n\n  if (response[1] + 4 !== response.length) {\n    valid = false;\n  }\n\n  if (response[2] !== 0x02) {\n    valid = false;\n  }\n\n  var rLength = response[3];\n\n  if (response[4 + rLength] !== 0x02) {\n    valid = false;\n  }\n\n  var idxLengthSVal = 5 + rLength;\n  var sLength = response[idxLengthSVal];\n\n  if (idxLengthSVal + 1 + sLength + 2 !== response.length) {\n    valid = false;\n  }\n\n  return valid;\n}\n/**\r\n *\r\n * @description Extract a part of the response returned by the Ledger\r\n * @param idxLength The index in the response from the Ledger that corresponds to the length of the part to extract\r\n * @param response The signature returned by the Ledger (return from the signWithLedger function)\r\n * @returns An object that contains the extracted buffer, the index where it starts in the response and the length of the extracted part\r\n */\n\n\nfunction extractValue(idxLength, response) {\n  var buffer = Buffer.alloc(32);\n  buffer.fill(0);\n  var length = response[idxLength];\n  var idxValueStart = idxLength + 1;\n\n  if (length > 32) {\n    idxValueStart += length - 32;\n    length = 32;\n  }\n\n  response.copy(buffer, 32 - length, idxValueStart, idxValueStart + length);\n  return {\n    buffer: buffer,\n    idxValueStart: idxValueStart,\n    length: length\n  };\n} // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\n\n/* tslint:disable */\n\n\nvar VERSION = {\n  \"commitHash\": \"a8e9548e650215186f661033b59299ace72c9ee6\",\n  \"version\": \"9.2.0\"\n};\n/* tslint:enable */\n\n/**\r\n * @packageDocumentation\r\n * @module @taquito/ledger-signer\r\n */\n\nvar DerivationType;\n\n(function (DerivationType) {\n  DerivationType[DerivationType[\"ED25519\"] = 0] = \"ED25519\";\n  DerivationType[DerivationType[\"SECP256K1\"] = 1] = \"SECP256K1\";\n  DerivationType[DerivationType[\"P256\"] = 2] = \"P256\"; // tz3\n})(DerivationType || (DerivationType = {}));\n\nvar HDPathTemplate = function (account) {\n  return \"44'/1729'/\" + account + \"'/0'\";\n};\n/**\r\n *\r\n * @description Implementation of the Signer interface that will allow signing operation from a Ledger Nano device\r\n *\r\n * @param transport A transport instance from LedgerJS libraries depending on the platform used (e.g. Web, Node)\r\n * @param path The ledger derivation path (default is \"44'/1729'/0'/0'\")\r\n * @param prompt Whether to prompt the ledger for public key (default is true)\r\n * @param derivationType The value which defines the curve to use (DerivationType.ED25519(default), DerivationType.SECP256K1, DerivationType.P256)\r\n *\r\n * @example\r\n * ```\r\n * import TransportNodeHid from \"@ledgerhq/hw-transport-node-hid\";\r\n * const transport = await TransportNodeHid.create();\r\n * const ledgerSigner = new LedgerSigner(transport, \"44'/1729'/0'/0'\", false, DerivationType.ED25519);\r\n * ```\r\n *\r\n * @example\r\n * ```\r\n * import TransportU2F from \"@ledgerhq/hw-transport-u2f\";\r\n * const transport = await TransportU2F.create();\r\n * const ledgerSigner = new LedgerSigner(transport, \"44'/1729'/0'/0'\", true, DerivationType.SECP256K1);\r\n * ```\r\n */\n\n\nvar LedgerSigner =\n/** @class */\nfunction () {\n  function LedgerSigner(transport, path, prompt, derivationType) {\n    if (path === void 0) {\n      path = \"44'/1729'/0'/0'\";\n    }\n\n    if (prompt === void 0) {\n      prompt = true;\n    }\n\n    if (derivationType === void 0) {\n      derivationType = DerivationType.ED25519;\n    }\n\n    this.transport = transport;\n    this.path = path;\n    this.prompt = prompt;\n    this.derivationType = derivationType; // constants for APDU requests (https://github.com/obsidiansystems/ledger-app-tezos/blob/master/APDUs.md)\n\n    this.CLA = 0x80; // Instruction class (always 0x80)\n\n    this.INS_GET_PUBLIC_KEY = 0x02; // Instruction code to get the ledger’s internal public key without prompt\n\n    this.INS_PROMPT_PUBLIC_KEY = 0x03; // Instruction code to get the ledger’s internal public key with prompt\n\n    this.INS_SIGN = 0x04; // Sign a message with the ledger’s key\n\n    this.FIRST_MESSAGE_SEQUENCE = 0X00;\n    this.LAST_MESSAGE_SEQUENCE = 0X81;\n    this.OTHER_MESSAGE_SEQUENCE = 0X01;\n    this.transport.setScrambleKey('XTZ');\n\n    if (!path.startsWith(\"44'/1729'\")) {\n      throw new Error(\"The derivation path must start with 44'/1729'\");\n    }\n\n    if (!Object.values(DerivationType).includes(derivationType)) {\n      throw new Error(\"The derivation type must be DerivationType.ED25519, DerivationType.SECP256K1 or DerivationType.P256\");\n    }\n  }\n\n  LedgerSigner.prototype.publicKeyHash = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!!this._publicKeyHash) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.publicKey()];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            if (this._publicKeyHash) {\n              return [2\n              /*return*/\n              , this._publicKeyHash];\n            }\n\n            throw new Error(\"Unable to get the public key hash.\");\n        }\n      });\n    });\n  };\n\n  LedgerSigner.prototype.publicKey = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var responseLedger, publicKeyLength, rawPublicKey, compressedPublicKey, prefixes, publicKey, publicKeyHash;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this._publicKey) {\n              return [2\n              /*return*/\n              , this._publicKey];\n            }\n\n            return [4\n            /*yield*/\n            , this.getLedgerpublicKey()];\n\n          case 1:\n            responseLedger = _a.sent();\n            publicKeyLength = responseLedger[0];\n            rawPublicKey = responseLedger.slice(1, 1 + publicKeyLength);\n            compressedPublicKey = compressPublicKey(rawPublicKey, this.derivationType);\n            prefixes = this.getPrefixes();\n            publicKey = b58cencode(compressedPublicKey, prefixes.prefPk);\n            return [4\n            /*yield*/\n            , sodium.ready];\n\n          case 2:\n            _a.sent();\n\n            publicKeyHash = b58cencode(sodium.crypto_generichash(20, compressedPublicKey), prefixes.prefPkh);\n            this._publicKey = publicKey;\n            this._publicKeyHash = publicKeyHash;\n            return [2\n            /*return*/\n            , publicKey];\n        }\n      });\n    });\n  };\n\n  LedgerSigner.prototype.getLedgerpublicKey = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var ins, responseLedger;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            ins = this.INS_PROMPT_PUBLIC_KEY;\n\n            if (this.prompt === false) {\n              ins = this.INS_GET_PUBLIC_KEY;\n            }\n\n            return [4\n            /*yield*/\n            , this.transport.send(this.CLA, ins, this.FIRST_MESSAGE_SEQUENCE, this.derivationType, transformPathToBuffer(this.path))];\n\n          case 1:\n            responseLedger = _a.sent();\n            return [2\n            /*return*/\n            , responseLedger];\n\n          case 2:\n            _a.sent();\n\n            throw new Error(\"Unable to retrieve public key\");\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  LedgerSigner.prototype.secretKey = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        throw new Error('Secret key cannot be exposed');\n      });\n    });\n  };\n\n  LedgerSigner.prototype.sign = function (bytes, watermark) {\n    return __awaiter(this, void 0, void 0, function () {\n      var watermarkedBytes, watermarkedBytes2buff, messageToSend, ledgerResponse, signature, idxLengthRVal, rValue, idxLengthSVal, sValue, signatureBuffer;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            watermarkedBytes = appendWatermark(bytes, watermark);\n            watermarkedBytes2buff = Buffer.from(watermarkedBytes, \"hex\");\n            messageToSend = [];\n            messageToSend.push(transformPathToBuffer(this.path));\n            messageToSend = chunkOperation(messageToSend, watermarkedBytes2buff);\n            return [4\n            /*yield*/\n            , this.signWithLedger(messageToSend)];\n\n          case 1:\n            ledgerResponse = _a.sent();\n\n            if (this.derivationType === DerivationType.ED25519) {\n              signature = ledgerResponse.slice(0, ledgerResponse.length - 2).toString('hex');\n            } else {\n              if (!validateResponse(ledgerResponse)) {\n                throw new Error('Cannot parse ledger response.');\n              }\n\n              idxLengthRVal = 3;\n              rValue = extractValue(idxLengthRVal, ledgerResponse);\n              idxLengthSVal = rValue.idxValueStart + rValue.length + 1;\n              sValue = extractValue(idxLengthSVal, ledgerResponse);\n              signatureBuffer = Buffer.concat([rValue.buffer, sValue.buffer]);\n              signature = signatureBuffer.toString('hex');\n            }\n\n            return [2\n            /*return*/\n            , {\n              bytes: bytes,\n              sig: b58cencode(signature, prefix[Prefix.SIG]),\n              prefixSig: b58cencode(signature, this.getPrefixes().prefSig),\n              sbytes: bytes + signature\n            }];\n        }\n      });\n    });\n  };\n\n  LedgerSigner.prototype.signWithLedger = function (message) {\n    return __awaiter(this, void 0, void 0, function () {\n      var ledgerResponse, i, p1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.transport.send(this.CLA, this.INS_SIGN, this.FIRST_MESSAGE_SEQUENCE, this.derivationType, message[0])];\n\n          case 1:\n            ledgerResponse = _a.sent();\n            i = 1;\n            _a.label = 2;\n\n          case 2:\n            if (!(i < message.length)) return [3\n            /*break*/\n            , 5];\n            p1 = i === message.length - 1 ? this.LAST_MESSAGE_SEQUENCE : this.OTHER_MESSAGE_SEQUENCE;\n            return [4\n            /*yield*/\n            , this.transport.send(this.CLA, this.INS_SIGN, p1, this.derivationType, message[i])];\n\n          case 3:\n            ledgerResponse = _a.sent();\n            _a.label = 4;\n\n          case 4:\n            i++;\n            return [3\n            /*break*/\n            , 2];\n\n          case 5:\n            return [2\n            /*return*/\n            , ledgerResponse];\n        }\n      });\n    });\n  };\n\n  LedgerSigner.prototype.getPrefixes = function () {\n    if (this.derivationType === DerivationType.ED25519) {\n      return {\n        prefPk: prefix[Prefix.EDPK],\n        prefPkh: prefix[Prefix.TZ1],\n        prefSig: prefix[Prefix.EDSIG]\n      };\n    } else if (this.derivationType === DerivationType.SECP256K1) {\n      return {\n        prefPk: prefix[Prefix.SPPK],\n        prefPkh: prefix[Prefix.TZ2],\n        prefSig: prefix[Prefix.SPSIG]\n      };\n    } else {\n      return {\n        prefPk: prefix[Prefix.P2PK],\n        prefPkh: prefix[Prefix.TZ3],\n        prefSig: prefix[Prefix.P2SIG]\n      };\n    }\n  };\n\n  return LedgerSigner;\n}();\n\nexport { DerivationType, HDPathTemplate, LedgerSigner, VERSION };","map":{"version":3,"sources":["../src/utils.ts","../src/version.ts","../src/taquito-ledger-signer.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Some code in this file is adapted from sotez\n * Copyright (c) 2018 Andrew Kishino\n */\n\nimport { DerivationType } from './taquito-ledger-signer';\n\nconst MAX_CHUNK_SIZE = 230;\n\n/**\n *\n * @description Convert the path to a buffer that will be used as LC and CDATA in the APDU send to the ledger device (https://github.com/obsidiansystems/ledger-app-tezos/blob/master/APDUs.md)  \n *\n * @param path The ledger derivation path (default is \"44'/1729'/0'/0'\")\n * @returns A buffer where the first element is the length of the path (default is 4), then 3 bytes for each number of the path to which is added 0x8000000\n */\nexport function transformPathToBuffer(path : string) : Buffer {\n    const result: any[] = [];\n    const components = path.split('/');\n    components.forEach((element) => {\n        let toNumber = parseInt(element, 10);\n        if (Number.isNaN(toNumber)) {\n            return;\n        }\n        if (element.length > 1 && element[element.length - 1] === \"'\") {\n            toNumber += 0x80000000;\n        }\n        result.push(toNumber);\n    });\n    let buffer = Buffer.alloc(1 + result.length * 4);\n    buffer[0] = result.length;\n    result.forEach((element, index) => {\n        buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return buffer;\n}\n\n/**\n *\n * @description Converts uncompressed ledger key to standard tezos binary representation  \n */\nexport function compressPublicKey(publicKey: Buffer, curve: DerivationType) {\n    if (curve === 0x00){\n        publicKey = publicKey.slice(1);\n    } else {\n        publicKey[0] = 0x02 + (publicKey[64] & 0x01);\n        publicKey = publicKey.slice(0, 33);\n    }\n    return publicKey\n}\n\nexport function appendWatermark(bytes: string, watermark?: Uint8Array): string {\n    let transactionHex = bytes;\n        if (typeof watermark !== 'undefined') {\n          let hexWatermark = Buffer.from(watermark).toString('hex');\n          transactionHex = hexWatermark.concat(bytes);\n        }\n        return transactionHex;\n}\n\n/**\n *\n * @description In order not to exceed the data length allowed by the Ledger device, split the operation into buffers of 230 bytes (max) and add them to the message to send to the Ledger\n * @param messageToSend The message to send to the Ledger device\n * @param operation The operation which will be chunk if its length is over 230 bytes\n * @returns The instruction to send to the Ledger device\n */\nexport function chunkOperation(messageToSend: any, operation: Buffer){\n    let offset = 0;\n    while (offset !== operation.length) {\n        let chunkSize = offset + MAX_CHUNK_SIZE >= operation.length ? operation.length - offset : MAX_CHUNK_SIZE;\n        const buff = Buffer.alloc(chunkSize);\n        operation.copy(buff, 0, offset, offset + chunkSize);\n        messageToSend.push(buff);\n        offset += chunkSize;\n        }\n    return messageToSend; \n}\n\n/**\n *\n * @description Verify if the signature returned by the ledger for tz2 and tz3 is valid\n * @param response The signature returned by the Ledger (return from the signWithLedger function)\n * @returns True if valid, false otherwise\n */\nexport function validateResponse(response: Buffer) : boolean\n{\n    let valid = true;\n    if (response[0] !== 0x31 && response[0] !== 0x30) {\n        valid = false;\n    }\n    if (response[1] + 4 !== response.length) {\n        valid = false;\n    }\n    if (response[2] !== 0x02) {\n        valid = false;\n    }\n    let rLength = response[3];\n    if (response[4 + rLength] !== 0x02) {\n        valid = false;\n    }\n\n    let idxLengthSVal = 5 + rLength;\n    let sLength = response[idxLengthSVal];\n    if((idxLengthSVal + 1 + sLength) + 2 !== response.length) {\n        valid = false;\n    }\n    return valid;\n}\n\n/**\n *\n * @description Extract a part of the response returned by the Ledger\n * @param idxLength The index in the response from the Ledger that corresponds to the length of the part to extract\n * @param response The signature returned by the Ledger (return from the signWithLedger function)\n * @returns An object that contains the extracted buffer, the index where it starts in the response and the length of the extracted part\n */\nexport function extractValue(idxLength: number, response: Buffer) {\n    const buffer = Buffer.alloc(32);\n    buffer.fill(0);\n\n    let length = response[idxLength];           \n    let idxValueStart = idxLength + 1;\n    if (length > 32) {\n        idxValueStart += length - 32;\n        length = 32;\n    }\n    response.copy(buffer, 32 - length, idxValueStart, idxValueStart + length);\n    return {buffer, idxValueStart, length};\n}","\n// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\n/* tslint:disable */\nexport const VERSION = {\n    \"commitHash\": \"a8e9548e650215186f661033b59299ace72c9ee6\",\n    \"version\": \"9.2.0\"\n};\n/* tslint:enable */\n","/**\n * @packageDocumentation\n * @module @taquito/ledger-signer\n */\n\nimport { Signer } from '@taquito/taquito';\nimport Transport from '@ledgerhq/hw-transport';\nimport { b58cencode, prefix, Prefix } from '@taquito/utils';\nimport {\n  appendWatermark,\n  transformPathToBuffer,\n  compressPublicKey,\n  chunkOperation,\n  validateResponse,\n  extractValue\n} from './utils';\nimport sodium from 'libsodium-wrappers';\n\nexport type LedgerTransport = Pick<Transport<string>, 'send' | 'decorateAppAPIMethods' | 'setScrambleKey'>\n\nexport enum DerivationType {\n  ED25519 = 0x00, // tz1\n  SECP256K1 = 0x01, // tz2\n  P256 = 0x02 // tz3\n};\n\nexport const HDPathTemplate = (account: number) => {\n  return `44'/1729'/${account}'/0'`;\n};\n\nexport { VERSION } from './version';\n\n/**\n *\n * @description Implementation of the Signer interface that will allow signing operation from a Ledger Nano device \n *\n * @param transport A transport instance from LedgerJS libraries depending on the platform used (e.g. Web, Node)\n * @param path The ledger derivation path (default is \"44'/1729'/0'/0'\")\n * @param prompt Whether to prompt the ledger for public key (default is true)\n * @param derivationType The value which defines the curve to use (DerivationType.ED25519(default), DerivationType.SECP256K1, DerivationType.P256)\n * \n * @example\n * ```\n * import TransportNodeHid from \"@ledgerhq/hw-transport-node-hid\";\n * const transport = await TransportNodeHid.create();\n * const ledgerSigner = new LedgerSigner(transport, \"44'/1729'/0'/0'\", false, DerivationType.ED25519);\n * ```\n * \n * @example\n * ```\n * import TransportU2F from \"@ledgerhq/hw-transport-u2f\";\n * const transport = await TransportU2F.create();\n * const ledgerSigner = new LedgerSigner(transport, \"44'/1729'/0'/0'\", true, DerivationType.SECP256K1);\n * ```\n */\nexport class LedgerSigner implements Signer {\n\n  // constants for APDU requests (https://github.com/obsidiansystems/ledger-app-tezos/blob/master/APDUs.md)\n  private readonly CLA = 0x80; // Instruction class (always 0x80)\n  private readonly INS_GET_PUBLIC_KEY = 0x02; // Instruction code to get the ledger’s internal public key without prompt\n  private readonly INS_PROMPT_PUBLIC_KEY = 0x03; // Instruction code to get the ledger’s internal public key with prompt\n  private readonly INS_SIGN = 0x04; // Sign a message with the ledger’s key\n  private readonly FIRST_MESSAGE_SEQUENCE = 0X00;\n  private readonly LAST_MESSAGE_SEQUENCE = 0X81;\n  private readonly OTHER_MESSAGE_SEQUENCE = 0X01;\n\n  private _publicKey?: string;\n  private _publicKeyHash?: string;\n  constructor(\n    private transport: LedgerTransport,\n    private path: string = \"44'/1729'/0'/0'\",\n    private prompt: boolean = true,\n    private derivationType: DerivationType = DerivationType.ED25519\n  ) {\n    this.transport.setScrambleKey('XTZ')\n    if (!path.startsWith(\"44'/1729'\")) {\n      throw new Error(\"The derivation path must start with 44'/1729'\");\n    }\n    if (!Object.values(DerivationType).includes(derivationType)) {\n      throw new Error(\"The derivation type must be DerivationType.ED25519, DerivationType.SECP256K1 or DerivationType.P256\")\n    }\n  }\n\n  async publicKeyHash(): Promise<string> {\n    if (!this._publicKeyHash) {\n      await this.publicKey();\n    }\n    if (this._publicKeyHash) {\n      return this._publicKeyHash;\n    }\n    throw new Error(`Unable to get the public key hash.`)\n  }\n\n  async publicKey(): Promise<string> {\n    if (this._publicKey) {\n      return this._publicKey;\n    }\n    const responseLedger = await this.getLedgerpublicKey();\n    const publicKeyLength = responseLedger[0];\n    const rawPublicKey = responseLedger.slice(1, 1 + publicKeyLength);\n    const compressedPublicKey = compressPublicKey(rawPublicKey, this.derivationType);\n\n    const prefixes = this.getPrefixes();\n    const publicKey = b58cencode(compressedPublicKey, prefixes.prefPk);\n    await sodium.ready;\n    const publicKeyHash = b58cencode(sodium.crypto_generichash(20, compressedPublicKey), prefixes.prefPkh);\n\n    this._publicKey = publicKey;\n    this._publicKeyHash = publicKeyHash;\n    return publicKey;\n  }\n\n  private async getLedgerpublicKey(): Promise<Buffer> {\n    try {\n      let ins = this.INS_PROMPT_PUBLIC_KEY;\n      if (this.prompt === false) {\n        ins = this.INS_GET_PUBLIC_KEY;\n      }\n      const responseLedger = await this.transport.send(this.CLA, ins, this.FIRST_MESSAGE_SEQUENCE, this.derivationType, transformPathToBuffer(this.path));\n      return responseLedger;\n    }\n    catch (error) {\n      throw new Error(\"Unable to retrieve public key\")\n    }\n  }\n\n  async secretKey(): Promise<string> {\n    throw new Error('Secret key cannot be exposed');\n  }\n\n  async sign(bytes: string, watermark?: Uint8Array) {\n    const watermarkedBytes = appendWatermark(bytes, watermark);\n    const watermarkedBytes2buff = Buffer.from(watermarkedBytes, \"hex\");\n    let messageToSend = [];\n    messageToSend.push(transformPathToBuffer(this.path));\n    messageToSend = chunkOperation(messageToSend, watermarkedBytes2buff)\n    let ledgerResponse = await this.signWithLedger(messageToSend);\n    let signature;\n    if (this.derivationType === DerivationType.ED25519) {\n      signature = ledgerResponse.slice(0, ledgerResponse.length - 2).toString('hex');\n    } else {\n      if (!validateResponse(ledgerResponse)) {\n        throw new Error('Cannot parse ledger response.');\n      }\n      const idxLengthRVal = 3; // Third element of response is length of r value\n      const rValue = extractValue(idxLengthRVal, ledgerResponse)\n      let idxLengthSVal = rValue.idxValueStart + rValue.length + 1;\n      const sValue = extractValue(idxLengthSVal, ledgerResponse);\n      const signatureBuffer = Buffer.concat([rValue.buffer, sValue.buffer])\n      signature = signatureBuffer.toString('hex');\n    }\n\n    return {\n      bytes,\n      sig: b58cencode(signature, prefix[Prefix.SIG]),\n      prefixSig: b58cencode(signature, this.getPrefixes().prefSig),\n      sbytes: bytes + signature\n    };\n  }\n\n  private async signWithLedger(message: any): Promise<Buffer> {\n    // first element of the message represents the path\n    let ledgerResponse = await this.transport.send(this.CLA, this.INS_SIGN, this.FIRST_MESSAGE_SEQUENCE, this.derivationType, message[0]);\n    for (let i = 1; i < message.length; i++) {\n      let p1 = (i === message.length - 1) ? this.LAST_MESSAGE_SEQUENCE : this.OTHER_MESSAGE_SEQUENCE;\n      ledgerResponse = await this.transport.send(this.CLA, this.INS_SIGN, p1, this.derivationType, message[i]);\n    }\n    return ledgerResponse;\n  }\n\n  private getPrefixes() {\n    if (this.derivationType === DerivationType.ED25519) {\n      return {\n        prefPk: prefix[Prefix.EDPK],\n        prefPkh: prefix[Prefix.TZ1],\n        prefSig: prefix[Prefix.EDSIG]\n      }\n    } else if (this.derivationType === DerivationType.SECP256K1) {\n      return {\n        prefPk: prefix[Prefix.SPPK],\n        prefPkh: prefix[Prefix.TZ2],\n        prefSig: prefix[Prefix.SPSIG]\n      }\n    } else {\n      return {\n        prefPk: prefix[Prefix.P2PK],\n        prefPkh: prefix[Prefix.TZ3],\n        prefSig: prefix[Prefix.P2SIG]\n      }\n    }\n\n  }\n}"]},"metadata":{},"sourceType":"module"}