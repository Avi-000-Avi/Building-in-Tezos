{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { keys } from '../utils/utils';\nimport { MatrixRoom, MatrixRoomStatus } from './models/MatrixRoom';\nimport { StorageKey } from '..';\nconst PRESERVED_FIELDS = ['syncToken', 'rooms'];\n/**\n * The class managing the local state of matrix\n */\n\nexport class MatrixClientStore {\n  constructor(storage) {\n    this.storage = storage;\n    /**\n     * The state of the matrix client\n     */\n\n    this.state = {\n      isRunning: false,\n      userId: undefined,\n      deviceId: undefined,\n      txnNo: 0,\n      accessToken: undefined,\n      syncToken: undefined,\n      pollingTimeout: undefined,\n      pollingRetries: 0,\n      rooms: {}\n    };\n    /**\n     * Listeners that will be called when the state changes\n     */\n\n    this.onStateChangedListeners = new Map();\n    /**\n     * A promise that resolves once the client is ready\n     */\n\n    this.waitReadyPromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this.initFromStorage();\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    }));\n  }\n  /**\n   * Get an item from the state\n   *\n   * @param key\n   */\n\n\n  get(key) {\n    return this.state[key];\n  }\n  /**\n   * Get the room from an ID or room instance\n   *\n   * @param roomOrId\n   */\n\n\n  getRoom(roomOrId) {\n    const room = MatrixRoom.from(roomOrId, MatrixRoomStatus.UNKNOWN);\n    return this.state.rooms[room.id] || room;\n  }\n  /**\n   * Update the state with a partial state\n   *\n   * @param stateUpdate\n   */\n\n\n  update(stateUpdate) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.waitReady();\n      const oldState = Object.assign({}, this.state);\n      this.setState(stateUpdate);\n      this.updateStorage(stateUpdate);\n      this.notifyListeners(oldState, this.state, stateUpdate);\n    });\n  }\n  /**\n   * Register listeners that are called once the state has changed\n   *\n   * @param listener\n   * @param subscribed\n   */\n\n\n  onStateChanged(listener, ...subscribed) {\n    if (subscribed.length > 0) {\n      subscribed.forEach(key => {\n        this.onStateChangedListeners.set(key, listener);\n      });\n    } else {\n      this.onStateChangedListeners.set('all', listener);\n    }\n  }\n  /**\n   * A promise that resolves once the client is ready\n   */\n\n\n  waitReady() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.waitReadyPromise;\n    });\n  }\n  /**\n   * Read state from storage\n   */\n\n\n  initFromStorage() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const preserved = yield this.storage.get(StorageKey.MATRIX_PRESERVED_STATE);\n      this.setState(preserved);\n    });\n  }\n  /**\n   * Prepare data before persisting it in storage\n   *\n   * @param toStore\n   */\n\n\n  prepareData(toStore) {\n    const requiresPreparation = ['rooms'];\n    const toStoreCopy = requiresPreparation.some(key => toStore[key] !== undefined) ? JSON.parse(JSON.stringify(toStore)) : toStore; // there is no need for saving messages in a persistent storage\n\n    Object.values(toStoreCopy.rooms || {}).forEach(room => {\n      room.messages = [];\n    });\n    return toStoreCopy;\n  }\n  /**\n   * Persist state in storage\n   *\n   * @param stateUpdate\n   */\n\n\n  updateStorage(stateUpdate) {\n    const updatedCachedFields = Object.entries(stateUpdate).filter(([key, value]) => PRESERVED_FIELDS.includes(key) && Boolean(value));\n\n    if (updatedCachedFields.length > 0) {\n      const filteredState = {};\n      PRESERVED_FIELDS.forEach(key => {\n        filteredState[key] = this.state[key];\n      });\n      this.storage.set(StorageKey.MATRIX_PRESERVED_STATE, this.prepareData(filteredState));\n    }\n  }\n  /**\n   * Set the state\n   *\n   * @param partialState\n   */\n\n\n  setState(partialState) {\n    this.state = {\n      isRunning: partialState.isRunning || this.state.isRunning,\n      userId: partialState.userId || this.state.userId,\n      deviceId: partialState.deviceId || this.state.deviceId,\n      txnNo: partialState.txnNo || this.state.txnNo,\n      accessToken: partialState.accessToken || this.state.accessToken,\n      syncToken: partialState.syncToken || this.state.syncToken,\n      pollingTimeout: partialState.pollingTimeout || this.state.pollingTimeout,\n      pollingRetries: partialState.pollingRetries || this.state.pollingRetries,\n      rooms: this.mergeRooms(this.state.rooms, partialState.rooms)\n    };\n  }\n  /**\n   * Merge room records and eliminate duplicates\n   *\n   * @param oldRooms\n   * @param _newRooms\n   */\n\n\n  mergeRooms(oldRooms, _newRooms) {\n    if (!_newRooms) {\n      return oldRooms;\n    }\n\n    const newRooms = Array.isArray(_newRooms) ? _newRooms : Object.values(_newRooms);\n    const merged = Object.assign({}, oldRooms);\n    newRooms.forEach(newRoom => {\n      merged[newRoom.id] = MatrixRoom.merge(newRoom, oldRooms[newRoom.id]);\n    });\n    return merged;\n  }\n  /**\n   * Notify listeners of state changes\n   *\n   * @param oldState\n   * @param newState\n   * @param stateChange\n   */\n\n\n  notifyListeners(oldState, newState, stateChange) {\n    const listenForAll = this.onStateChangedListeners.get('all');\n\n    if (listenForAll) {\n      listenForAll(oldState, newState, stateChange);\n    }\n\n    keys(stateChange).filter(key => stateChange[key] !== undefined).forEach(key => {\n      const listener = this.onStateChangedListeners.get(key);\n\n      if (listener) {\n        listener(oldState, newState, stateChange);\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/matrix-client/MatrixClientStore.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { keys } from '../utils/utils';\nimport { MatrixRoom, MatrixRoomStatus } from './models/MatrixRoom';\nimport { StorageKey } from '..';\nconst PRESERVED_FIELDS = ['syncToken', 'rooms'];\n/**\n * The class managing the local state of matrix\n */\nexport class MatrixClientStore {\n    constructor(storage) {\n        this.storage = storage;\n        /**\n         * The state of the matrix client\n         */\n        this.state = {\n            isRunning: false,\n            userId: undefined,\n            deviceId: undefined,\n            txnNo: 0,\n            accessToken: undefined,\n            syncToken: undefined,\n            pollingTimeout: undefined,\n            pollingRetries: 0,\n            rooms: {}\n        };\n        /**\n         * Listeners that will be called when the state changes\n         */\n        this.onStateChangedListeners = new Map();\n        /**\n         * A promise that resolves once the client is ready\n         */\n        this.waitReadyPromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this.initFromStorage();\n                resolve();\n            }\n            catch (error) {\n                reject(error);\n            }\n        }));\n    }\n    /**\n     * Get an item from the state\n     *\n     * @param key\n     */\n    get(key) {\n        return this.state[key];\n    }\n    /**\n     * Get the room from an ID or room instance\n     *\n     * @param roomOrId\n     */\n    getRoom(roomOrId) {\n        const room = MatrixRoom.from(roomOrId, MatrixRoomStatus.UNKNOWN);\n        return this.state.rooms[room.id] || room;\n    }\n    /**\n     * Update the state with a partial state\n     *\n     * @param stateUpdate\n     */\n    update(stateUpdate) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.waitReady();\n            const oldState = Object.assign({}, this.state);\n            this.setState(stateUpdate);\n            this.updateStorage(stateUpdate);\n            this.notifyListeners(oldState, this.state, stateUpdate);\n        });\n    }\n    /**\n     * Register listeners that are called once the state has changed\n     *\n     * @param listener\n     * @param subscribed\n     */\n    onStateChanged(listener, ...subscribed) {\n        if (subscribed.length > 0) {\n            subscribed.forEach((key) => {\n                this.onStateChangedListeners.set(key, listener);\n            });\n        }\n        else {\n            this.onStateChangedListeners.set('all', listener);\n        }\n    }\n    /**\n     * A promise that resolves once the client is ready\n     */\n    waitReady() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.waitReadyPromise;\n        });\n    }\n    /**\n     * Read state from storage\n     */\n    initFromStorage() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const preserved = yield this.storage.get(StorageKey.MATRIX_PRESERVED_STATE);\n            this.setState(preserved);\n        });\n    }\n    /**\n     * Prepare data before persisting it in storage\n     *\n     * @param toStore\n     */\n    prepareData(toStore) {\n        const requiresPreparation = ['rooms'];\n        const toStoreCopy = requiresPreparation.some((key) => toStore[key] !== undefined)\n            ? JSON.parse(JSON.stringify(toStore))\n            : toStore;\n        // there is no need for saving messages in a persistent storage\n        Object.values(toStoreCopy.rooms || {}).forEach((room) => {\n            room.messages = [];\n        });\n        return toStoreCopy;\n    }\n    /**\n     * Persist state in storage\n     *\n     * @param stateUpdate\n     */\n    updateStorage(stateUpdate) {\n        const updatedCachedFields = Object.entries(stateUpdate).filter(([key, value]) => PRESERVED_FIELDS.includes(key) && Boolean(value));\n        if (updatedCachedFields.length > 0) {\n            const filteredState = {};\n            PRESERVED_FIELDS.forEach((key) => {\n                filteredState[key] = this.state[key];\n            });\n            this.storage.set(StorageKey.MATRIX_PRESERVED_STATE, this.prepareData(filteredState));\n        }\n    }\n    /**\n     * Set the state\n     *\n     * @param partialState\n     */\n    setState(partialState) {\n        this.state = {\n            isRunning: partialState.isRunning || this.state.isRunning,\n            userId: partialState.userId || this.state.userId,\n            deviceId: partialState.deviceId || this.state.deviceId,\n            txnNo: partialState.txnNo || this.state.txnNo,\n            accessToken: partialState.accessToken || this.state.accessToken,\n            syncToken: partialState.syncToken || this.state.syncToken,\n            pollingTimeout: partialState.pollingTimeout || this.state.pollingTimeout,\n            pollingRetries: partialState.pollingRetries || this.state.pollingRetries,\n            rooms: this.mergeRooms(this.state.rooms, partialState.rooms)\n        };\n    }\n    /**\n     * Merge room records and eliminate duplicates\n     *\n     * @param oldRooms\n     * @param _newRooms\n     */\n    mergeRooms(oldRooms, _newRooms) {\n        if (!_newRooms) {\n            return oldRooms;\n        }\n        const newRooms = Array.isArray(_newRooms) ? _newRooms : Object.values(_newRooms);\n        const merged = Object.assign({}, oldRooms);\n        newRooms.forEach((newRoom) => {\n            merged[newRoom.id] = MatrixRoom.merge(newRoom, oldRooms[newRoom.id]);\n        });\n        return merged;\n    }\n    /**\n     * Notify listeners of state changes\n     *\n     * @param oldState\n     * @param newState\n     * @param stateChange\n     */\n    notifyListeners(oldState, newState, stateChange) {\n        const listenForAll = this.onStateChangedListeners.get('all');\n        if (listenForAll) {\n            listenForAll(oldState, newState, stateChange);\n        }\n        keys(stateChange)\n            .filter((key) => stateChange[key] !== undefined)\n            .forEach((key) => {\n            const listener = this.onStateChangedListeners.get(key);\n            if (listener) {\n                listener(oldState, newState, stateChange);\n            }\n        });\n    }\n}\n//# sourceMappingURL=MatrixClientStore.js.map"]},"metadata":{},"sourceType":"module"}