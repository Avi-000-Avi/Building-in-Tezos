{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport * as sodium from 'libsodium-wrappers';\nimport { BEACON_VERSION } from '../../constants';\nimport { decryptCryptoboxPayload, encryptCryptoboxPayload } from '../../utils/crypto';\nimport { generateGUID } from '../../utils/generate-uuid';\nimport { CommunicationClient } from './CommunicationClient';\n/**\n * @internalapi\n *\n *\n */\n\nexport class MessageBasedClient extends CommunicationClient {\n  constructor(name, keyPair) {\n    super(keyPair);\n    this.name = name;\n    /**\n     * The listeners that will be notified of new messages\n     */\n\n    this.activeListeners = new Map();\n    this.init().catch(console.error);\n  }\n  /**\n   * start the client and make sure all dependencies are ready\n   */\n\n\n  start() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield sodium.ready;\n    });\n  }\n  /**\n   * Get the pairing request information. This will be shared with the peer during the connection setup\n   */\n\n\n  getPairingRequestInfo() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return {\n        id: yield generateGUID(),\n        type: 'postmessage-pairing-request',\n        name: this.name,\n        version: BEACON_VERSION,\n        publicKey: yield this.getPublicKey()\n      };\n    });\n  }\n  /**\n   * Get the pairing response information. This will be shared with the peer during the connection setup\n   */\n\n\n  getPairingResponseInfo(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return {\n        id: request.id,\n        type: 'postmessage-pairing-response',\n        name: this.name,\n        version: BEACON_VERSION,\n        publicKey: yield this.getPublicKey()\n      };\n    });\n  }\n  /**\n   * Unsubscribe from encrypted messages from a specific peer\n   *\n   * @param senderPublicKey\n   */\n\n\n  unsubscribeFromEncryptedMessage(senderPublicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const listener = this.activeListeners.get(senderPublicKey);\n\n      if (!listener) {\n        return;\n      }\n\n      this.activeListeners.delete(senderPublicKey);\n    });\n  }\n  /**\n   * Unsubscribe from all encrypted messages\n   */\n\n\n  unsubscribeFromEncryptedMessages() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.activeListeners.clear();\n    });\n  }\n  /**\n   * Decrypt a message from a specific peer\n   *\n   * @param senderPublicKey\n   * @param payload\n   */\n\n\n  decryptMessage(senderPublicKey, payload) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        sharedRx\n      } = yield this.createCryptoBoxServer(senderPublicKey, this.keyPair.privateKey);\n      const hexPayload = Buffer.from(payload, 'hex');\n\n      if (hexPayload.length >= sodium.crypto_secretbox_NONCEBYTES + sodium.crypto_secretbox_MACBYTES) {\n        try {\n          return yield decryptCryptoboxPayload(hexPayload, sharedRx);\n        } catch (decryptionError) {\n          /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n        }\n      }\n\n      throw new Error('Could not decrypt message');\n    });\n  }\n  /**\n   * Encrypt a message for a specific publicKey (receiver)\n   *\n   * @param recipientPublicKey\n   * @param message\n   */\n\n\n  encryptMessage(recipientPublicKey, message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        sharedTx\n      } = yield this.createCryptoBoxClient(recipientPublicKey, this.keyPair.privateKey);\n      return encryptCryptoboxPayload(message, sharedTx);\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../../src/transports/clients/MessageBasedClient.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,KAAK,MAAZ,MAAwB,oBAAxB;AACA,SAAS,cAAT,QAA+B,iBAA/B;AAGA,SAAS,uBAAT,EAAkC,uBAAlC,QAAiE,oBAAjE;AACA,SAAS,YAAT,QAA6B,2BAA7B;AACA,SAAS,mBAAT,QAAoC,uBAApC;AAEA;;;;AAIG;;AACH,OAAM,MAAgB,kBAAhB,SAA2C,mBAA3C,CAA8D;AAMlE,EAAA,WAAA,CAA+B,IAA/B,EAA6C,OAA7C,EAAoE;AAClE,UAAM,OAAN;AAD6B,SAAA,IAAA,GAAA,IAAA;AAL/B;;AAEG;;AACyB,SAAA,eAAA,GAAwC,IAAI,GAAJ,EAAxC;AAI1B,SAAK,IAAL,GAAY,KAAZ,CAAkB,OAAO,CAAC,KAA1B;AACD;AAED;;AAEG;;;AACU,EAAA,KAAK,GAAA;;AAChB,YAAM,MAAM,CAAC,KAAb;AACD,K;AAAA;AAED;;AAEG;;;AACU,EAAA,qBAAqB,GAAA;;AAChC,aAAO;AACL,QAAA,EAAE,EAAE,MAAM,YAAY,EADjB;AAEL,QAAA,IAAI,EAAE,6BAFD;AAGL,QAAA,IAAI,EAAE,KAAK,IAHN;AAIL,QAAA,OAAO,EAAE,cAJJ;AAKL,QAAA,SAAS,EAAE,MAAM,KAAK,YAAL;AALZ,OAAP;AAOD,K;AAAA;AAED;;AAEG;;;AACU,EAAA,sBAAsB,CACjC,OADiC,EACC;;AAElC,aAAO;AACL,QAAA,EAAE,EAAE,OAAO,CAAC,EADP;AAEL,QAAA,IAAI,EAAE,8BAFD;AAGL,QAAA,IAAI,EAAE,KAAK,IAHN;AAIL,QAAA,OAAO,EAAE,cAJJ;AAKL,QAAA,SAAS,EAAE,MAAM,KAAK,YAAL;AALZ,OAAP;AAOD,K;AAAA;AAED;;;;AAIG;;;AACU,EAAA,+BAA+B,CAAC,eAAD,EAAwB;;AAClE,YAAM,QAAQ,GAAG,KAAK,eAAL,CAAqB,GAArB,CAAyB,eAAzB,CAAjB;;AACA,UAAI,CAAC,QAAL,EAAe;AACb;AACD;;AAED,WAAK,eAAL,CAAqB,MAArB,CAA4B,eAA5B;AACD,K;AAAA;AAED;;AAEG;;;AACU,EAAA,gCAAgC,GAAA;;AAC3C,WAAK,eAAL,CAAqB,KAArB;AACD,K;AAAA;AAED;;;;;AAKG;;;AACa,EAAA,cAAc,CAAC,eAAD,EAA0B,OAA1B,EAAyC;;AACrE,YAAM;AAAE,QAAA;AAAF,UAAe,MAAM,KAAK,qBAAL,CAA2B,eAA3B,EAA4C,KAAK,OAAL,CAAa,UAAzD,CAA3B;AAEA,YAAM,UAAU,GAAG,MAAM,CAAC,IAAP,CAAY,OAAZ,EAAqB,KAArB,CAAnB;;AAEA,UACE,UAAU,CAAC,MAAX,IACA,MAAM,CAAC,2BAAP,GAAqC,MAAM,CAAC,yBAF9C,EAGE;AACA,YAAI;AACF,iBAAO,MAAM,uBAAuB,CAAC,UAAD,EAAa,QAAb,CAApC;AACD,SAFD,CAEE,OAAO,eAAP,EAAwB;AACxB;AACD;AACF;;AAED,YAAM,IAAI,KAAJ,CAAU,2BAAV,CAAN;AACD,K;AAAA;AAED;;;;;AAKG;;;AACa,EAAA,cAAc,CAAC,kBAAD,EAA6B,OAA7B,EAA4C;;AACxE,YAAM;AAAE,QAAA;AAAF,UAAe,MAAM,KAAK,qBAAL,CACzB,kBADyB,EAEzB,KAAK,OAAL,CAAa,UAFY,CAA3B;AAKA,aAAO,uBAAuB,CAAC,OAAD,EAAU,QAAV,CAA9B;AACD,K;AAAA;;AAzGiE","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as sodium from 'libsodium-wrappers';\nimport { BEACON_VERSION } from '../../constants';\nimport { decryptCryptoboxPayload, encryptCryptoboxPayload } from '../../utils/crypto';\nimport { generateGUID } from '../../utils/generate-uuid';\nimport { CommunicationClient } from './CommunicationClient';\n/**\n * @internalapi\n *\n *\n */\nexport class MessageBasedClient extends CommunicationClient {\n    constructor(name, keyPair) {\n        super(keyPair);\n        this.name = name;\n        /**\n         * The listeners that will be notified of new messages\n         */\n        this.activeListeners = new Map();\n        this.init().catch(console.error);\n    }\n    /**\n     * start the client and make sure all dependencies are ready\n     */\n    start() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield sodium.ready;\n        });\n    }\n    /**\n     * Get the pairing request information. This will be shared with the peer during the connection setup\n     */\n    getPairingRequestInfo() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return {\n                id: yield generateGUID(),\n                type: 'postmessage-pairing-request',\n                name: this.name,\n                version: BEACON_VERSION,\n                publicKey: yield this.getPublicKey()\n            };\n        });\n    }\n    /**\n     * Get the pairing response information. This will be shared with the peer during the connection setup\n     */\n    getPairingResponseInfo(request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return {\n                id: request.id,\n                type: 'postmessage-pairing-response',\n                name: this.name,\n                version: BEACON_VERSION,\n                publicKey: yield this.getPublicKey()\n            };\n        });\n    }\n    /**\n     * Unsubscribe from encrypted messages from a specific peer\n     *\n     * @param senderPublicKey\n     */\n    unsubscribeFromEncryptedMessage(senderPublicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const listener = this.activeListeners.get(senderPublicKey);\n            if (!listener) {\n                return;\n            }\n            this.activeListeners.delete(senderPublicKey);\n        });\n    }\n    /**\n     * Unsubscribe from all encrypted messages\n     */\n    unsubscribeFromEncryptedMessages() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.activeListeners.clear();\n        });\n    }\n    /**\n     * Decrypt a message from a specific peer\n     *\n     * @param senderPublicKey\n     * @param payload\n     */\n    decryptMessage(senderPublicKey, payload) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { sharedRx } = yield this.createCryptoBoxServer(senderPublicKey, this.keyPair.privateKey);\n            const hexPayload = Buffer.from(payload, 'hex');\n            if (hexPayload.length >=\n                sodium.crypto_secretbox_NONCEBYTES + sodium.crypto_secretbox_MACBYTES) {\n                try {\n                    return yield decryptCryptoboxPayload(hexPayload, sharedRx);\n                }\n                catch (decryptionError) {\n                    /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n                }\n            }\n            throw new Error('Could not decrypt message');\n        });\n    }\n    /**\n     * Encrypt a message for a specific publicKey (receiver)\n     *\n     * @param recipientPublicKey\n     * @param message\n     */\n    encryptMessage(recipientPublicKey, message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { sharedTx } = yield this.createCryptoBoxClient(recipientPublicKey, this.keyPair.privateKey);\n            return encryptCryptoboxPayload(message, sharedTx);\n        });\n    }\n}\n//# sourceMappingURL=MessageBasedClient.js.map"]},"metadata":{},"sourceType":"module"}