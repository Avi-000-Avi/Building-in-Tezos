{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport * as sodium from 'libsodium-wrappers';\nimport { toHex, getHexHash, sealCryptobox } from '../../utils/crypto';\n/**\n * @internalapi\n *\n *\n */\n\nexport class CommunicationClient {\n  constructor(keyPair) {\n    this.keyPair = keyPair;\n  }\n  /**\n   * Get the public key\n   */\n\n\n  getPublicKey() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return toHex(this.keyPair.publicKey);\n    });\n  }\n  /**\n   * get the public key hash\n   */\n\n\n  getPublicKeyHash() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return getHexHash(this.keyPair.publicKey);\n    });\n  }\n  /**\n   * Create a cryptobox shared key\n   *\n   * @param otherPublicKey\n   * @param selfPrivateKey\n   */\n\n\n  createCryptoBox(otherPublicKey, selfPrivateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // TODO: Don't calculate it every time?\n      const kxSelfPrivateKey = sodium.crypto_sign_ed25519_sk_to_curve25519(Buffer.from(selfPrivateKey)); // Secret bytes to scalar bytes\n\n      const kxSelfPublicKey = sodium.crypto_sign_ed25519_pk_to_curve25519(Buffer.from(selfPrivateKey).slice(32, 64)); // Secret bytes to scalar bytes\n\n      const kxOtherPublicKey = sodium.crypto_sign_ed25519_pk_to_curve25519(Buffer.from(otherPublicKey, 'hex')); // Secret bytes to scalar bytes\n\n      return [Buffer.from(kxSelfPublicKey), Buffer.from(kxSelfPrivateKey), Buffer.from(kxOtherPublicKey)];\n    });\n  }\n  /**\n   * Create a cryptobox server\n   *\n   * @param otherPublicKey\n   * @param selfPrivateKey\n   */\n\n\n  createCryptoBoxServer(otherPublicKey, selfPrivateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const keys = yield this.createCryptoBox(otherPublicKey, selfPrivateKey);\n      return sodium.crypto_kx_server_session_keys(...keys);\n    });\n  }\n  /**\n   * Create a cryptobox client\n   *\n   * @param otherPublicKey\n   * @param selfPrivateKey\n   */\n\n\n  createCryptoBoxClient(otherPublicKey, selfPrivateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const keys = yield this.createCryptoBox(otherPublicKey, selfPrivateKey);\n      return sodium.crypto_kx_client_session_keys(...keys);\n    });\n  }\n  /**\n   * Encrypt a message for a specific publicKey (receiver, asymmetric)\n   *\n   * @param recipientPublicKey\n   * @param message\n   */\n\n\n  encryptMessageAsymmetric(recipientPublicKey, message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return sealCryptobox(message, Buffer.from(recipientPublicKey, 'hex'));\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../../src/transports/clients/CommunicationClient.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,KAAK,MAAZ,MAAwB,oBAAxB;AAKA,SAAS,KAAT,EAAgB,UAAhB,EAA4B,aAA5B,QAAiD,oBAAjD;AAEA;;;;AAIG;;AACH,OAAM,MAAgB,mBAAhB,CAAmC;AACvC,EAAA,WAAA,CAA+B,OAA/B,EAAsD;AAAvB,SAAA,OAAA,GAAA,OAAA;AAA2B;AAE1D;;AAEG;;;AACU,EAAA,YAAY,GAAA;;AACvB,aAAO,KAAK,CAAC,KAAK,OAAL,CAAa,SAAd,CAAZ;AACD,K;AAAA;AAED;;AAEG;;;AACU,EAAA,gBAAgB,GAAA;;AAC3B,aAAO,UAAU,CAAC,KAAK,OAAL,CAAa,SAAd,CAAjB;AACD,K;AAAA;AAED;;;;;AAKG;;;AACa,EAAA,eAAe,CAC7B,cAD6B,EAE7B,cAF6B,EAEH;;AAE1B;AACA,YAAM,gBAAgB,GAAG,MAAM,CAAC,oCAAP,CACvB,MAAM,CAAC,IAAP,CAAY,cAAZ,CADuB,CAAzB,C,CAEE;;AACF,YAAM,eAAe,GAAG,MAAM,CAAC,oCAAP,CACtB,MAAM,CAAC,IAAP,CAAY,cAAZ,EAA4B,KAA5B,CAAkC,EAAlC,EAAsC,EAAtC,CADsB,CAAxB,C,CAEE;;AACF,YAAM,gBAAgB,GAAG,MAAM,CAAC,oCAAP,CACvB,MAAM,CAAC,IAAP,CAAY,cAAZ,EAA4B,KAA5B,CADuB,CAAzB,C,CAEE;;AAEF,aAAO,CACL,MAAM,CAAC,IAAP,CAAY,eAAZ,CADK,EAEL,MAAM,CAAC,IAAP,CAAY,gBAAZ,CAFK,EAGL,MAAM,CAAC,IAAP,CAAY,gBAAZ,CAHK,CAAP;AAKD,K;AAAA;AAED;;;;;AAKG;;;AACa,EAAA,qBAAqB,CACnC,cADmC,EAEnC,cAFmC,EAET;;AAE1B,YAAM,IAAI,GAAG,MAAM,KAAK,eAAL,CAAqB,cAArB,EAAqC,cAArC,CAAnB;AAEA,aAAO,MAAM,CAAC,6BAAP,CAAqC,GAAG,IAAxC,CAAP;AACD,K;AAAA;AAED;;;;;AAKG;;;AACa,EAAA,qBAAqB,CACnC,cADmC,EAEnC,cAFmC,EAET;;AAE1B,YAAM,IAAI,GAAG,MAAM,KAAK,eAAL,CAAqB,cAArB,EAAqC,cAArC,CAAnB;AAEA,aAAO,MAAM,CAAC,6BAAP,CAAqC,GAAG,IAAxC,CAAP;AACD,K;AAAA;AAED;;;;;AAKG;;;AACa,EAAA,wBAAwB,CACtC,kBADsC,EAEtC,OAFsC,EAEvB;;AAEf,aAAO,aAAa,CAAC,OAAD,EAAU,MAAM,CAAC,IAAP,CAAY,kBAAZ,EAAgC,KAAhC,CAAV,CAApB;AACD,K;AAAA;;AAtFsC","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as sodium from 'libsodium-wrappers';\nimport { toHex, getHexHash, sealCryptobox } from '../../utils/crypto';\n/**\n * @internalapi\n *\n *\n */\nexport class CommunicationClient {\n    constructor(keyPair) {\n        this.keyPair = keyPair;\n    }\n    /**\n     * Get the public key\n     */\n    getPublicKey() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return toHex(this.keyPair.publicKey);\n        });\n    }\n    /**\n     * get the public key hash\n     */\n    getPublicKeyHash() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return getHexHash(this.keyPair.publicKey);\n        });\n    }\n    /**\n     * Create a cryptobox shared key\n     *\n     * @param otherPublicKey\n     * @param selfPrivateKey\n     */\n    createCryptoBox(otherPublicKey, selfPrivateKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // TODO: Don't calculate it every time?\n            const kxSelfPrivateKey = sodium.crypto_sign_ed25519_sk_to_curve25519(Buffer.from(selfPrivateKey)); // Secret bytes to scalar bytes\n            const kxSelfPublicKey = sodium.crypto_sign_ed25519_pk_to_curve25519(Buffer.from(selfPrivateKey).slice(32, 64)); // Secret bytes to scalar bytes\n            const kxOtherPublicKey = sodium.crypto_sign_ed25519_pk_to_curve25519(Buffer.from(otherPublicKey, 'hex')); // Secret bytes to scalar bytes\n            return [\n                Buffer.from(kxSelfPublicKey),\n                Buffer.from(kxSelfPrivateKey),\n                Buffer.from(kxOtherPublicKey)\n            ];\n        });\n    }\n    /**\n     * Create a cryptobox server\n     *\n     * @param otherPublicKey\n     * @param selfPrivateKey\n     */\n    createCryptoBoxServer(otherPublicKey, selfPrivateKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const keys = yield this.createCryptoBox(otherPublicKey, selfPrivateKey);\n            return sodium.crypto_kx_server_session_keys(...keys);\n        });\n    }\n    /**\n     * Create a cryptobox client\n     *\n     * @param otherPublicKey\n     * @param selfPrivateKey\n     */\n    createCryptoBoxClient(otherPublicKey, selfPrivateKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const keys = yield this.createCryptoBox(otherPublicKey, selfPrivateKey);\n            return sodium.crypto_kx_client_session_keys(...keys);\n        });\n    }\n    /**\n     * Encrypt a message for a specific publicKey (receiver, asymmetric)\n     *\n     * @param recipientPublicKey\n     * @param message\n     */\n    encryptMessageAsymmetric(recipientPublicKey, message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return sealCryptobox(message, Buffer.from(recipientPublicKey, 'hex'));\n        });\n    }\n}\n//# sourceMappingURL=CommunicationClient.js.map"]},"metadata":{},"sourceType":"module"}