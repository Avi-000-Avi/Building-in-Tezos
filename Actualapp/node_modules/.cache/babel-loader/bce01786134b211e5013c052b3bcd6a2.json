{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { assertNever } from '../utils/assert-never';\nimport { BeaconMessageType } from '..';\nimport { BEACON_VERSION } from '../constants';\nimport { getAddressFromPublicKey } from '../utils/crypto';\nimport { getAccountIdentifier } from '../utils/get-account-identifier';\nimport { BeaconErrorType } from '../types/BeaconErrorType';\nimport { Logger } from '../utils/Logger';\nconst logger = new Logger('OutgoingResponseInterceptor');\n/**\n * @internalapi\n *\n * The OutgoingResponseInterceptor is used in the WalletClient to intercept an outgoing response and enrich it with data.\n */\n\nexport class OutgoingResponseInterceptor {\n  static intercept(config) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        senderId,\n        request,\n        message,\n        ownAppMetadata,\n        permissionManager,\n        appMetadataManager,\n        interceptorCallback\n      } = config; // TODO: Remove v1 compatibility in later version\n\n      const interceptorCallbackWrapper = msg => {\n        const untypedMessage = msg;\n        untypedMessage.beaconId = msg.senderId;\n        interceptorCallback(msg);\n      };\n\n      switch (message.type) {\n        case BeaconMessageType.Error:\n          {\n            const response = {\n              type: message.type,\n              version: BEACON_VERSION,\n              senderId,\n              id: message.id,\n              errorType: message.errorType\n            };\n\n            if (message.errorType === BeaconErrorType.TRANSACTION_INVALID_ERROR && message.errorData) {\n              const errorData = message.errorData; // Check if error data is in correct format\n\n              if (Array.isArray(errorData) && errorData.every(item => Boolean(item.kind) && Boolean(item.id))) {\n                response.errorData = message.errorData;\n              } else {\n                logger.warn('ErrorData provided is not in correct format. It needs to be an array of RPC errors. It will not be included in the message sent to the dApp');\n              }\n            }\n\n            interceptorCallbackWrapper(response);\n            break;\n          }\n\n        case BeaconMessageType.Acknowledge:\n          {\n            const response = {\n              type: message.type,\n              version: BEACON_VERSION,\n              senderId,\n              id: message.id\n            };\n            interceptorCallbackWrapper(response);\n            break;\n          }\n\n        case BeaconMessageType.PermissionResponse:\n          {\n            const response = Object.assign({\n              senderId,\n              version: BEACON_VERSION,\n              appMetadata: ownAppMetadata\n            }, message); // TODO: Migration code. Remove sometime after 1.0.0 release.\n\n            const publicKey = response.publicKey || response.pubkey || response.pubKey;\n            const address = yield getAddressFromPublicKey(publicKey);\n            const appMetadata = yield appMetadataManager.getAppMetadata(request.senderId);\n\n            if (!appMetadata) {\n              throw new Error('AppMetadata not found');\n            }\n\n            const permission = {\n              accountIdentifier: yield getAccountIdentifier(address, response.network),\n              senderId: request.senderId,\n              appMetadata,\n              website: '',\n              address,\n              publicKey,\n              network: response.network,\n              scopes: response.scopes,\n              connectedAt: new Date().getTime()\n            };\n            permissionManager.addPermission(permission).catch(console.error);\n            interceptorCallbackWrapper(response);\n            break;\n          }\n\n        case BeaconMessageType.OperationResponse:\n          {\n            const response = Object.assign({\n              senderId,\n              version: BEACON_VERSION\n            }, message);\n            interceptorCallbackWrapper(response);\n          }\n          break;\n\n        case BeaconMessageType.SignPayloadResponse:\n          {\n            const response = Object.assign({\n              senderId,\n              version: BEACON_VERSION\n            }, message);\n            interceptorCallbackWrapper(response);\n          }\n          break;\n        // TODO: ENCRYPTION\n        // case BeaconMessageType.EncryptPayloadResponse:\n        //   {\n        //     const response: EncryptPayloadResponse = {\n        //       senderId,\n        //       version: BEACON_VERSION,\n        //       ...message\n        //     }\n        //     interceptorCallbackWrapper(response)\n        //   }\n        //   break\n\n        case BeaconMessageType.BroadcastResponse:\n          {\n            const response = Object.assign({\n              senderId,\n              version: BEACON_VERSION\n            }, message);\n            interceptorCallbackWrapper(response);\n          }\n          break;\n\n        default:\n          logger.log('intercept', 'Message not handled');\n          assertNever(message);\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/interceptors/OutgoingResponseInterceptor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { assertNever } from '../utils/assert-never';\nimport { BeaconMessageType } from '..';\nimport { BEACON_VERSION } from '../constants';\nimport { getAddressFromPublicKey } from '../utils/crypto';\nimport { getAccountIdentifier } from '../utils/get-account-identifier';\nimport { BeaconErrorType } from '../types/BeaconErrorType';\nimport { Logger } from '../utils/Logger';\nconst logger = new Logger('OutgoingResponseInterceptor');\n/**\n * @internalapi\n *\n * The OutgoingResponseInterceptor is used in the WalletClient to intercept an outgoing response and enrich it with data.\n */\nexport class OutgoingResponseInterceptor {\n    static intercept(config) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { senderId, request, message, ownAppMetadata, permissionManager, appMetadataManager, interceptorCallback } = config;\n            // TODO: Remove v1 compatibility in later version\n            const interceptorCallbackWrapper = (msg) => {\n                const untypedMessage = msg;\n                untypedMessage.beaconId = msg.senderId;\n                interceptorCallback(msg);\n            };\n            switch (message.type) {\n                case BeaconMessageType.Error: {\n                    const response = {\n                        type: message.type,\n                        version: BEACON_VERSION,\n                        senderId,\n                        id: message.id,\n                        errorType: message.errorType\n                    };\n                    if (message.errorType === BeaconErrorType.TRANSACTION_INVALID_ERROR && message.errorData) {\n                        const errorData = message.errorData;\n                        // Check if error data is in correct format\n                        if (Array.isArray(errorData) &&\n                            errorData.every((item) => Boolean(item.kind) && Boolean(item.id))) {\n                            response.errorData = message.errorData;\n                        }\n                        else {\n                            logger.warn('ErrorData provided is not in correct format. It needs to be an array of RPC errors. It will not be included in the message sent to the dApp');\n                        }\n                    }\n                    interceptorCallbackWrapper(response);\n                    break;\n                }\n                case BeaconMessageType.Acknowledge: {\n                    const response = {\n                        type: message.type,\n                        version: BEACON_VERSION,\n                        senderId,\n                        id: message.id\n                    };\n                    interceptorCallbackWrapper(response);\n                    break;\n                }\n                case BeaconMessageType.PermissionResponse: {\n                    const response = Object.assign({ senderId, version: BEACON_VERSION, appMetadata: ownAppMetadata }, message);\n                    // TODO: Migration code. Remove sometime after 1.0.0 release.\n                    const publicKey = response.publicKey || response.pubkey || response.pubKey;\n                    const address = yield getAddressFromPublicKey(publicKey);\n                    const appMetadata = yield appMetadataManager.getAppMetadata(request.senderId);\n                    if (!appMetadata) {\n                        throw new Error('AppMetadata not found');\n                    }\n                    const permission = {\n                        accountIdentifier: yield getAccountIdentifier(address, response.network),\n                        senderId: request.senderId,\n                        appMetadata,\n                        website: '',\n                        address,\n                        publicKey,\n                        network: response.network,\n                        scopes: response.scopes,\n                        connectedAt: new Date().getTime()\n                    };\n                    permissionManager.addPermission(permission).catch(console.error);\n                    interceptorCallbackWrapper(response);\n                    break;\n                }\n                case BeaconMessageType.OperationResponse:\n                    {\n                        const response = Object.assign({ senderId, version: BEACON_VERSION }, message);\n                        interceptorCallbackWrapper(response);\n                    }\n                    break;\n                case BeaconMessageType.SignPayloadResponse:\n                    {\n                        const response = Object.assign({ senderId, version: BEACON_VERSION }, message);\n                        interceptorCallbackWrapper(response);\n                    }\n                    break;\n                // TODO: ENCRYPTION\n                // case BeaconMessageType.EncryptPayloadResponse:\n                //   {\n                //     const response: EncryptPayloadResponse = {\n                //       senderId,\n                //       version: BEACON_VERSION,\n                //       ...message\n                //     }\n                //     interceptorCallbackWrapper(response)\n                //   }\n                //   break\n                case BeaconMessageType.BroadcastResponse:\n                    {\n                        const response = Object.assign({ senderId, version: BEACON_VERSION }, message);\n                        interceptorCallbackWrapper(response);\n                    }\n                    break;\n                default:\n                    logger.log('intercept', 'Message not handled');\n                    assertNever(message);\n            }\n        });\n    }\n}\n//# sourceMappingURL=OutgoingResponseInterceptor.js.map"]},"metadata":{},"sourceType":"module"}