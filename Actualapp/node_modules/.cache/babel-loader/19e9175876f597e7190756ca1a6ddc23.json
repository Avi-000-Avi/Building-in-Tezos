{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ExposedPromise, ExposedPromiseStatus } from '../../utils/exposed-promise';\nimport { Serializer, TransportStatus, BeaconMessageType } from '../..';\nimport { BeaconEventHandler, BeaconEvent } from '../../events';\nimport { BeaconClient } from '../beacon-client/BeaconClient';\nimport { AccountManager } from '../../managers/AccountManager';\nimport { generateGUID } from '../../utils/generate-uuid';\nimport { BEACON_VERSION } from '../../constants';\nimport { getSenderId } from '../../utils/get-sender-id';\nimport { Logger } from '../../utils/Logger';\nconst logger = new Logger('Client');\n/**\n * @internalapi\n *\n * This abstract class handles the a big part of the logic that is shared between the dapp and wallet client.\n * For example, it selects and manages the transport and accounts.\n */\n\nexport class Client extends BeaconClient {\n  constructor(config) {\n    var _a, _b;\n\n    super(config);\n    /**\n     * How many requests can be sent after another\n     */\n\n    this.rateLimit = 2;\n    /**\n     * The time window in seconds in which the \"rateLimit\" is checked\n     */\n\n    this.rateLimitWindowInSeconds = 5;\n    /**\n     * Stores the times when requests have been made to determine if the rate limit has been reached\n     */\n\n    this.requestCounter = [];\n    this._transport = new ExposedPromise();\n    this.events = new BeaconEventHandler(config.eventHandlers, (_a = config.disableDefaultEvents) !== null && _a !== void 0 ? _a : false);\n    this.accountManager = new AccountManager(config.storage);\n    this.matrixNodes = (_b = config.matrixNodes) !== null && _b !== void 0 ? _b : [];\n\n    this.handleResponse = (message, connectionInfo) => {\n      throw new Error(`not overwritten${JSON.stringify(message)} - ${JSON.stringify(connectionInfo)}`);\n    };\n  }\n\n  get transport() {\n    return this._transport.promise;\n  }\n  /**\n   * Returns the connection status of the Client\n   */\n\n\n  get connectionStatus() {\n    var _a, _b;\n\n    return (_b = (_a = this._transport.promiseResult) === null || _a === void 0 ? void 0 : _a.connectionStatus) !== null && _b !== void 0 ? _b : TransportStatus.NOT_CONNECTED;\n  }\n  /**\n   * Returns whether or not the transaport is ready\n   */\n\n\n  get ready() {\n    return this.transport.then(() => undefined);\n  }\n  /**\n   * Return all locally known accounts\n   */\n\n\n  getAccounts() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.accountManager.getAccounts();\n    });\n  }\n  /**\n   * Return the account by ID\n   * @param accountIdentifier The ID of an account\n   */\n\n\n  getAccount(accountIdentifier) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.accountManager.getAccount(accountIdentifier);\n    });\n  }\n  /**\n   * Remove the account by ID\n   * @param accountIdentifier The ID of an account\n   */\n\n\n  removeAccount(accountIdentifier) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.accountManager.removeAccount(accountIdentifier);\n    });\n  }\n  /**\n   * Remove all locally stored accounts\n   */\n\n\n  removeAllAccounts() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.accountManager.removeAllAccounts();\n    });\n  }\n  /**\n   * Add a new request (current timestamp) to the pending requests, remove old ones and check if we are above the limit\n   */\n\n\n  addRequestAndCheckIfRateLimited() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const now = new Date().getTime();\n      this.requestCounter = this.requestCounter.filter(date => date + this.rateLimitWindowInSeconds * 1000 > now);\n      this.requestCounter.push(now);\n      return this.requestCounter.length > this.rateLimit;\n    });\n  }\n  /**\n   * This method initializes the client. It will check if the connection should be established to a\n   * browser extension or if the P2P transport should be used.\n   *\n   * @param transport A transport that can be provided by the user\n   */\n\n\n  init(transport) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._transport.status === ExposedPromiseStatus.RESOLVED) {\n        return (yield this.transport).type;\n      }\n\n      yield this.setTransport(transport); // Let users define their own transport\n\n      return transport.type;\n    });\n  }\n  /**\n   * Returns the metadata of this DApp\n   */\n\n\n  getOwnAppMetadata() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return {\n        senderId: yield getSenderId(yield this.beaconId),\n        name: this.name,\n        icon: this.iconUrl\n      };\n    });\n  }\n  /**\n   * Return all known peers\n   */\n\n\n  getPeers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return (yield this.transport).getPeers();\n    });\n  }\n  /**\n   * Add a new peer to the known peers\n   * @param peer The new peer to add\n   */\n\n\n  addPeer(peer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return (yield this.transport).addPeer(peer);\n    });\n  }\n\n  destroy() {\n    const _super = Object.create(null, {\n      destroy: {\n        get: () => super.destroy\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._transport.status === ExposedPromiseStatus.RESOLVED) {\n        yield (yield this.transport).disconnect();\n      }\n\n      yield _super.destroy.call(this);\n    });\n  }\n  /**\n   * A \"setter\" for when the transport needs to be changed.\n   */\n\n\n  setTransport(transport) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (transport) {\n        if (this._transport.isSettled()) {\n          // If the promise has already been resolved we need to create a new one.\n          this._transport = ExposedPromise.resolve(transport);\n        } else {\n          this._transport.resolve(transport);\n        }\n      } else {\n        if (this._transport.isSettled()) {\n          // If the promise has already been resolved we need to create a new one.\n          this._transport = new ExposedPromise();\n        }\n      }\n\n      yield this.events.emit(BeaconEvent.ACTIVE_TRANSPORT_SET, transport);\n    });\n  }\n\n  addListener(transport) {\n    return __awaiter(this, void 0, void 0, function* () {\n      transport.addListener((message, connectionInfo) => __awaiter(this, void 0, void 0, function* () {\n        if (typeof message === 'string') {\n          const deserializedMessage = yield new Serializer().deserialize(message);\n          this.handleResponse(deserializedMessage, connectionInfo);\n        }\n      })).catch(error => logger.error('addListener', error));\n    });\n  }\n\n  sendDisconnectToPeer(peer, transport) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const request = {\n        id: yield generateGUID(),\n        version: BEACON_VERSION,\n        senderId: yield getSenderId(yield this.beaconId),\n        type: BeaconMessageType.Disconnect\n      };\n      const payload = yield new Serializer().serialize(request);\n      const selectedTransport = transport !== null && transport !== void 0 ? transport : yield this.transport;\n      yield selectedTransport.send(payload, peer);\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../../src/clients/client/Client.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ExposedPromise, ExposedPromiseStatus } from '../../utils/exposed-promise';\nimport { Serializer, TransportStatus, BeaconMessageType } from '../..';\nimport { BeaconEventHandler, BeaconEvent } from '../../events';\nimport { BeaconClient } from '../beacon-client/BeaconClient';\nimport { AccountManager } from '../../managers/AccountManager';\nimport { generateGUID } from '../../utils/generate-uuid';\nimport { BEACON_VERSION } from '../../constants';\nimport { getSenderId } from '../../utils/get-sender-id';\nimport { Logger } from '../../utils/Logger';\nconst logger = new Logger('Client');\n/**\n * @internalapi\n *\n * This abstract class handles the a big part of the logic that is shared between the dapp and wallet client.\n * For example, it selects and manages the transport and accounts.\n */\nexport class Client extends BeaconClient {\n    constructor(config) {\n        var _a, _b;\n        super(config);\n        /**\n         * How many requests can be sent after another\n         */\n        this.rateLimit = 2;\n        /**\n         * The time window in seconds in which the \"rateLimit\" is checked\n         */\n        this.rateLimitWindowInSeconds = 5;\n        /**\n         * Stores the times when requests have been made to determine if the rate limit has been reached\n         */\n        this.requestCounter = [];\n        this._transport = new ExposedPromise();\n        this.events = new BeaconEventHandler(config.eventHandlers, (_a = config.disableDefaultEvents) !== null && _a !== void 0 ? _a : false);\n        this.accountManager = new AccountManager(config.storage);\n        this.matrixNodes = (_b = config.matrixNodes) !== null && _b !== void 0 ? _b : [];\n        this.handleResponse = (message, connectionInfo) => {\n            throw new Error(`not overwritten${JSON.stringify(message)} - ${JSON.stringify(connectionInfo)}`);\n        };\n    }\n    get transport() {\n        return this._transport.promise;\n    }\n    /**\n     * Returns the connection status of the Client\n     */\n    get connectionStatus() {\n        var _a, _b;\n        return (_b = (_a = this._transport.promiseResult) === null || _a === void 0 ? void 0 : _a.connectionStatus) !== null && _b !== void 0 ? _b : TransportStatus.NOT_CONNECTED;\n    }\n    /**\n     * Returns whether or not the transaport is ready\n     */\n    get ready() {\n        return this.transport.then(() => undefined);\n    }\n    /**\n     * Return all locally known accounts\n     */\n    getAccounts() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.accountManager.getAccounts();\n        });\n    }\n    /**\n     * Return the account by ID\n     * @param accountIdentifier The ID of an account\n     */\n    getAccount(accountIdentifier) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.accountManager.getAccount(accountIdentifier);\n        });\n    }\n    /**\n     * Remove the account by ID\n     * @param accountIdentifier The ID of an account\n     */\n    removeAccount(accountIdentifier) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.accountManager.removeAccount(accountIdentifier);\n        });\n    }\n    /**\n     * Remove all locally stored accounts\n     */\n    removeAllAccounts() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.accountManager.removeAllAccounts();\n        });\n    }\n    /**\n     * Add a new request (current timestamp) to the pending requests, remove old ones and check if we are above the limit\n     */\n    addRequestAndCheckIfRateLimited() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const now = new Date().getTime();\n            this.requestCounter = this.requestCounter.filter((date) => date + this.rateLimitWindowInSeconds * 1000 > now);\n            this.requestCounter.push(now);\n            return this.requestCounter.length > this.rateLimit;\n        });\n    }\n    /**\n     * This method initializes the client. It will check if the connection should be established to a\n     * browser extension or if the P2P transport should be used.\n     *\n     * @param transport A transport that can be provided by the user\n     */\n    init(transport) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._transport.status === ExposedPromiseStatus.RESOLVED) {\n                return (yield this.transport).type;\n            }\n            yield this.setTransport(transport); // Let users define their own transport\n            return transport.type;\n        });\n    }\n    /**\n     * Returns the metadata of this DApp\n     */\n    getOwnAppMetadata() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return {\n                senderId: yield getSenderId(yield this.beaconId),\n                name: this.name,\n                icon: this.iconUrl\n            };\n        });\n    }\n    /**\n     * Return all known peers\n     */\n    getPeers() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return (yield this.transport).getPeers();\n        });\n    }\n    /**\n     * Add a new peer to the known peers\n     * @param peer The new peer to add\n     */\n    addPeer(peer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return (yield this.transport).addPeer(peer);\n        });\n    }\n    destroy() {\n        const _super = Object.create(null, {\n            destroy: { get: () => super.destroy }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._transport.status === ExposedPromiseStatus.RESOLVED) {\n                yield (yield this.transport).disconnect();\n            }\n            yield _super.destroy.call(this);\n        });\n    }\n    /**\n     * A \"setter\" for when the transport needs to be changed.\n     */\n    setTransport(transport) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (transport) {\n                if (this._transport.isSettled()) {\n                    // If the promise has already been resolved we need to create a new one.\n                    this._transport = ExposedPromise.resolve(transport);\n                }\n                else {\n                    this._transport.resolve(transport);\n                }\n            }\n            else {\n                if (this._transport.isSettled()) {\n                    // If the promise has already been resolved we need to create a new one.\n                    this._transport = new ExposedPromise();\n                }\n            }\n            yield this.events.emit(BeaconEvent.ACTIVE_TRANSPORT_SET, transport);\n        });\n    }\n    addListener(transport) {\n        return __awaiter(this, void 0, void 0, function* () {\n            transport\n                .addListener((message, connectionInfo) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof message === 'string') {\n                    const deserializedMessage = (yield new Serializer().deserialize(message));\n                    this.handleResponse(deserializedMessage, connectionInfo);\n                }\n            }))\n                .catch((error) => logger.error('addListener', error));\n        });\n    }\n    sendDisconnectToPeer(peer, transport) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const request = {\n                id: yield generateGUID(),\n                version: BEACON_VERSION,\n                senderId: yield getSenderId(yield this.beaconId),\n                type: BeaconMessageType.Disconnect\n            };\n            const payload = yield new Serializer().serialize(request);\n            const selectedTransport = transport !== null && transport !== void 0 ? transport : (yield this.transport);\n            yield selectedTransport.send(payload, peer);\n        });\n    }\n}\n//# sourceMappingURL=Client.js.map"]},"metadata":{},"sourceType":"module"}