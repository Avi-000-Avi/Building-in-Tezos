{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { StorageKey, P2PTransport, TransportStatus } from '..';\nimport { Logger } from '../utils/Logger';\nconst logger = new Logger('DappP2PTransport');\n/**\n * @internalapi\n *\n *\n */\n\nexport class DappP2PTransport extends P2PTransport {\n  constructor(name, keyPair, storage, matrixNodes, iconUrl, appUrl) {\n    super(name, keyPair, storage, matrixNodes, StorageKey.TRANSPORT_P2P_PEERS_DAPP, iconUrl, appUrl);\n  }\n\n  startOpenChannelListener() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.client.listenForChannelOpening(peer => __awaiter(this, void 0, void 0, function* () {\n        logger.log('listenForNewPeer', `new publicKey`, peer.publicKey);\n        yield this.addPeer(peer);\n        this._isConnected = TransportStatus.CONNECTED;\n\n        if (this.newPeerListener) {\n          this.newPeerListener(peer);\n          this.newPeerListener = undefined; // TODO: Remove this once we use the id\n        }\n      }));\n    });\n  }\n\n  listenForNewPeer(newPeerListener) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('listenForNewPeer');\n      this.newPeerListener = newPeerListener;\n    });\n  }\n\n  stopListeningForNewPeers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('stopListeningForNewPeers');\n      this.newPeerListener = undefined;\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/transports/DappP2PTransport.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SAAkB,UAAlB,EAA8B,YAA9B,EAA4C,eAA5C,QAAmE,IAAnE;AAEA,SAAS,MAAT,QAAuB,iBAAvB;AAEA,MAAM,MAAM,GAAG,IAAI,MAAJ,CAAW,kBAAX,CAAf;AAEA;;;;AAIG;;AACH,OAAM,MAAO,gBAAP,SAAgC,YAAhC,CAGL;AACC,EAAA,WAAA,CACE,IADF,EAEE,OAFF,EAGE,OAHF,EAIE,WAJF,EAKE,OALF,EAME,MANF,EAMiB;AAEf,UAAM,IAAN,EAAY,OAAZ,EAAqB,OAArB,EAA8B,WAA9B,EAA2C,UAAU,CAAC,wBAAtD,EAAgF,OAAhF,EAAyF,MAAzF;AACD;;AAEY,EAAA,wBAAwB,GAAA;;AACnC,aAAO,KAAK,MAAL,CAAY,uBAAZ,CAA2C,IAAP,IAAe,SAAA,CAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;AACxD,QAAA,MAAM,CAAC,GAAP,CAAW,kBAAX,EAA+B,eAA/B,EAAgD,IAAI,CAAC,SAArD;AAEA,cAAM,KAAK,OAAL,CAAa,IAAb,CAAN;AAEA,aAAK,YAAL,GAAoB,eAAe,CAAC,SAApC;;AAEA,YAAI,KAAK,eAAT,EAA0B;AACxB,eAAK,eAAL,CAAqB,IAArB;AACA,eAAK,eAAL,GAAuB,SAAvB,CAFwB,CAES;AAClC;AACF,OAXyD,CAAnD,CAAP;AAYD,K;AAAA;;AAEY,EAAA,gBAAgB,CAC3B,eAD2B,EACgC;;AAE3D,MAAA,MAAM,CAAC,GAAP,CAAW,kBAAX;AACA,WAAK,eAAL,GAAuB,eAAvB;AACD,K;AAAA;;AAEY,EAAA,wBAAwB,GAAA;;AACnC,MAAA,MAAM,CAAC,GAAP,CAAW,0BAAX;AACA,WAAK,eAAL,GAAuB,SAAvB;AACD,K;AAAA;;AArCF","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { StorageKey, P2PTransport, TransportStatus } from '..';\nimport { Logger } from '../utils/Logger';\nconst logger = new Logger('DappP2PTransport');\n/**\n * @internalapi\n *\n *\n */\nexport class DappP2PTransport extends P2PTransport {\n    constructor(name, keyPair, storage, matrixNodes, iconUrl, appUrl) {\n        super(name, keyPair, storage, matrixNodes, StorageKey.TRANSPORT_P2P_PEERS_DAPP, iconUrl, appUrl);\n    }\n    startOpenChannelListener() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.client.listenForChannelOpening((peer) => __awaiter(this, void 0, void 0, function* () {\n                logger.log('listenForNewPeer', `new publicKey`, peer.publicKey);\n                yield this.addPeer(peer);\n                this._isConnected = TransportStatus.CONNECTED;\n                if (this.newPeerListener) {\n                    this.newPeerListener(peer);\n                    this.newPeerListener = undefined; // TODO: Remove this once we use the id\n                }\n            }));\n        });\n    }\n    listenForNewPeer(newPeerListener) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('listenForNewPeer');\n            this.newPeerListener = newPeerListener;\n        });\n    }\n    stopListeningForNewPeers() {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('stopListeningForNewPeers');\n            this.newPeerListener = undefined;\n        });\n    }\n}\n//# sourceMappingURL=DappP2PTransport.js.map"]},"metadata":{},"sourceType":"module"}