{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport * as sodium from 'libsodium-wrappers';\nimport axios from 'axios';\nimport { getHexHash, toHex, recipientString, openCryptobox, encryptCryptoboxPayload, decryptCryptoboxPayload } from '../../utils/crypto';\nimport { MatrixClient } from '../../matrix-client/MatrixClient';\nimport { MatrixClientEventType } from '../../matrix-client/models/MatrixClientEvent';\nimport { MatrixMessageType } from '../../matrix-client/models/MatrixMessage';\nimport { PeerManager, StorageKey } from '../..';\nimport { BEACON_VERSION } from '../../constants';\nimport { generateGUID } from '../../utils/generate-uuid';\nimport { getSenderId } from '../../utils/get-sender-id';\nimport { Logger } from '../../utils/Logger';\nimport { CommunicationClient } from './CommunicationClient';\nimport { ExposedPromise } from '../../utils/exposed-promise';\nconst logger = new Logger('P2PCommunicationClient');\nconst KNOWN_RELAY_SERVERS = ['beacon-node-1.sky.papers.tech', 'beacon-node-0.papers.tech:8448', 'beacon-node-2.sky.papers.tech'];\n\nconst publicKeyToNumber = (arr, mod) => {\n  let sum = 0;\n\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] + i;\n  }\n\n  return Math.floor(sum % mod);\n};\n/**\n * @internalapi\n *\n *\n */\n\n\nexport class P2PCommunicationClient extends CommunicationClient {\n  constructor(name, keyPair, replicationCount, storage, matrixNodes, iconUrl, appUrl) {\n    super(keyPair);\n    this.name = name;\n    this.replicationCount = replicationCount;\n    this.storage = storage;\n    this.iconUrl = iconUrl;\n    this.appUrl = appUrl;\n    this.client = new ExposedPromise();\n    this.activeListeners = new Map();\n    this.ignoredRooms = [];\n    this.loginCounter = 0;\n    logger.log('constructor', 'P2PCommunicationClient created');\n    this.KNOWN_RELAY_SERVERS = matrixNodes.length > 0 ? matrixNodes : KNOWN_RELAY_SERVERS;\n  }\n\n  getPairingRequestInfo() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const info = {\n        id: yield generateGUID(),\n        type: 'p2p-pairing-request',\n        name: this.name,\n        version: BEACON_VERSION,\n        publicKey: yield this.getPublicKey(),\n        relayServer: yield this.getRelayServer()\n      };\n\n      if (this.iconUrl) {\n        info.icon = this.iconUrl;\n      }\n\n      if (this.appUrl) {\n        info.appUrl = this.appUrl;\n      }\n\n      return info;\n    });\n  }\n\n  getPairingResponseInfo(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const info = {\n        id: request.id,\n        type: 'p2p-pairing-response',\n        name: this.name,\n        version: BEACON_VERSION,\n        publicKey: yield this.getPublicKey(),\n        relayServer: yield this.getRelayServer()\n      };\n\n      if (this.iconUrl) {\n        info.icon = this.iconUrl;\n      }\n\n      if (this.appUrl) {\n        info.appUrl = this.appUrl;\n      }\n\n      return info;\n    });\n  }\n\n  getRelayServer() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.relayServer) {\n        return this.relayServer.promise;\n      } else {\n        this.relayServer = new ExposedPromise();\n      } // MIGRATION: If a relay server is set, it's all good and we don't have to do any migration\n\n\n      const node = yield this.storage.get(StorageKey.MATRIX_SELECTED_NODE);\n\n      if (node && node.length > 0) {\n        this.relayServer.resolve(node);\n        return node;\n      } else if (KNOWN_RELAY_SERVERS === this.KNOWN_RELAY_SERVERS) {\n        // Migration start\n        // Only if the array of nodes is the default we do the migration, otherwise we leave it.\n        // If NO relay server is set, we have 3 possibilities:\n        const hasDoneMigration = yield this.storage.get(StorageKey.MULTI_NODE_SETUP_DONE);\n\n        if (!hasDoneMigration) {\n          // If this migration has run before, we can skip it.\n          const preservedState = yield this.storage.get(StorageKey.MATRIX_PRESERVED_STATE);\n          console.log('PRESERVED STATE', preservedState);\n\n          if (preservedState.syncToken || preservedState.rooms) {\n            // If migration has NOT run and we have a sync state, we know have been previously connected. So we set the old default relayServer as our current node.\n            const node = 'matrix.papers.tech'; // 2.2.7 Migration: This will default to the old default to avoid peers from losing their relayServer.\n\n            this.storage.set(StorageKey.MATRIX_SELECTED_NODE, node).catch(error => logger.log(error));\n            this.relayServer.resolve(node);\n            return node;\n          }\n\n          this.storage.set(StorageKey.MULTI_NODE_SETUP_DONE, true).catch(error => logger.log(error)); // Migration end\n        }\n      }\n\n      console.log('GET RELAY SERVER');\n      const startIndex = publicKeyToNumber(this.keyPair.publicKey, this.KNOWN_RELAY_SERVERS.length);\n      let offset = 0;\n\n      while (offset < this.KNOWN_RELAY_SERVERS.length) {\n        const serverIndex = (startIndex + offset) % this.KNOWN_RELAY_SERVERS.length;\n        const server = this.KNOWN_RELAY_SERVERS[serverIndex];\n\n        try {\n          yield axios.get(`https://${server}/_matrix/client/versions`);\n          this.storage.set(StorageKey.MATRIX_SELECTED_NODE, server).catch(error => logger.log(error));\n          this.relayServer.resolve(server);\n          return server;\n        } catch (relayError) {\n          logger.log(`Ignoring server \"${server}\", trying another one...`);\n          offset++;\n        }\n      }\n\n      this.relayServer.reject(`No matrix server reachable!`);\n      throw new Error(`No matrix server reachable!`);\n    });\n  }\n\n  tryJoinRooms(roomId, retry = 1) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield (yield this.client.promise).joinRooms(roomId);\n      } catch (error) {\n        if (retry <= 10 && error.errcode === 'M_FORBIDDEN') {\n          // If we join the room too fast after receiving the invite, the server can accidentally reject our join. This seems to be a problem only when using a federated multi-node setup. Usually waiting for a couple milliseconds solves the issue, but to handle lag, we will keep retrying for 2 seconds.\n          logger.log(`Retrying to join...`, error);\n          setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n            yield this.tryJoinRooms(roomId, retry + 1);\n          }), 200);\n        } else {\n          logger.log(`Failed to join after ${retry} tries.`, error);\n        }\n      }\n    });\n  }\n\n  start() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('start', 'starting client');\n      yield sodium.ready;\n      const loginRawDigest = sodium.crypto_generichash(32, sodium.from_string(`login:${Math.floor(Date.now() / 1000 / (5 * 60))}`));\n      const rawSignature = sodium.crypto_sign_detached(loginRawDigest, this.keyPair.privateKey);\n      logger.log('start', `connecting to server`);\n      const relayServer = yield this.getRelayServer();\n      const client = MatrixClient.create({\n        baseUrl: `https://${relayServer}`,\n        storage: this.storage\n      });\n\n      this.initialListener = event => __awaiter(this, void 0, void 0, function* () {\n        if (this.initialEvent && this.initialEvent.timestamp && event && event.timestamp) {\n          if (this.initialEvent.timestamp < event.timestamp) {\n            this.initialEvent = event;\n          }\n        } else {\n          this.initialEvent = event;\n        }\n      });\n\n      client.subscribe(MatrixClientEventType.MESSAGE, this.initialListener);\n      client.subscribe(MatrixClientEventType.INVITE, event => __awaiter(this, void 0, void 0, function* () {\n        let member;\n\n        if (event.content.members.length === 1) {\n          // If there is only one member we know it's a new room\n          // TODO: Use the \"sender\" of the event instead\n          member = event.content.members[0];\n        }\n\n        yield this.tryJoinRooms(event.content.roomId);\n\n        if (member) {\n          yield this.updateRelayServer(member);\n          yield this.updatePeerRoom(member, event.content.roomId);\n        }\n      }));\n      logger.log('start', 'login', yield this.getPublicKeyHash(), 'on', relayServer);\n\n      try {\n        yield client.start({\n          id: yield this.getPublicKeyHash(),\n          password: `ed:${toHex(rawSignature)}:${yield this.getPublicKey()}`,\n          deviceId: toHex(this.keyPair.publicKey)\n        });\n      } catch (error) {\n        console.log('ERROR, RETRYING');\n        yield this.reset(); // If we can't log in, let's reset\n\n        console.log('TRYING AGAIN');\n\n        if (this.loginCounter <= this.KNOWN_RELAY_SERVERS.length) {\n          this.loginCounter++;\n          this.start();\n          return;\n        } else {\n          throw new Error('Too many login attempts. Try again later.');\n        }\n      }\n\n      console.log('client is ready');\n      this.client.resolve(client);\n    });\n  }\n\n  stop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.client.isResolved()) {\n        yield (yield this.client.promise).stop().catch(error => logger.error(error));\n      }\n\n      yield this.reset();\n    });\n  }\n\n  reset() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.storage.delete(StorageKey.MATRIX_PEER_ROOM_IDS).catch(error => logger.log(error));\n      yield this.storage.delete(StorageKey.MATRIX_PRESERVED_STATE).catch(error => logger.log(error));\n      yield this.storage.delete(StorageKey.MATRIX_SELECTED_NODE).catch(error => logger.log(error)); // Instead of resetting everything, maybe we should make sure a new instance is created?\n\n      this.relayServer = undefined;\n      this.client = new ExposedPromise();\n      this.initialEvent = undefined;\n      this.initialListener = undefined;\n    });\n  }\n\n  listenForEncryptedMessage(senderPublicKey, messageCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.activeListeners.has(senderPublicKey)) {\n        return;\n      }\n\n      const {\n        sharedRx\n      } = yield this.createCryptoBoxServer(senderPublicKey, this.keyPair.privateKey);\n\n      const callbackFunction = event => __awaiter(this, void 0, void 0, function* () {\n        if (this.isTextMessage(event.content) && (yield this.isSender(event, senderPublicKey))) {\n          let payload;\n          yield this.updateRelayServer(event.content.message.sender);\n          yield this.updatePeerRoom(event.content.message.sender, event.content.roomId);\n\n          try {\n            payload = Buffer.from(event.content.message.content, 'hex'); // content can be non-hex if it's a connection open request\n          } catch (_a) {\n            /* */\n          }\n\n          if (payload && payload.length >= sodium.crypto_secretbox_NONCEBYTES + sodium.crypto_secretbox_MACBYTES) {\n            try {\n              const decryptedMessage = yield decryptCryptoboxPayload(payload, sharedRx); // logger.log(\n              //   'listenForEncryptedMessage',\n              //   'encrypted message received',\n              //   decryptedMessage,\n              //   await new Serializer().deserialize(decryptedMessage)\n              // )\n              // console.log('calculated sender ID', await getSenderId(senderPublicKey))\n              // TODO: Add check for correct decryption key / sender ID\n\n              messageCallback(decryptedMessage);\n            } catch (decryptionError) {\n              /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n            }\n          }\n        }\n      });\n\n      this.activeListeners.set(senderPublicKey, callbackFunction);\n      (yield this.client.promise).subscribe(MatrixClientEventType.MESSAGE, callbackFunction);\n      const lastEvent = this.initialEvent;\n\n      if (lastEvent && lastEvent.timestamp && new Date().getTime() - lastEvent.timestamp < 5 * 60 * 1000) {\n        logger.log('listenForEncryptedMessage', 'Handling previous event');\n        yield callbackFunction(lastEvent);\n      } else {\n        logger.log('listenForEncryptedMessage', 'No previous event found');\n      }\n\n      const initialListener = this.initialListener;\n\n      if (initialListener) {\n        ;\n        (yield this.client.promise).unsubscribe(MatrixClientEventType.MESSAGE, initialListener);\n      }\n\n      this.initialListener = undefined;\n      this.initialEvent = undefined;\n    });\n  }\n\n  unsubscribeFromEncryptedMessage(senderPublicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const listener = this.activeListeners.get(senderPublicKey);\n\n      if (!listener) {\n        return;\n      }\n\n      ;\n      (yield this.client.promise).unsubscribe(MatrixClientEventType.MESSAGE, listener);\n      this.activeListeners.delete(senderPublicKey);\n    });\n  }\n\n  unsubscribeFromEncryptedMessages() {\n    return __awaiter(this, void 0, void 0, function* () {\n      ;\n      (yield this.client.promise).unsubscribeAll(MatrixClientEventType.MESSAGE);\n      this.activeListeners.clear();\n    });\n  }\n\n  sendMessage(message, peer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        sharedTx\n      } = yield this.createCryptoBoxClient(peer.publicKey, this.keyPair.privateKey);\n      const recipientHash = yield getHexHash(Buffer.from(peer.publicKey, 'hex'));\n      const recipient = recipientString(recipientHash, peer.relayServer);\n      const roomId = yield this.getRelevantRoom(recipient); // Before we send the message, we have to wait for the join to be accepted.\n\n      yield this.waitForJoin(roomId); // TODO: This can probably be removed because we are now waiting inside the get room method\n\n      const encryptedMessage = yield encryptCryptoboxPayload(message, sharedTx);\n      (yield this.client.promise).sendTextMessage(roomId, encryptedMessage).catch(error => __awaiter(this, void 0, void 0, function* () {\n        if (error.errcode === 'M_FORBIDDEN') {\n          // Room doesn't exist\n          logger.log(`sendMessage`, `M_FORBIDDEN`, error);\n          yield this.deleteRoomIdFromRooms(roomId);\n          const newRoomId = yield this.getRelevantRoom(recipient);\n          (yield this.client.promise).sendTextMessage(newRoomId, encryptedMessage).catch(error2 => __awaiter(this, void 0, void 0, function* () {\n            logger.log(`sendMessage`, `inner error`, error2);\n          }));\n        } else {\n          logger.log(`sendMessage`, `not forbidden`, error);\n        }\n      }));\n    });\n  }\n\n  updatePeerRoom(sender, roomId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Sender is in the format \"@pubkeyhash:relayserver.tld\"\n      const split = sender.split(':');\n\n      if (split.length < 2 || !split[0].startsWith('@')) {\n        throw new Error('Invalid sender');\n      }\n\n      const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n      const room = roomIds[sender];\n\n      if (room && room[1]) {\n        // If we have a room already, let's ignore it. We need to do this, otherwise it will be loaded from the matrix cache.\n        this.ignoredRooms.push(room[1]);\n      }\n\n      roomIds[sender] = roomId;\n      yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, roomIds); // TODO: We also need to delete the room from the sync state\n      // If we need to delete a room, we can assume the local state is not up to date anymore, so we can reset the state\n    });\n  }\n\n  deleteRoomIdFromRooms(roomId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n      const newRoomIds = Object.entries(roomIds).filter(entry => entry[1] !== roomId).reduce((pv, cv) => Object.assign(Object.assign({}, pv), {\n        [cv[0]]: cv[1]\n      }), {});\n      yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, newRoomIds); // TODO: We also need to delete the room from the sync state\n      // If we need to delete a room, we can assume the local state is not up to date anymore, so we can reset the state\n\n      this.ignoredRooms.push(roomId);\n    });\n  }\n\n  listenForChannelOpening(messageCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      ;\n      (yield this.client.promise).subscribe(MatrixClientEventType.MESSAGE, event => __awaiter(this, void 0, void 0, function* () {\n        if (this.isTextMessage(event.content) && (yield this.isChannelOpenMessage(event.content))) {\n          logger.log(`listenForChannelOpening`, `channel opening`, JSON.stringify(event));\n          yield this.updateRelayServer(event.content.message.sender);\n          yield this.updatePeerRoom(event.content.message.sender, event.content.roomId);\n          const splits = event.content.message.content.split(':');\n          const payload = Buffer.from(splits[splits.length - 1], 'hex');\n\n          if (payload.length >= sodium.crypto_secretbox_NONCEBYTES + sodium.crypto_secretbox_MACBYTES) {\n            try {\n              const pairingResponse = JSON.parse(yield openCryptobox(payload, this.keyPair.publicKey, this.keyPair.privateKey));\n              messageCallback(Object.assign(Object.assign({}, pairingResponse), {\n                senderId: yield getSenderId(pairingResponse.publicKey)\n              }));\n            } catch (decryptionError) {\n              /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n            }\n          }\n        }\n      }));\n    });\n  }\n\n  waitForJoin(roomId, retry = 0) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Rooms are updated as new events come in. `client.getRoomById` only accesses memory, it does not do any network requests.\n      // TODO: Improve to listen to \"JOIN\" event\n      const room = yield (yield this.client.promise).getRoomById(roomId);\n      logger.log(`waitForJoin`, `Currently ${room.members.length} members, we need at least 2`);\n\n      if (room.members.length >= 2 || room.members.length === 0) {\n        // 0 means it's an unknown room, we don't need to wait\n        return;\n      } else {\n        if (retry <= 200) {\n          // On mobile, due to app switching, we potentially have to wait for a long time\n          logger.log(`Waiting for join... Try: ${retry}`);\n          return new Promise(resolve => {\n            setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n              resolve(this.waitForJoin(roomId, retry + 1));\n            }), 100 * (retry > 50 ? 10 : 1)); // After the initial 5 seconds, retry only once per second\n          });\n        } else {\n          throw new Error(`No one joined after ${retry} tries.`);\n        }\n      }\n    });\n  }\n\n  sendPairingResponse(pairingRequest) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log(`sendPairingResponse`);\n      const recipientHash = yield getHexHash(Buffer.from(pairingRequest.publicKey, 'hex'));\n      const recipient = recipientString(recipientHash, pairingRequest.relayServer); // We force room creation here because if we \"re-pair\", we need to make sure that we don't send it to an old room.\n\n      const roomId = yield (yield this.client.promise).createTrustedPrivateRoom(recipient);\n      yield this.updatePeerRoom(recipient, roomId); // Before we send the message, we have to wait for the join to be accepted.\n\n      yield this.waitForJoin(roomId); // TODO: This can probably be removed because we are now waiting inside the get room method\n      // TODO: remove v1 backwards-compatibility\n\n      const message = typeof pairingRequest.version === 'undefined' ? yield this.getPublicKey() // v1\n      : JSON.stringify(yield this.getPairingResponseInfo(pairingRequest)); // v2\n\n      const encryptedMessage = yield this.encryptMessageAsymmetric(pairingRequest.publicKey, message);\n      const msg = ['@channel-open', recipient, encryptedMessage].join(':');\n      (yield this.client.promise).sendTextMessage(roomId, msg).catch(error => __awaiter(this, void 0, void 0, function* () {\n        if (error.errcode === 'M_FORBIDDEN') {\n          // Room doesn't exist\n          logger.log(`sendMessage`, `M_FORBIDDEN`, error);\n          yield this.deleteRoomIdFromRooms(roomId);\n          const newRoomId = yield this.getRelevantRoom(recipient);\n          (yield this.client.promise).sendTextMessage(newRoomId, msg).catch(error2 => __awaiter(this, void 0, void 0, function* () {\n            logger.log(`sendMessage`, `inner error`, error2);\n          }));\n        } else {\n          logger.log(`sendMessage`, `not forbidden`, error);\n        }\n      }));\n    });\n  }\n\n  isTextMessage(content) {\n    return content.message.type === MatrixMessageType.TEXT;\n  }\n\n  updateRelayServer(sender) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Sender is in the format \"@pubkeyhash:relayserver.tld\"\n      const split = sender.split(':');\n\n      if (split.length < 2 || !split[0].startsWith('@')) {\n        throw new Error('Invalid sender');\n      }\n\n      const senderHash = split.shift();\n      const relayServer = split.join(':');\n      const manager = localStorage.getItem('beacon:communication-peers-dapp') ? new PeerManager(this.storage, StorageKey.TRANSPORT_P2P_PEERS_DAPP) : new PeerManager(this.storage, StorageKey.TRANSPORT_P2P_PEERS_WALLET);\n      const peers = yield manager.getPeers();\n      const promiseArray = peers.map(peer => __awaiter(this, void 0, void 0, function* () {\n        const hash = `@${yield getHexHash(Buffer.from(peer.publicKey, 'hex'))}`;\n\n        if (hash === senderHash) {\n          if (peer.relayServer !== relayServer) {\n            peer.relayServer = relayServer;\n            yield manager.addPeer(peer);\n          }\n        }\n      }));\n      yield Promise.all(promiseArray);\n    });\n  }\n\n  isChannelOpenMessage(content) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return content.message.content.startsWith(`@channel-open:@${yield getHexHash(Buffer.from(yield this.getPublicKey(), 'hex'))}`);\n    });\n  }\n\n  isSender(event, senderPublicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return event.content.message.sender.startsWith(`@${yield getHexHash(Buffer.from(senderPublicKey, 'hex'))}`);\n    });\n  }\n\n  getRelevantRoom(recipient) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n      let roomId = roomIds[recipient];\n\n      if (!roomId) {\n        logger.log(`getRelevantRoom`, `No room found for peer ${recipient}, checking joined ones.`);\n        const room = yield this.getRelevantJoinedRoom(recipient);\n        roomId = room.id;\n        roomIds[recipient] = room.id;\n        yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, roomIds);\n      }\n\n      logger.log(`getRelevantRoom`, `Using room ${roomId}`);\n      return roomId;\n    });\n  }\n\n  getRelevantJoinedRoom(recipient) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const joinedRooms = yield (yield this.client.promise).joinedRooms;\n      logger.log('checking joined rooms', joinedRooms, recipient);\n      const relevantRooms = joinedRooms.filter(roomElement => !this.ignoredRooms.some(id => roomElement.id === id)).filter(roomElement => roomElement.members.some(member => member === recipient));\n      let room; // We always create a new room if one has been ignored. This is because if we ignore one, we know the server state changed.\n      // So we cannot trust the current sync state. This can be removed once we have a method to properly clear and refresh the sync state.\n\n      if (relevantRooms.length === 0 || this.ignoredRooms.length > 0) {\n        logger.log(`getRelevantJoinedRoom`, `no relevant rooms found, creating new one`);\n        const roomId = yield (yield this.client.promise).createTrustedPrivateRoom(recipient);\n        room = yield (yield this.client.promise).getRoomById(roomId);\n        logger.log(`getRelevantJoinedRoom`, `waiting for other party to join room: ${room.id}`);\n        yield this.waitForJoin(roomId);\n        logger.log(`getRelevantJoinedRoom`, `new room created and peer invited: ${room.id}`);\n      } else {\n        room = relevantRooms[0];\n        logger.log(`getRelevantJoinedRoom`, `channel already open, reusing room ${room.id}`);\n      }\n\n      return room;\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../../src/transports/clients/P2PCommunicationClient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as sodium from 'libsodium-wrappers';\nimport axios from 'axios';\nimport { getHexHash, toHex, recipientString, openCryptobox, encryptCryptoboxPayload, decryptCryptoboxPayload } from '../../utils/crypto';\nimport { MatrixClient } from '../../matrix-client/MatrixClient';\nimport { MatrixClientEventType } from '../../matrix-client/models/MatrixClientEvent';\nimport { MatrixMessageType } from '../../matrix-client/models/MatrixMessage';\nimport { PeerManager, StorageKey } from '../..';\nimport { BEACON_VERSION } from '../../constants';\nimport { generateGUID } from '../../utils/generate-uuid';\nimport { getSenderId } from '../../utils/get-sender-id';\nimport { Logger } from '../../utils/Logger';\nimport { CommunicationClient } from './CommunicationClient';\nimport { ExposedPromise } from '../../utils/exposed-promise';\nconst logger = new Logger('P2PCommunicationClient');\nconst KNOWN_RELAY_SERVERS = [\n    'beacon-node-1.sky.papers.tech',\n    'beacon-node-0.papers.tech:8448',\n    'beacon-node-2.sky.papers.tech'\n];\nconst publicKeyToNumber = (arr, mod) => {\n    let sum = 0;\n    for (let i = 0; i < arr.length; i++) {\n        sum += arr[i] + i;\n    }\n    return Math.floor(sum % mod);\n};\n/**\n * @internalapi\n *\n *\n */\nexport class P2PCommunicationClient extends CommunicationClient {\n    constructor(name, keyPair, replicationCount, storage, matrixNodes, iconUrl, appUrl) {\n        super(keyPair);\n        this.name = name;\n        this.replicationCount = replicationCount;\n        this.storage = storage;\n        this.iconUrl = iconUrl;\n        this.appUrl = appUrl;\n        this.client = new ExposedPromise();\n        this.activeListeners = new Map();\n        this.ignoredRooms = [];\n        this.loginCounter = 0;\n        logger.log('constructor', 'P2PCommunicationClient created');\n        this.KNOWN_RELAY_SERVERS = matrixNodes.length > 0 ? matrixNodes : KNOWN_RELAY_SERVERS;\n    }\n    getPairingRequestInfo() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const info = {\n                id: yield generateGUID(),\n                type: 'p2p-pairing-request',\n                name: this.name,\n                version: BEACON_VERSION,\n                publicKey: yield this.getPublicKey(),\n                relayServer: yield this.getRelayServer()\n            };\n            if (this.iconUrl) {\n                info.icon = this.iconUrl;\n            }\n            if (this.appUrl) {\n                info.appUrl = this.appUrl;\n            }\n            return info;\n        });\n    }\n    getPairingResponseInfo(request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const info = {\n                id: request.id,\n                type: 'p2p-pairing-response',\n                name: this.name,\n                version: BEACON_VERSION,\n                publicKey: yield this.getPublicKey(),\n                relayServer: yield this.getRelayServer()\n            };\n            if (this.iconUrl) {\n                info.icon = this.iconUrl;\n            }\n            if (this.appUrl) {\n                info.appUrl = this.appUrl;\n            }\n            return info;\n        });\n    }\n    getRelayServer() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.relayServer) {\n                return this.relayServer.promise;\n            }\n            else {\n                this.relayServer = new ExposedPromise();\n            }\n            // MIGRATION: If a relay server is set, it's all good and we don't have to do any migration\n            const node = yield this.storage.get(StorageKey.MATRIX_SELECTED_NODE);\n            if (node && node.length > 0) {\n                this.relayServer.resolve(node);\n                return node;\n            }\n            else if (KNOWN_RELAY_SERVERS === this.KNOWN_RELAY_SERVERS) {\n                // Migration start\n                // Only if the array of nodes is the default we do the migration, otherwise we leave it.\n                // If NO relay server is set, we have 3 possibilities:\n                const hasDoneMigration = yield this.storage.get(StorageKey.MULTI_NODE_SETUP_DONE);\n                if (!hasDoneMigration) {\n                    // If this migration has run before, we can skip it.\n                    const preservedState = yield this.storage.get(StorageKey.MATRIX_PRESERVED_STATE);\n                    console.log('PRESERVED STATE', preservedState);\n                    if (preservedState.syncToken || preservedState.rooms) {\n                        // If migration has NOT run and we have a sync state, we know have been previously connected. So we set the old default relayServer as our current node.\n                        const node = 'matrix.papers.tech'; // 2.2.7 Migration: This will default to the old default to avoid peers from losing their relayServer.\n                        this.storage\n                            .set(StorageKey.MATRIX_SELECTED_NODE, node)\n                            .catch((error) => logger.log(error));\n                        this.relayServer.resolve(node);\n                        return node;\n                    }\n                    this.storage.set(StorageKey.MULTI_NODE_SETUP_DONE, true).catch((error) => logger.log(error));\n                    // Migration end\n                }\n            }\n            console.log('GET RELAY SERVER');\n            const startIndex = publicKeyToNumber(this.keyPair.publicKey, this.KNOWN_RELAY_SERVERS.length);\n            let offset = 0;\n            while (offset < this.KNOWN_RELAY_SERVERS.length) {\n                const serverIndex = (startIndex + offset) % this.KNOWN_RELAY_SERVERS.length;\n                const server = this.KNOWN_RELAY_SERVERS[serverIndex];\n                try {\n                    yield axios.get(`https://${server}/_matrix/client/versions`);\n                    this.storage\n                        .set(StorageKey.MATRIX_SELECTED_NODE, server)\n                        .catch((error) => logger.log(error));\n                    this.relayServer.resolve(server);\n                    return server;\n                }\n                catch (relayError) {\n                    logger.log(`Ignoring server \"${server}\", trying another one...`);\n                    offset++;\n                }\n            }\n            this.relayServer.reject(`No matrix server reachable!`);\n            throw new Error(`No matrix server reachable!`);\n        });\n    }\n    tryJoinRooms(roomId, retry = 1) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield (yield this.client.promise).joinRooms(roomId);\n            }\n            catch (error) {\n                if (retry <= 10 && error.errcode === 'M_FORBIDDEN') {\n                    // If we join the room too fast after receiving the invite, the server can accidentally reject our join. This seems to be a problem only when using a federated multi-node setup. Usually waiting for a couple milliseconds solves the issue, but to handle lag, we will keep retrying for 2 seconds.\n                    logger.log(`Retrying to join...`, error);\n                    setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                        yield this.tryJoinRooms(roomId, retry + 1);\n                    }), 200);\n                }\n                else {\n                    logger.log(`Failed to join after ${retry} tries.`, error);\n                }\n            }\n        });\n    }\n    start() {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('start', 'starting client');\n            yield sodium.ready;\n            const loginRawDigest = sodium.crypto_generichash(32, sodium.from_string(`login:${Math.floor(Date.now() / 1000 / (5 * 60))}`));\n            const rawSignature = sodium.crypto_sign_detached(loginRawDigest, this.keyPair.privateKey);\n            logger.log('start', `connecting to server`);\n            const relayServer = yield this.getRelayServer();\n            const client = MatrixClient.create({\n                baseUrl: `https://${relayServer}`,\n                storage: this.storage\n            });\n            this.initialListener = (event) => __awaiter(this, void 0, void 0, function* () {\n                if (this.initialEvent && this.initialEvent.timestamp && event && event.timestamp) {\n                    if (this.initialEvent.timestamp < event.timestamp) {\n                        this.initialEvent = event;\n                    }\n                }\n                else {\n                    this.initialEvent = event;\n                }\n            });\n            client.subscribe(MatrixClientEventType.MESSAGE, this.initialListener);\n            client.subscribe(MatrixClientEventType.INVITE, (event) => __awaiter(this, void 0, void 0, function* () {\n                let member;\n                if (event.content.members.length === 1) {\n                    // If there is only one member we know it's a new room\n                    // TODO: Use the \"sender\" of the event instead\n                    member = event.content.members[0];\n                }\n                yield this.tryJoinRooms(event.content.roomId);\n                if (member) {\n                    yield this.updateRelayServer(member);\n                    yield this.updatePeerRoom(member, event.content.roomId);\n                }\n            }));\n            logger.log('start', 'login', yield this.getPublicKeyHash(), 'on', relayServer);\n            try {\n                yield client.start({\n                    id: yield this.getPublicKeyHash(),\n                    password: `ed:${toHex(rawSignature)}:${yield this.getPublicKey()}`,\n                    deviceId: toHex(this.keyPair.publicKey)\n                });\n            }\n            catch (error) {\n                console.log('ERROR, RETRYING');\n                yield this.reset(); // If we can't log in, let's reset\n                console.log('TRYING AGAIN');\n                if (this.loginCounter <= this.KNOWN_RELAY_SERVERS.length) {\n                    this.loginCounter++;\n                    this.start();\n                    return;\n                }\n                else {\n                    throw new Error('Too many login attempts. Try again later.');\n                }\n            }\n            console.log('client is ready');\n            this.client.resolve(client);\n        });\n    }\n    stop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.client.isResolved()) {\n                yield (yield this.client.promise).stop().catch((error) => logger.error(error));\n            }\n            yield this.reset();\n        });\n    }\n    reset() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.storage.delete(StorageKey.MATRIX_PEER_ROOM_IDS).catch((error) => logger.log(error));\n            yield this.storage.delete(StorageKey.MATRIX_PRESERVED_STATE).catch((error) => logger.log(error));\n            yield this.storage.delete(StorageKey.MATRIX_SELECTED_NODE).catch((error) => logger.log(error));\n            // Instead of resetting everything, maybe we should make sure a new instance is created?\n            this.relayServer = undefined;\n            this.client = new ExposedPromise();\n            this.initialEvent = undefined;\n            this.initialListener = undefined;\n        });\n    }\n    listenForEncryptedMessage(senderPublicKey, messageCallback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.activeListeners.has(senderPublicKey)) {\n                return;\n            }\n            const { sharedRx } = yield this.createCryptoBoxServer(senderPublicKey, this.keyPair.privateKey);\n            const callbackFunction = (event) => __awaiter(this, void 0, void 0, function* () {\n                if (this.isTextMessage(event.content) && (yield this.isSender(event, senderPublicKey))) {\n                    let payload;\n                    yield this.updateRelayServer(event.content.message.sender);\n                    yield this.updatePeerRoom(event.content.message.sender, event.content.roomId);\n                    try {\n                        payload = Buffer.from(event.content.message.content, 'hex');\n                        // content can be non-hex if it's a connection open request\n                    }\n                    catch (_a) {\n                        /* */\n                    }\n                    if (payload &&\n                        payload.length >= sodium.crypto_secretbox_NONCEBYTES + sodium.crypto_secretbox_MACBYTES) {\n                        try {\n                            const decryptedMessage = yield decryptCryptoboxPayload(payload, sharedRx);\n                            // logger.log(\n                            //   'listenForEncryptedMessage',\n                            //   'encrypted message received',\n                            //   decryptedMessage,\n                            //   await new Serializer().deserialize(decryptedMessage)\n                            // )\n                            // console.log('calculated sender ID', await getSenderId(senderPublicKey))\n                            // TODO: Add check for correct decryption key / sender ID\n                            messageCallback(decryptedMessage);\n                        }\n                        catch (decryptionError) {\n                            /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n                        }\n                    }\n                }\n            });\n            this.activeListeners.set(senderPublicKey, callbackFunction);\n            (yield this.client.promise).subscribe(MatrixClientEventType.MESSAGE, callbackFunction);\n            const lastEvent = this.initialEvent;\n            if (lastEvent &&\n                lastEvent.timestamp &&\n                new Date().getTime() - lastEvent.timestamp < 5 * 60 * 1000) {\n                logger.log('listenForEncryptedMessage', 'Handling previous event');\n                yield callbackFunction(lastEvent);\n            }\n            else {\n                logger.log('listenForEncryptedMessage', 'No previous event found');\n            }\n            const initialListener = this.initialListener;\n            if (initialListener) {\n                ;\n                (yield this.client.promise).unsubscribe(MatrixClientEventType.MESSAGE, initialListener);\n            }\n            this.initialListener = undefined;\n            this.initialEvent = undefined;\n        });\n    }\n    unsubscribeFromEncryptedMessage(senderPublicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const listener = this.activeListeners.get(senderPublicKey);\n            if (!listener) {\n                return;\n            }\n            ;\n            (yield this.client.promise).unsubscribe(MatrixClientEventType.MESSAGE, listener);\n            this.activeListeners.delete(senderPublicKey);\n        });\n    }\n    unsubscribeFromEncryptedMessages() {\n        return __awaiter(this, void 0, void 0, function* () {\n            ;\n            (yield this.client.promise).unsubscribeAll(MatrixClientEventType.MESSAGE);\n            this.activeListeners.clear();\n        });\n    }\n    sendMessage(message, peer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { sharedTx } = yield this.createCryptoBoxClient(peer.publicKey, this.keyPair.privateKey);\n            const recipientHash = yield getHexHash(Buffer.from(peer.publicKey, 'hex'));\n            const recipient = recipientString(recipientHash, peer.relayServer);\n            const roomId = yield this.getRelevantRoom(recipient);\n            // Before we send the message, we have to wait for the join to be accepted.\n            yield this.waitForJoin(roomId); // TODO: This can probably be removed because we are now waiting inside the get room method\n            const encryptedMessage = yield encryptCryptoboxPayload(message, sharedTx);\n            (yield this.client.promise).sendTextMessage(roomId, encryptedMessage).catch((error) => __awaiter(this, void 0, void 0, function* () {\n                if (error.errcode === 'M_FORBIDDEN') {\n                    // Room doesn't exist\n                    logger.log(`sendMessage`, `M_FORBIDDEN`, error);\n                    yield this.deleteRoomIdFromRooms(roomId);\n                    const newRoomId = yield this.getRelevantRoom(recipient);\n                    (yield this.client.promise)\n                        .sendTextMessage(newRoomId, encryptedMessage)\n                        .catch((error2) => __awaiter(this, void 0, void 0, function* () {\n                        logger.log(`sendMessage`, `inner error`, error2);\n                    }));\n                }\n                else {\n                    logger.log(`sendMessage`, `not forbidden`, error);\n                }\n            }));\n        });\n    }\n    updatePeerRoom(sender, roomId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Sender is in the format \"@pubkeyhash:relayserver.tld\"\n            const split = sender.split(':');\n            if (split.length < 2 || !split[0].startsWith('@')) {\n                throw new Error('Invalid sender');\n            }\n            const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n            const room = roomIds[sender];\n            if (room && room[1]) {\n                // If we have a room already, let's ignore it. We need to do this, otherwise it will be loaded from the matrix cache.\n                this.ignoredRooms.push(room[1]);\n            }\n            roomIds[sender] = roomId;\n            yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, roomIds);\n            // TODO: We also need to delete the room from the sync state\n            // If we need to delete a room, we can assume the local state is not up to date anymore, so we can reset the state\n        });\n    }\n    deleteRoomIdFromRooms(roomId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n            const newRoomIds = Object.entries(roomIds)\n                .filter((entry) => entry[1] !== roomId)\n                .reduce((pv, cv) => (Object.assign(Object.assign({}, pv), { [cv[0]]: cv[1] })), {});\n            yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, newRoomIds);\n            // TODO: We also need to delete the room from the sync state\n            // If we need to delete a room, we can assume the local state is not up to date anymore, so we can reset the state\n            this.ignoredRooms.push(roomId);\n        });\n    }\n    listenForChannelOpening(messageCallback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            ;\n            (yield this.client.promise).subscribe(MatrixClientEventType.MESSAGE, (event) => __awaiter(this, void 0, void 0, function* () {\n                if (this.isTextMessage(event.content) && (yield this.isChannelOpenMessage(event.content))) {\n                    logger.log(`listenForChannelOpening`, `channel opening`, JSON.stringify(event));\n                    yield this.updateRelayServer(event.content.message.sender);\n                    yield this.updatePeerRoom(event.content.message.sender, event.content.roomId);\n                    const splits = event.content.message.content.split(':');\n                    const payload = Buffer.from(splits[splits.length - 1], 'hex');\n                    if (payload.length >=\n                        sodium.crypto_secretbox_NONCEBYTES + sodium.crypto_secretbox_MACBYTES) {\n                        try {\n                            const pairingResponse = JSON.parse(yield openCryptobox(payload, this.keyPair.publicKey, this.keyPair.privateKey));\n                            messageCallback(Object.assign(Object.assign({}, pairingResponse), { senderId: yield getSenderId(pairingResponse.publicKey) }));\n                        }\n                        catch (decryptionError) {\n                            /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n                        }\n                    }\n                }\n            }));\n        });\n    }\n    waitForJoin(roomId, retry = 0) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Rooms are updated as new events come in. `client.getRoomById` only accesses memory, it does not do any network requests.\n            // TODO: Improve to listen to \"JOIN\" event\n            const room = yield (yield this.client.promise).getRoomById(roomId);\n            logger.log(`waitForJoin`, `Currently ${room.members.length} members, we need at least 2`);\n            if (room.members.length >= 2 || room.members.length === 0) {\n                // 0 means it's an unknown room, we don't need to wait\n                return;\n            }\n            else {\n                if (retry <= 200) {\n                    // On mobile, due to app switching, we potentially have to wait for a long time\n                    logger.log(`Waiting for join... Try: ${retry}`);\n                    return new Promise((resolve) => {\n                        setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                            resolve(this.waitForJoin(roomId, retry + 1));\n                        }), 100 * (retry > 50 ? 10 : 1)); // After the initial 5 seconds, retry only once per second\n                    });\n                }\n                else {\n                    throw new Error(`No one joined after ${retry} tries.`);\n                }\n            }\n        });\n    }\n    sendPairingResponse(pairingRequest) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log(`sendPairingResponse`);\n            const recipientHash = yield getHexHash(Buffer.from(pairingRequest.publicKey, 'hex'));\n            const recipient = recipientString(recipientHash, pairingRequest.relayServer);\n            // We force room creation here because if we \"re-pair\", we need to make sure that we don't send it to an old room.\n            const roomId = yield (yield this.client.promise).createTrustedPrivateRoom(recipient);\n            yield this.updatePeerRoom(recipient, roomId);\n            // Before we send the message, we have to wait for the join to be accepted.\n            yield this.waitForJoin(roomId); // TODO: This can probably be removed because we are now waiting inside the get room method\n            // TODO: remove v1 backwards-compatibility\n            const message = typeof pairingRequest.version === 'undefined'\n                ? yield this.getPublicKey() // v1\n                : JSON.stringify(yield this.getPairingResponseInfo(pairingRequest)); // v2\n            const encryptedMessage = yield this.encryptMessageAsymmetric(pairingRequest.publicKey, message);\n            const msg = ['@channel-open', recipient, encryptedMessage].join(':');\n            (yield this.client.promise).sendTextMessage(roomId, msg).catch((error) => __awaiter(this, void 0, void 0, function* () {\n                if (error.errcode === 'M_FORBIDDEN') {\n                    // Room doesn't exist\n                    logger.log(`sendMessage`, `M_FORBIDDEN`, error);\n                    yield this.deleteRoomIdFromRooms(roomId);\n                    const newRoomId = yield this.getRelevantRoom(recipient);\n                    (yield this.client.promise).sendTextMessage(newRoomId, msg).catch((error2) => __awaiter(this, void 0, void 0, function* () {\n                        logger.log(`sendMessage`, `inner error`, error2);\n                    }));\n                }\n                else {\n                    logger.log(`sendMessage`, `not forbidden`, error);\n                }\n            }));\n        });\n    }\n    isTextMessage(content) {\n        return content.message.type === MatrixMessageType.TEXT;\n    }\n    updateRelayServer(sender) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Sender is in the format \"@pubkeyhash:relayserver.tld\"\n            const split = sender.split(':');\n            if (split.length < 2 || !split[0].startsWith('@')) {\n                throw new Error('Invalid sender');\n            }\n            const senderHash = split.shift();\n            const relayServer = split.join(':');\n            const manager = localStorage.getItem('beacon:communication-peers-dapp')\n                ? new PeerManager(this.storage, StorageKey.TRANSPORT_P2P_PEERS_DAPP)\n                : new PeerManager(this.storage, StorageKey.TRANSPORT_P2P_PEERS_WALLET);\n            const peers = yield manager.getPeers();\n            const promiseArray = peers.map((peer) => __awaiter(this, void 0, void 0, function* () {\n                const hash = `@${yield getHexHash(Buffer.from(peer.publicKey, 'hex'))}`;\n                if (hash === senderHash) {\n                    if (peer.relayServer !== relayServer) {\n                        peer.relayServer = relayServer;\n                        yield manager.addPeer(peer);\n                    }\n                }\n            }));\n            yield Promise.all(promiseArray);\n        });\n    }\n    isChannelOpenMessage(content) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return content.message.content.startsWith(`@channel-open:@${yield getHexHash(Buffer.from(yield this.getPublicKey(), 'hex'))}`);\n        });\n    }\n    isSender(event, senderPublicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return event.content.message.sender.startsWith(`@${yield getHexHash(Buffer.from(senderPublicKey, 'hex'))}`);\n        });\n    }\n    getRelevantRoom(recipient) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n            let roomId = roomIds[recipient];\n            if (!roomId) {\n                logger.log(`getRelevantRoom`, `No room found for peer ${recipient}, checking joined ones.`);\n                const room = yield this.getRelevantJoinedRoom(recipient);\n                roomId = room.id;\n                roomIds[recipient] = room.id;\n                yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, roomIds);\n            }\n            logger.log(`getRelevantRoom`, `Using room ${roomId}`);\n            return roomId;\n        });\n    }\n    getRelevantJoinedRoom(recipient) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const joinedRooms = yield (yield this.client.promise).joinedRooms;\n            logger.log('checking joined rooms', joinedRooms, recipient);\n            const relevantRooms = joinedRooms\n                .filter((roomElement) => !this.ignoredRooms.some((id) => roomElement.id === id))\n                .filter((roomElement) => roomElement.members.some((member) => member === recipient));\n            let room;\n            // We always create a new room if one has been ignored. This is because if we ignore one, we know the server state changed.\n            // So we cannot trust the current sync state. This can be removed once we have a method to properly clear and refresh the sync state.\n            if (relevantRooms.length === 0 || this.ignoredRooms.length > 0) {\n                logger.log(`getRelevantJoinedRoom`, `no relevant rooms found, creating new one`);\n                const roomId = yield (yield this.client.promise).createTrustedPrivateRoom(recipient);\n                room = yield (yield this.client.promise).getRoomById(roomId);\n                logger.log(`getRelevantJoinedRoom`, `waiting for other party to join room: ${room.id}`);\n                yield this.waitForJoin(roomId);\n                logger.log(`getRelevantJoinedRoom`, `new room created and peer invited: ${room.id}`);\n            }\n            else {\n                room = relevantRooms[0];\n                logger.log(`getRelevantJoinedRoom`, `channel already open, reusing room ${room.id}`);\n            }\n            return room;\n        });\n    }\n}\n//# sourceMappingURL=P2PCommunicationClient.js.map"]},"metadata":{},"sourceType":"module"}