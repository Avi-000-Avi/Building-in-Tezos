{"ast":null,"code":"import { isCreateEvent, isJoinEvent, isMessageEvent } from '../utils/events';\nimport { MatrixMessage } from './MatrixMessage';\nexport var MatrixRoomStatus;\n\n(function (MatrixRoomStatus) {\n  MatrixRoomStatus[MatrixRoomStatus[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  MatrixRoomStatus[MatrixRoomStatus[\"JOINED\"] = 1] = \"JOINED\";\n  MatrixRoomStatus[MatrixRoomStatus[\"INVITED\"] = 2] = \"INVITED\";\n  MatrixRoomStatus[MatrixRoomStatus[\"LEFT\"] = 3] = \"LEFT\";\n})(MatrixRoomStatus || (MatrixRoomStatus = {}));\n\nexport class MatrixRoom {\n  constructor(id, status = MatrixRoomStatus.UNKNOWN, members = [], messages = []) {\n    this.id = id;\n    this.status = status;\n    this.members = members;\n    this.messages = messages;\n  }\n  /**\n   * Reconstruct rooms from a sync response\n   *\n   * @param roomSync\n   */\n\n\n  static fromSync(roomSync) {\n    function create(rooms, creator) {\n      return Object.entries(rooms).map(([id, room]) => creator(id, room));\n    }\n\n    return [...create(roomSync.join, MatrixRoom.fromJoined), ...create(roomSync.invite, MatrixRoom.fromInvited), ...create(roomSync.leave, MatrixRoom.fromLeft)];\n  }\n  /**\n   * Reconstruct a room from an ID or object\n   *\n   * @param roomOrId\n   * @param status\n   */\n\n\n  static from(roomOrId, status) {\n    return typeof roomOrId === 'string' ? new MatrixRoom(roomOrId, status || MatrixRoomStatus.UNKNOWN) : status !== undefined ? new MatrixRoom(roomOrId.id, status, roomOrId.members, roomOrId.messages) : roomOrId;\n  }\n  /**\n   * Merge new and old state and remove duplicates\n   *\n   * @param newState\n   * @param previousState\n   */\n\n\n  static merge(newState, previousState) {\n    if (!previousState || previousState.id !== newState.id) {\n      return MatrixRoom.from(newState);\n    }\n\n    return new MatrixRoom(newState.id, newState.status, [...previousState.members, ...newState.members].filter((member, index, array) => array.indexOf(member) === index), [...previousState.messages, ...newState.messages]);\n  }\n  /**\n   * Create a room from a join\n   *\n   * @param id\n   * @param joined\n   */\n\n\n  static fromJoined(id, joined) {\n    const events = [...joined.state.events, ...joined.timeline.events];\n    const members = MatrixRoom.getMembersFromEvents(events);\n    const messages = MatrixRoom.getMessagesFromEvents(events);\n    return new MatrixRoom(id, MatrixRoomStatus.JOINED, members, messages);\n  }\n  /**\n   * Create a room from an invite\n   *\n   * @param id\n   * @param invited\n   */\n\n\n  static fromInvited(id, invited) {\n    const members = MatrixRoom.getMembersFromEvents(invited.invite_state.events);\n    return new MatrixRoom(id, MatrixRoomStatus.INVITED, members);\n  }\n  /**\n   * Create a room from a leave\n   *\n   * @param id\n   * @param left\n   */\n\n\n  static fromLeft(id, left) {\n    const events = [...left.state.events, ...left.timeline.events];\n    const members = MatrixRoom.getMembersFromEvents(events);\n    const messages = MatrixRoom.getMessagesFromEvents(events);\n    return new MatrixRoom(id, MatrixRoomStatus.LEFT, members, messages);\n  }\n  /**\n   * Extract members from an event\n   *\n   * @param events\n   */\n\n\n  static getMembersFromEvents(events) {\n    return MatrixRoom.getUniqueEvents(events.filter(event => isCreateEvent(event) || isJoinEvent(event))).map(event => event.sender).filter((member, index, array) => array.indexOf(member) === index);\n  }\n  /**\n   * Extract messages from an event\n   *\n   * @param events\n   */\n\n\n  static getMessagesFromEvents(events) {\n    return MatrixRoom.getUniqueEvents(events.filter(isMessageEvent)).map(event => MatrixMessage.from(event)).filter(Boolean);\n  }\n  /**\n   * Get unique events and remove duplicates\n   *\n   * @param events\n   */\n\n\n  static getUniqueEvents(events) {\n    const eventIds = {};\n    const uniqueEvents = [];\n    events.forEach((event, index) => {\n      const eventId = event.event_id;\n\n      if (eventId === undefined || !(eventId in eventIds)) {\n        if (eventId !== undefined) {\n          eventIds[eventId] = index;\n        }\n\n        uniqueEvents.push(event);\n      }\n    });\n    return uniqueEvents;\n  }\n\n}","map":{"version":3,"sources":["../../../../src/matrix-client/models/MatrixRoom.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isCreateEvent, isJoinEvent, isMessageEvent } from '../utils/events';\nimport { MatrixMessage } from './MatrixMessage';\nexport var MatrixRoomStatus;\n(function (MatrixRoomStatus) {\n    MatrixRoomStatus[MatrixRoomStatus[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    MatrixRoomStatus[MatrixRoomStatus[\"JOINED\"] = 1] = \"JOINED\";\n    MatrixRoomStatus[MatrixRoomStatus[\"INVITED\"] = 2] = \"INVITED\";\n    MatrixRoomStatus[MatrixRoomStatus[\"LEFT\"] = 3] = \"LEFT\";\n})(MatrixRoomStatus || (MatrixRoomStatus = {}));\nexport class MatrixRoom {\n    constructor(id, status = MatrixRoomStatus.UNKNOWN, members = [], messages = []) {\n        this.id = id;\n        this.status = status;\n        this.members = members;\n        this.messages = messages;\n    }\n    /**\n     * Reconstruct rooms from a sync response\n     *\n     * @param roomSync\n     */\n    static fromSync(roomSync) {\n        function create(rooms, creator) {\n            return Object.entries(rooms).map(([id, room]) => creator(id, room));\n        }\n        return [\n            ...create(roomSync.join, MatrixRoom.fromJoined),\n            ...create(roomSync.invite, MatrixRoom.fromInvited),\n            ...create(roomSync.leave, MatrixRoom.fromLeft)\n        ];\n    }\n    /**\n     * Reconstruct a room from an ID or object\n     *\n     * @param roomOrId\n     * @param status\n     */\n    static from(roomOrId, status) {\n        return typeof roomOrId === 'string'\n            ? new MatrixRoom(roomOrId, status || MatrixRoomStatus.UNKNOWN)\n            : status !== undefined\n                ? new MatrixRoom(roomOrId.id, status, roomOrId.members, roomOrId.messages)\n                : roomOrId;\n    }\n    /**\n     * Merge new and old state and remove duplicates\n     *\n     * @param newState\n     * @param previousState\n     */\n    static merge(newState, previousState) {\n        if (!previousState || previousState.id !== newState.id) {\n            return MatrixRoom.from(newState);\n        }\n        return new MatrixRoom(newState.id, newState.status, [...previousState.members, ...newState.members].filter((member, index, array) => array.indexOf(member) === index), [...previousState.messages, ...newState.messages]);\n    }\n    /**\n     * Create a room from a join\n     *\n     * @param id\n     * @param joined\n     */\n    static fromJoined(id, joined) {\n        const events = [...joined.state.events, ...joined.timeline.events];\n        const members = MatrixRoom.getMembersFromEvents(events);\n        const messages = MatrixRoom.getMessagesFromEvents(events);\n        return new MatrixRoom(id, MatrixRoomStatus.JOINED, members, messages);\n    }\n    /**\n     * Create a room from an invite\n     *\n     * @param id\n     * @param invited\n     */\n    static fromInvited(id, invited) {\n        const members = MatrixRoom.getMembersFromEvents(invited.invite_state.events);\n        return new MatrixRoom(id, MatrixRoomStatus.INVITED, members);\n    }\n    /**\n     * Create a room from a leave\n     *\n     * @param id\n     * @param left\n     */\n    static fromLeft(id, left) {\n        const events = [...left.state.events, ...left.timeline.events];\n        const members = MatrixRoom.getMembersFromEvents(events);\n        const messages = MatrixRoom.getMessagesFromEvents(events);\n        return new MatrixRoom(id, MatrixRoomStatus.LEFT, members, messages);\n    }\n    /**\n     * Extract members from an event\n     *\n     * @param events\n     */\n    static getMembersFromEvents(events) {\n        return MatrixRoom.getUniqueEvents(events.filter((event) => isCreateEvent(event) || isJoinEvent(event)))\n            .map((event) => event.sender)\n            .filter((member, index, array) => array.indexOf(member) === index);\n    }\n    /**\n     * Extract messages from an event\n     *\n     * @param events\n     */\n    static getMessagesFromEvents(events) {\n        return MatrixRoom.getUniqueEvents(events.filter(isMessageEvent))\n            .map((event) => MatrixMessage.from(event))\n            .filter(Boolean);\n    }\n    /**\n     * Get unique events and remove duplicates\n     *\n     * @param events\n     */\n    static getUniqueEvents(events) {\n        const eventIds = {};\n        const uniqueEvents = [];\n        events.forEach((event, index) => {\n            const eventId = event.event_id;\n            if (eventId === undefined || !(eventId in eventIds)) {\n                if (eventId !== undefined) {\n                    eventIds[eventId] = index;\n                }\n                uniqueEvents.push(event);\n            }\n        });\n        return uniqueEvents;\n    }\n}\n//# sourceMappingURL=MatrixRoom.js.map"]},"metadata":{},"sourceType":"module"}