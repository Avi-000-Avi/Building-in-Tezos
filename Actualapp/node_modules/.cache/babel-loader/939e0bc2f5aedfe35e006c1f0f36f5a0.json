{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport axios from 'axios';\nimport { keys } from '../utils/utils';\nconst CLIENT_API_R0 = '/_matrix/client/r0';\n/**\n * Handling the HTTP connection to the matrix synapse node\n */\n\nexport class MatrixHttpClient {\n  constructor(baseUrl) {\n    this.baseUrl = baseUrl;\n    this.cancelTokenSource = axios.CancelToken.source();\n  }\n  /**\n   * Get data from the synapse node\n   *\n   * @param endpoint\n   * @param options\n   */\n\n\n  get(endpoint, params, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.send('GET', endpoint, options, params);\n    });\n  }\n  /**\n   * Post data to the synapse node\n   *\n   * @param endpoint\n   * @param body\n   * @param options\n   * @param params\n   */\n\n\n  post(endpoint, body, options, params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.send('POST', endpoint, options, params, body);\n    });\n  }\n  /**\n   * Put data to the synapse node\n   *\n   * @param endpoint\n   * @param body\n   * @param options\n   * @param params\n   */\n\n\n  put(endpoint, body, options, params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.send('PUT', endpoint, options, params, body);\n    });\n  }\n\n  cancelAllRequests() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.cancelTokenSource.cancel('Manually cancelled');\n    });\n  }\n  /**\n   * Send a request to the synapse node\n   *\n   * @param method\n   * @param endpoint\n   * @param config\n   * @param requestParams\n   * @param data\n   */\n\n\n  send(method, endpoint, config, requestParams, data) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const headers = config ? this.getHeaders(config) : undefined;\n      const params = requestParams ? this.getParams(requestParams) : undefined;\n      let response;\n\n      try {\n        response = yield axios.request({\n          method,\n          url: endpoint,\n          baseURL: this.apiUrl(CLIENT_API_R0),\n          headers,\n          data,\n          params,\n          cancelToken: this.cancelTokenSource.token\n        });\n      } catch (axiosError) {\n        throw axiosError.response.data;\n      }\n\n      return response.data;\n    });\n  }\n  /**\n   * Get the headers based on the options object\n   *\n   * @param options\n   */\n\n\n  getHeaders(options) {\n    const headers = {};\n    const entries = [];\n\n    if (options.accessToken) {\n      entries.push(['Authorization', `Bearer ${options.accessToken}`]);\n    }\n\n    if (entries.length === 0) {\n      return undefined;\n    }\n\n    for (const [key, value] of entries) {\n      headers[key] = value;\n    }\n\n    return headers;\n  }\n  /**\n   * Get parameters\n   *\n   * @param _params\n   */\n\n\n  getParams(_params) {\n    if (!_params) {\n      return undefined;\n    }\n\n    const params = Object.assign(_params, {});\n    keys(params).forEach(key => params[key] === undefined && delete params[key]);\n    return params;\n  }\n  /**\n   * Construct API URL\n   */\n\n\n  apiUrl(...parts) {\n    const apiBase = this.baseUrl.endsWith('/') ? this.baseUrl.substr(0, this.baseUrl.length - 1) : this.baseUrl;\n    const apiParts = parts.map(path => path.startsWith('/') ? path.substr(1) : path);\n    return [apiBase, ...apiParts].join('/');\n  }\n\n}","map":{"version":3,"sources":["../../../src/matrix-client/MatrixHttpClient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport axios from 'axios';\nimport { keys } from '../utils/utils';\nconst CLIENT_API_R0 = '/_matrix/client/r0';\n/**\n * Handling the HTTP connection to the matrix synapse node\n */\nexport class MatrixHttpClient {\n    constructor(baseUrl) {\n        this.baseUrl = baseUrl;\n        this.cancelTokenSource = axios.CancelToken.source();\n    }\n    /**\n     * Get data from the synapse node\n     *\n     * @param endpoint\n     * @param options\n     */\n    get(endpoint, params, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.send('GET', endpoint, options, params);\n        });\n    }\n    /**\n     * Post data to the synapse node\n     *\n     * @param endpoint\n     * @param body\n     * @param options\n     * @param params\n     */\n    post(endpoint, body, options, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.send('POST', endpoint, options, params, body);\n        });\n    }\n    /**\n     * Put data to the synapse node\n     *\n     * @param endpoint\n     * @param body\n     * @param options\n     * @param params\n     */\n    put(endpoint, body, options, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.send('PUT', endpoint, options, params, body);\n        });\n    }\n    cancelAllRequests() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.cancelTokenSource.cancel('Manually cancelled');\n        });\n    }\n    /**\n     * Send a request to the synapse node\n     *\n     * @param method\n     * @param endpoint\n     * @param config\n     * @param requestParams\n     * @param data\n     */\n    send(method, endpoint, config, requestParams, data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const headers = config ? this.getHeaders(config) : undefined;\n            const params = requestParams ? this.getParams(requestParams) : undefined;\n            let response;\n            try {\n                response = yield axios.request({\n                    method,\n                    url: endpoint,\n                    baseURL: this.apiUrl(CLIENT_API_R0),\n                    headers,\n                    data,\n                    params,\n                    cancelToken: this.cancelTokenSource.token\n                });\n            }\n            catch (axiosError) {\n                throw axiosError.response.data;\n            }\n            return response.data;\n        });\n    }\n    /**\n     * Get the headers based on the options object\n     *\n     * @param options\n     */\n    getHeaders(options) {\n        const headers = {};\n        const entries = [];\n        if (options.accessToken) {\n            entries.push(['Authorization', `Bearer ${options.accessToken}`]);\n        }\n        if (entries.length === 0) {\n            return undefined;\n        }\n        for (const [key, value] of entries) {\n            headers[key] = value;\n        }\n        return headers;\n    }\n    /**\n     * Get parameters\n     *\n     * @param _params\n     */\n    getParams(_params) {\n        if (!_params) {\n            return undefined;\n        }\n        const params = Object.assign(_params, {});\n        keys(params).forEach((key) => params[key] === undefined && delete params[key]);\n        return params;\n    }\n    /**\n     * Construct API URL\n     */\n    apiUrl(...parts) {\n        const apiBase = this.baseUrl.endsWith('/')\n            ? this.baseUrl.substr(0, this.baseUrl.length - 1)\n            : this.baseUrl;\n        const apiParts = parts.map((path) => (path.startsWith('/') ? path.substr(1) : path));\n        return [apiBase, ...apiParts].join('/');\n    }\n}\n//# sourceMappingURL=MatrixHttpClient.js.map"]},"metadata":{},"sourceType":"module"}