{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Serializer, Client, LocalStorage, TransportStatus, WalletP2PTransport } from '../..';\nimport { PermissionManager } from '../../managers/PermissionManager';\nimport { AppMetadataManager } from '../../managers/AppMetadataManager';\nimport { IncomingRequestInterceptor } from '../../interceptors/IncomingRequestInterceptor';\nimport { OutgoingResponseInterceptor } from '../../interceptors/OutgoingResponseInterceptor';\nimport { BeaconMessageType } from '../../types/beacon/BeaconMessageType';\nimport { getSenderId } from '../../utils/get-sender-id';\nimport { ExposedPromise } from '../../utils/exposed-promise';\nimport { Logger } from '../../utils/Logger';\nconst logger = new Logger('WalletClient');\n/**\n * @publicapi\n *\n * The WalletClient has to be used in the wallet. It handles all the logic related to connecting to beacon-compatible\n * dapps and handling/responding to requests.\n *\n * @category Wallet\n */\n\nexport class WalletClient extends Client {\n  constructor(config) {\n    super(Object.assign({\n      storage: new LocalStorage()\n    }, config));\n    /**\n     * Returns whether or not the transport is connected\n     */\n\n    this._isConnected = new ExposedPromise();\n    /**\n     * This array stores pending requests, meaning requests we received and have not yet handled / sent a response.\n     */\n\n    this.pendingRequests = [];\n    this.permissionManager = new PermissionManager(new LocalStorage());\n    this.appMetadataManager = new AppMetadataManager(new LocalStorage());\n  }\n\n  get isConnected() {\n    return this._isConnected.promise;\n  }\n\n  init() {\n    const _super = Object.create(null, {\n      init: {\n        get: () => super.init\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const keyPair = yield this.keyPair; // We wait for keypair here so the P2P Transport creation is not delayed and causing issues\n\n      const p2pTransport = new WalletP2PTransport(this.name, keyPair, this.storage, this.matrixNodes, this.iconUrl, this.appUrl);\n      return _super.init.call(this, p2pTransport);\n    });\n  }\n  /**\n   * This method initiates a connection to the P2P network and registers a callback that will be called\n   * whenever a message is received.\n   *\n   * @param newMessageCallback The callback that will be invoked for every message the transport receives.\n   */\n\n\n  connect(newMessageCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.handleResponse = (message, connectionContext) => __awaiter(this, void 0, void 0, function* () {\n        if (message.type === BeaconMessageType.Disconnect) {\n          const transport = yield this.transport;\n          const peers = yield transport.getPeers();\n          const peer = peers.find(peerEl => peerEl.senderId === message.senderId);\n\n          if (peer) {\n            yield this.removePeer(peer);\n          }\n\n          return;\n        }\n\n        if (!this.pendingRequests.some(request => request[0].id === message.id)) {\n          this.pendingRequests.push([message, connectionContext]);\n\n          if (message.version !== '1') {\n            yield this.sendAcknowledgeResponse(message, connectionContext);\n          }\n\n          yield IncomingRequestInterceptor.intercept({\n            message,\n            connectionInfo: connectionContext,\n            appMetadataManager: this.appMetadataManager,\n            interceptorCallback: newMessageCallback\n          });\n        }\n      });\n\n      return this._connect();\n    });\n  }\n  /**\n   * The method will attempt to initiate a connection using the active transport.\n   */\n\n\n  _connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const transport = yield this.transport;\n\n      if (transport.connectionStatus === TransportStatus.NOT_CONNECTED) {\n        yield transport.connect();\n        transport.addListener((message, connectionInfo) => __awaiter(this, void 0, void 0, function* () {\n          if (typeof message === 'string') {\n            const deserializedMessage = yield new Serializer().deserialize(message);\n            this.handleResponse(deserializedMessage, connectionInfo);\n          }\n        })).catch(error => logger.log('_connect', error));\n\n        this._isConnected.resolve(true);\n      } else {// NO-OP\n      }\n    });\n  }\n  /**\n   * This method sends a response for a specific request back to the DApp\n   *\n   * @param message The BeaconResponseMessage that will be sent back to the DApp\n   */\n\n\n  respond(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const request = this.pendingRequests.find(pendingRequest => pendingRequest[0].id === message.id);\n\n      if (!request) {\n        throw new Error('No matching request found!');\n      }\n\n      this.pendingRequests = this.pendingRequests.filter(pendingRequest => pendingRequest[0].id !== message.id);\n      yield OutgoingResponseInterceptor.intercept({\n        senderId: yield getSenderId(yield this.beaconId),\n        request: request[0],\n        message,\n        ownAppMetadata: yield this.getOwnAppMetadata(),\n        permissionManager: this.permissionManager,\n        appMetadataManager: this.appMetadataManager,\n        interceptorCallback: response => __awaiter(this, void 0, void 0, function* () {\n          yield this.respondToMessage(response, request[1]);\n        })\n      });\n    });\n  }\n\n  getAppMetadataList() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.appMetadataManager.getAppMetadataList();\n    });\n  }\n\n  getAppMetadata(senderId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.appMetadataManager.getAppMetadata(senderId);\n    });\n  }\n\n  removeAppMetadata(senderId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.appMetadataManager.removeAppMetadata(senderId);\n    });\n  }\n\n  removeAllAppMetadata() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.appMetadataManager.removeAllAppMetadata();\n    });\n  }\n\n  getPermissions() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.permissionManager.getPermissions();\n    });\n  }\n\n  getPermission(accountIdentifier) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.permissionManager.getPermission(accountIdentifier);\n    });\n  }\n\n  removePermission(accountIdentifier) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.permissionManager.removePermission(accountIdentifier);\n    });\n  }\n\n  removeAllPermissions() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.permissionManager.removeAllPermissions();\n    });\n  }\n  /**\n   * Add a new peer to the known peers\n   * @param peer The new peer to add\n   */\n\n\n  addPeer(peer, sendPairingResponse = true) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const extendedPeer = Object.assign(Object.assign({}, peer), {\n        senderId: yield getSenderId(peer.publicKey)\n      });\n      return (yield this.transport).addPeer(extendedPeer, sendPairingResponse);\n    });\n  }\n\n  removePeer(peer, sendDisconnectToPeer = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const removePeerResult = (yield this.transport).removePeer(peer);\n      yield this.removePermissionsForPeers([peer]);\n\n      if (sendDisconnectToPeer) {\n        yield this.sendDisconnectToPeer(peer);\n      }\n\n      return removePeerResult;\n    });\n  }\n\n  removeAllPeers(sendDisconnectToPeers = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const peers = yield (yield this.transport).getPeers();\n      const removePeerResult = (yield this.transport).removeAllPeers();\n      yield this.removePermissionsForPeers(peers);\n\n      if (sendDisconnectToPeers) {\n        const disconnectPromises = peers.map(peer => this.sendDisconnectToPeer(peer));\n        yield Promise.all(disconnectPromises);\n      }\n\n      return removePeerResult;\n    });\n  }\n\n  removePermissionsForPeers(peersToRemove) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const permissions = yield this.permissionManager.getPermissions();\n      const peerIdsToRemove = peersToRemove.map(peer => peer.senderId); // Remove all permissions with origin of the specified peer\n\n      const permissionsToRemove = permissions.filter(permission => peerIdsToRemove.includes(permission.appMetadata.senderId));\n      const permissionIdentifiersToRemove = permissionsToRemove.map(permissionInfo => permissionInfo.accountIdentifier);\n      yield this.permissionManager.removePermissions(permissionIdentifiersToRemove);\n    });\n  }\n  /**\n   * Send an acknowledge message back to the sender\n   *\n   * @param message The message that was received\n   */\n\n\n  sendAcknowledgeResponse(request, connectionContext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Acknowledge the message\n      const acknowledgeResponse = {\n        id: request.id,\n        type: BeaconMessageType.Acknowledge\n      };\n      yield OutgoingResponseInterceptor.intercept({\n        senderId: yield getSenderId(yield this.beaconId),\n        request,\n        message: acknowledgeResponse,\n        ownAppMetadata: yield this.getOwnAppMetadata(),\n        permissionManager: this.permissionManager,\n        appMetadataManager: this.appMetadataManager,\n        interceptorCallback: response => __awaiter(this, void 0, void 0, function* () {\n          yield this.respondToMessage(response, connectionContext);\n        })\n      });\n    });\n  }\n  /**\n   * An internal method to send a BeaconMessage to the DApp\n   *\n   * @param response Send a message back to the DApp\n   */\n\n\n  respondToMessage(response, connectionContext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const serializedMessage = yield new Serializer().serialize(response);\n\n      if (connectionContext) {\n        const peerInfos = yield this.getPeers();\n        const peer = peerInfos.find(peerInfo => peerInfo.publicKey === connectionContext.id);\n        yield (yield this.transport).send(serializedMessage, peer);\n      } else {\n        yield (yield this.transport).send(serializedMessage);\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../../src/clients/wallet-client/WalletClient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Serializer, Client, LocalStorage, TransportStatus, WalletP2PTransport } from '../..';\nimport { PermissionManager } from '../../managers/PermissionManager';\nimport { AppMetadataManager } from '../../managers/AppMetadataManager';\nimport { IncomingRequestInterceptor } from '../../interceptors/IncomingRequestInterceptor';\nimport { OutgoingResponseInterceptor } from '../../interceptors/OutgoingResponseInterceptor';\nimport { BeaconMessageType } from '../../types/beacon/BeaconMessageType';\nimport { getSenderId } from '../../utils/get-sender-id';\nimport { ExposedPromise } from '../../utils/exposed-promise';\nimport { Logger } from '../../utils/Logger';\nconst logger = new Logger('WalletClient');\n/**\n * @publicapi\n *\n * The WalletClient has to be used in the wallet. It handles all the logic related to connecting to beacon-compatible\n * dapps and handling/responding to requests.\n *\n * @category Wallet\n */\nexport class WalletClient extends Client {\n    constructor(config) {\n        super(Object.assign({ storage: new LocalStorage() }, config));\n        /**\n         * Returns whether or not the transport is connected\n         */\n        this._isConnected = new ExposedPromise();\n        /**\n         * This array stores pending requests, meaning requests we received and have not yet handled / sent a response.\n         */\n        this.pendingRequests = [];\n        this.permissionManager = new PermissionManager(new LocalStorage());\n        this.appMetadataManager = new AppMetadataManager(new LocalStorage());\n    }\n    get isConnected() {\n        return this._isConnected.promise;\n    }\n    init() {\n        const _super = Object.create(null, {\n            init: { get: () => super.init }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const keyPair = yield this.keyPair; // We wait for keypair here so the P2P Transport creation is not delayed and causing issues\n            const p2pTransport = new WalletP2PTransport(this.name, keyPair, this.storage, this.matrixNodes, this.iconUrl, this.appUrl);\n            return _super.init.call(this, p2pTransport);\n        });\n    }\n    /**\n     * This method initiates a connection to the P2P network and registers a callback that will be called\n     * whenever a message is received.\n     *\n     * @param newMessageCallback The callback that will be invoked for every message the transport receives.\n     */\n    connect(newMessageCallback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.handleResponse = (message, connectionContext) => __awaiter(this, void 0, void 0, function* () {\n                if (message.type === BeaconMessageType.Disconnect) {\n                    const transport = yield this.transport;\n                    const peers = yield transport.getPeers();\n                    const peer = peers.find((peerEl) => peerEl.senderId === message.senderId);\n                    if (peer) {\n                        yield this.removePeer(peer);\n                    }\n                    return;\n                }\n                if (!this.pendingRequests.some((request) => request[0].id === message.id)) {\n                    this.pendingRequests.push([message, connectionContext]);\n                    if (message.version !== '1') {\n                        yield this.sendAcknowledgeResponse(message, connectionContext);\n                    }\n                    yield IncomingRequestInterceptor.intercept({\n                        message,\n                        connectionInfo: connectionContext,\n                        appMetadataManager: this.appMetadataManager,\n                        interceptorCallback: newMessageCallback\n                    });\n                }\n            });\n            return this._connect();\n        });\n    }\n    /**\n     * The method will attempt to initiate a connection using the active transport.\n     */\n    _connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const transport = (yield this.transport);\n            if (transport.connectionStatus === TransportStatus.NOT_CONNECTED) {\n                yield transport.connect();\n                transport\n                    .addListener((message, connectionInfo) => __awaiter(this, void 0, void 0, function* () {\n                    if (typeof message === 'string') {\n                        const deserializedMessage = (yield new Serializer().deserialize(message));\n                        this.handleResponse(deserializedMessage, connectionInfo);\n                    }\n                }))\n                    .catch((error) => logger.log('_connect', error));\n                this._isConnected.resolve(true);\n            }\n            else {\n                // NO-OP\n            }\n        });\n    }\n    /**\n     * This method sends a response for a specific request back to the DApp\n     *\n     * @param message The BeaconResponseMessage that will be sent back to the DApp\n     */\n    respond(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const request = this.pendingRequests.find((pendingRequest) => pendingRequest[0].id === message.id);\n            if (!request) {\n                throw new Error('No matching request found!');\n            }\n            this.pendingRequests = this.pendingRequests.filter((pendingRequest) => pendingRequest[0].id !== message.id);\n            yield OutgoingResponseInterceptor.intercept({\n                senderId: yield getSenderId(yield this.beaconId),\n                request: request[0],\n                message,\n                ownAppMetadata: yield this.getOwnAppMetadata(),\n                permissionManager: this.permissionManager,\n                appMetadataManager: this.appMetadataManager,\n                interceptorCallback: (response) => __awaiter(this, void 0, void 0, function* () {\n                    yield this.respondToMessage(response, request[1]);\n                })\n            });\n        });\n    }\n    getAppMetadataList() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.appMetadataManager.getAppMetadataList();\n        });\n    }\n    getAppMetadata(senderId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.appMetadataManager.getAppMetadata(senderId);\n        });\n    }\n    removeAppMetadata(senderId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.appMetadataManager.removeAppMetadata(senderId);\n        });\n    }\n    removeAllAppMetadata() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.appMetadataManager.removeAllAppMetadata();\n        });\n    }\n    getPermissions() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.permissionManager.getPermissions();\n        });\n    }\n    getPermission(accountIdentifier) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.permissionManager.getPermission(accountIdentifier);\n        });\n    }\n    removePermission(accountIdentifier) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.permissionManager.removePermission(accountIdentifier);\n        });\n    }\n    removeAllPermissions() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.permissionManager.removeAllPermissions();\n        });\n    }\n    /**\n     * Add a new peer to the known peers\n     * @param peer The new peer to add\n     */\n    addPeer(peer, sendPairingResponse = true) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const extendedPeer = Object.assign(Object.assign({}, peer), { senderId: yield getSenderId(peer.publicKey) });\n            return (yield this.transport).addPeer(extendedPeer, sendPairingResponse);\n        });\n    }\n    removePeer(peer, sendDisconnectToPeer = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const removePeerResult = (yield this.transport).removePeer(peer);\n            yield this.removePermissionsForPeers([peer]);\n            if (sendDisconnectToPeer) {\n                yield this.sendDisconnectToPeer(peer);\n            }\n            return removePeerResult;\n        });\n    }\n    removeAllPeers(sendDisconnectToPeers = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const peers = yield (yield this.transport).getPeers();\n            const removePeerResult = (yield this.transport).removeAllPeers();\n            yield this.removePermissionsForPeers(peers);\n            if (sendDisconnectToPeers) {\n                const disconnectPromises = peers.map((peer) => this.sendDisconnectToPeer(peer));\n                yield Promise.all(disconnectPromises);\n            }\n            return removePeerResult;\n        });\n    }\n    removePermissionsForPeers(peersToRemove) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const permissions = yield this.permissionManager.getPermissions();\n            const peerIdsToRemove = peersToRemove.map((peer) => peer.senderId);\n            // Remove all permissions with origin of the specified peer\n            const permissionsToRemove = permissions.filter((permission) => peerIdsToRemove.includes(permission.appMetadata.senderId));\n            const permissionIdentifiersToRemove = permissionsToRemove.map((permissionInfo) => permissionInfo.accountIdentifier);\n            yield this.permissionManager.removePermissions(permissionIdentifiersToRemove);\n        });\n    }\n    /**\n     * Send an acknowledge message back to the sender\n     *\n     * @param message The message that was received\n     */\n    sendAcknowledgeResponse(request, connectionContext) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Acknowledge the message\n            const acknowledgeResponse = {\n                id: request.id,\n                type: BeaconMessageType.Acknowledge\n            };\n            yield OutgoingResponseInterceptor.intercept({\n                senderId: yield getSenderId(yield this.beaconId),\n                request,\n                message: acknowledgeResponse,\n                ownAppMetadata: yield this.getOwnAppMetadata(),\n                permissionManager: this.permissionManager,\n                appMetadataManager: this.appMetadataManager,\n                interceptorCallback: (response) => __awaiter(this, void 0, void 0, function* () {\n                    yield this.respondToMessage(response, connectionContext);\n                })\n            });\n        });\n    }\n    /**\n     * An internal method to send a BeaconMessage to the DApp\n     *\n     * @param response Send a message back to the DApp\n     */\n    respondToMessage(response, connectionContext) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const serializedMessage = yield new Serializer().serialize(response);\n            if (connectionContext) {\n                const peerInfos = yield this.getPeers();\n                const peer = peerInfos.find((peerInfo) => peerInfo.publicKey === connectionContext.id);\n                yield (yield this.transport).send(serializedMessage, peer);\n            }\n            else {\n                yield (yield this.transport).send(serializedMessage);\n            }\n        });\n    }\n}\n//# sourceMappingURL=WalletClient.js.map"]},"metadata":{},"sourceType":"module"}