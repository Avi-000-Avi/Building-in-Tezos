{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport * as bs58check from 'bs58check';\nimport * as sodium from 'libsodium-wrappers';\n/* eslint-disable prefer-arrow/prefer-arrow-functions */\n\n/**\n * Convert a value to hex\n *\n * @param value\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexport function toHex(value) {\n  return Buffer.from(value).toString('hex');\n}\n/**\n * Get the hex hash of a value\n *\n * @param key\n */\n\nexport function getHexHash(key) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield sodium.ready;\n    return toHex(sodium.crypto_generichash(32, key));\n  });\n}\n/**\n * Get a keypair from a seed\n *\n * @param seed\n */\n\nexport function getKeypairFromSeed(seed) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield sodium.ready;\n    return sodium.crypto_sign_seed_keypair(sodium.crypto_generichash(32, sodium.from_string(seed)));\n  });\n}\n/**\n * Encrypt a message with a shared key\n *\n * @param message\n * @param sharedKey\n */\n\nexport function encryptCryptoboxPayload(message, sharedKey) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield sodium.ready;\n    const nonce = Buffer.from(sodium.randombytes_buf(sodium.crypto_secretbox_NONCEBYTES));\n    const combinedPayload = Buffer.concat([nonce, Buffer.from(sodium.crypto_secretbox_easy(Buffer.from(message, 'utf8'), nonce, sharedKey))]);\n    return toHex(combinedPayload);\n  });\n}\n/**\n * Decrypt a message with a shared key\n *\n * @param payload\n * @param sharedKey\n */\n\nexport function decryptCryptoboxPayload(payload, sharedKey) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield sodium.ready;\n    const nonce = payload.slice(0, sodium.crypto_secretbox_NONCEBYTES);\n    const ciphertext = payload.slice(sodium.crypto_secretbox_NONCEBYTES);\n    return Buffer.from(sodium.crypto_secretbox_open_easy(ciphertext, nonce, sharedKey)).toString('utf8');\n  });\n}\n/**\n * Encrypt a message with a public key\n *\n * @param payload\n * @param publicKey\n */\n\nexport function sealCryptobox(payload, publicKey) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield sodium.ready;\n    const kxSelfPublicKey = sodium.crypto_sign_ed25519_pk_to_curve25519(Buffer.from(publicKey)); // Secret bytes to scalar bytes\n\n    const encryptedMessage = sodium.crypto_box_seal(payload, kxSelfPublicKey);\n    return toHex(encryptedMessage);\n  });\n}\n/**\n * Decrypt a message with public + private key\n *\n * @param encryptedPayload\n * @param publicKey\n * @param privateKey\n */\n\nexport function openCryptobox(encryptedPayload, publicKey, privateKey) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield sodium.ready;\n    const kxSelfPrivateKey = sodium.crypto_sign_ed25519_sk_to_curve25519(Buffer.from(privateKey)); // Secret bytes to scalar bytes\n\n    const kxSelfPublicKey = sodium.crypto_sign_ed25519_pk_to_curve25519(Buffer.from(publicKey)); // Secret bytes to scalar bytes\n\n    const decryptedMessage = sodium.crypto_box_seal_open(encryptedPayload, kxSelfPublicKey, kxSelfPrivateKey);\n    return Buffer.from(decryptedMessage).toString();\n  });\n}\n/**\n * Get an address from the public key\n *\n * @param publicKey\n */\n\nexport function getAddressFromPublicKey(publicKey) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield sodium.ready;\n    const prefixes = {\n      // tz1...\n      edpk: {\n        length: 54,\n        prefix: Buffer.from(new Uint8Array([6, 161, 159]))\n      },\n      // tz2...\n      sppk: {\n        length: 55,\n        prefix: Buffer.from(new Uint8Array([6, 161, 161]))\n      },\n      // tz3...\n      p2pk: {\n        length: 55,\n        prefix: Buffer.from(new Uint8Array([6, 161, 164]))\n      }\n    };\n    let prefix;\n    let plainPublicKey;\n\n    if (publicKey.length === 64) {\n      prefix = prefixes.edpk.prefix;\n      plainPublicKey = publicKey;\n    } else {\n      const entries = Object.entries(prefixes);\n\n      for (let index = 0; index < entries.length; index++) {\n        const [key, value] = entries[index];\n\n        if (publicKey.startsWith(key) && publicKey.length === value.length) {\n          prefix = value.prefix;\n          const decoded = bs58check.decode(publicKey);\n          plainPublicKey = decoded.slice(key.length, decoded.length).toString('hex');\n          break;\n        }\n      }\n    }\n\n    if (!prefix || !plainPublicKey) {\n      throw new Error(`invalid publicKey: ${publicKey}`);\n    }\n\n    const payload = sodium.crypto_generichash(20, Buffer.from(plainPublicKey, 'hex'));\n    return bs58check.encode(Buffer.concat([prefix, Buffer.from(payload)]));\n  });\n}\n/**\n * Get the recipient string used in the matrix message\n *\n * @param recipientHash\n * @param relayServer\n */\n\nexport function recipientString(recipientHash, relayServer) {\n  return `@${recipientHash}:${relayServer}`;\n}\n/* eslint-enable prefer-arrow/prefer-arrow-functions */","map":{"version":3,"sources":["../../../src/utils/crypto.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as bs58check from 'bs58check';\nimport * as sodium from 'libsodium-wrappers';\n/* eslint-disable prefer-arrow/prefer-arrow-functions */\n/**\n * Convert a value to hex\n *\n * @param value\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function toHex(value) {\n    return Buffer.from(value).toString('hex');\n}\n/**\n * Get the hex hash of a value\n *\n * @param key\n */\nexport function getHexHash(key) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield sodium.ready;\n        return toHex(sodium.crypto_generichash(32, key));\n    });\n}\n/**\n * Get a keypair from a seed\n *\n * @param seed\n */\nexport function getKeypairFromSeed(seed) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield sodium.ready;\n        return sodium.crypto_sign_seed_keypair(sodium.crypto_generichash(32, sodium.from_string(seed)));\n    });\n}\n/**\n * Encrypt a message with a shared key\n *\n * @param message\n * @param sharedKey\n */\nexport function encryptCryptoboxPayload(message, sharedKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield sodium.ready;\n        const nonce = Buffer.from(sodium.randombytes_buf(sodium.crypto_secretbox_NONCEBYTES));\n        const combinedPayload = Buffer.concat([\n            nonce,\n            Buffer.from(sodium.crypto_secretbox_easy(Buffer.from(message, 'utf8'), nonce, sharedKey))\n        ]);\n        return toHex(combinedPayload);\n    });\n}\n/**\n * Decrypt a message with a shared key\n *\n * @param payload\n * @param sharedKey\n */\nexport function decryptCryptoboxPayload(payload, sharedKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield sodium.ready;\n        const nonce = payload.slice(0, sodium.crypto_secretbox_NONCEBYTES);\n        const ciphertext = payload.slice(sodium.crypto_secretbox_NONCEBYTES);\n        return Buffer.from(sodium.crypto_secretbox_open_easy(ciphertext, nonce, sharedKey)).toString('utf8');\n    });\n}\n/**\n * Encrypt a message with a public key\n *\n * @param payload\n * @param publicKey\n */\nexport function sealCryptobox(payload, publicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield sodium.ready;\n        const kxSelfPublicKey = sodium.crypto_sign_ed25519_pk_to_curve25519(Buffer.from(publicKey)); // Secret bytes to scalar bytes\n        const encryptedMessage = sodium.crypto_box_seal(payload, kxSelfPublicKey);\n        return toHex(encryptedMessage);\n    });\n}\n/**\n * Decrypt a message with public + private key\n *\n * @param encryptedPayload\n * @param publicKey\n * @param privateKey\n */\nexport function openCryptobox(encryptedPayload, publicKey, privateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield sodium.ready;\n        const kxSelfPrivateKey = sodium.crypto_sign_ed25519_sk_to_curve25519(Buffer.from(privateKey)); // Secret bytes to scalar bytes\n        const kxSelfPublicKey = sodium.crypto_sign_ed25519_pk_to_curve25519(Buffer.from(publicKey)); // Secret bytes to scalar bytes\n        const decryptedMessage = sodium.crypto_box_seal_open(encryptedPayload, kxSelfPublicKey, kxSelfPrivateKey);\n        return Buffer.from(decryptedMessage).toString();\n    });\n}\n/**\n * Get an address from the public key\n *\n * @param publicKey\n */\nexport function getAddressFromPublicKey(publicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield sodium.ready;\n        const prefixes = {\n            // tz1...\n            edpk: {\n                length: 54,\n                prefix: Buffer.from(new Uint8Array([6, 161, 159]))\n            },\n            // tz2...\n            sppk: {\n                length: 55,\n                prefix: Buffer.from(new Uint8Array([6, 161, 161]))\n            },\n            // tz3...\n            p2pk: {\n                length: 55,\n                prefix: Buffer.from(new Uint8Array([6, 161, 164]))\n            }\n        };\n        let prefix;\n        let plainPublicKey;\n        if (publicKey.length === 64) {\n            prefix = prefixes.edpk.prefix;\n            plainPublicKey = publicKey;\n        }\n        else {\n            const entries = Object.entries(prefixes);\n            for (let index = 0; index < entries.length; index++) {\n                const [key, value] = entries[index];\n                if (publicKey.startsWith(key) && publicKey.length === value.length) {\n                    prefix = value.prefix;\n                    const decoded = bs58check.decode(publicKey);\n                    plainPublicKey = decoded.slice(key.length, decoded.length).toString('hex');\n                    break;\n                }\n            }\n        }\n        if (!prefix || !plainPublicKey) {\n            throw new Error(`invalid publicKey: ${publicKey}`);\n        }\n        const payload = sodium.crypto_generichash(20, Buffer.from(plainPublicKey, 'hex'));\n        return bs58check.encode(Buffer.concat([prefix, Buffer.from(payload)]));\n    });\n}\n/**\n * Get the recipient string used in the matrix message\n *\n * @param recipientHash\n * @param relayServer\n */\nexport function recipientString(recipientHash, relayServer) {\n    return `@${recipientHash}:${relayServer}`;\n}\n/* eslint-enable prefer-arrow/prefer-arrow-functions */\n//# sourceMappingURL=crypto.js.map"]},"metadata":{},"sourceType":"module"}