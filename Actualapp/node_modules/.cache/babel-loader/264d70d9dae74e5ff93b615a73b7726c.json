{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { assertNever } from '../utils/assert-never';\nimport { BeaconMessageType } from '..';\nimport { Logger } from '../utils/Logger';\nconst logger = new Logger('IncomingRequestInterceptor');\n/**\n * @internalapi\n *\n * The IncomingRequestInterceptor is used in the WalletClient to intercept an incoming request and enrich it with data, like app metadata.\n */\n\nexport class IncomingRequestInterceptor {\n  /**\n   * The method that is called during the interception\n   *\n   * @param config\n   */\n  static intercept(config) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        message,\n        connectionInfo,\n        appMetadataManager,\n        interceptorCallback\n      } = config; // TODO: Remove v1 compatibility in later version\n\n      if (message.beaconId && !message.senderId) {\n        message.senderId = message.beaconId;\n        delete message.beaconId;\n      }\n\n      switch (message.type) {\n        case BeaconMessageType.PermissionRequest:\n          {\n            // TODO: Remove v1 compatibility in later version\n            if (message.appMetadata.beaconId && !message.appMetadata.senderId) {\n              message.appMetadata.senderId = message.appMetadata.beaconId;\n              delete message.appMetadata.beaconId;\n            }\n\n            yield appMetadataManager.addAppMetadata(message.appMetadata);\n            const request = message;\n            interceptorCallback(request, connectionInfo);\n          }\n          break;\n\n        case BeaconMessageType.OperationRequest:\n          {\n            const appMetadata = yield IncomingRequestInterceptor.getAppMetadata(appMetadataManager, message.senderId);\n            const request = Object.assign({\n              appMetadata\n            }, message);\n            interceptorCallback(request, connectionInfo);\n          }\n          break;\n\n        case BeaconMessageType.SignPayloadRequest:\n          {\n            const appMetadata = yield IncomingRequestInterceptor.getAppMetadata(appMetadataManager, message.senderId);\n            const request = Object.assign({\n              appMetadata\n            }, message);\n            interceptorCallback(request, connectionInfo);\n          }\n          break;\n        // TODO: ENCRYPTION\n        // case BeaconMessageType.EncryptPayloadRequest:\n        //   {\n        //     const appMetadata: AppMetadata = await IncomingRequestInterceptor.getAppMetadata(\n        //       appMetadataManager,\n        //       message.senderId\n        //     )\n        //     const request: EncryptPayloadRequestOutput = {\n        //       appMetadata,\n        //       ...message\n        //     }\n        //     interceptorCallback(request, connectionInfo)\n        //   }\n        //   break\n\n        case BeaconMessageType.BroadcastRequest:\n          {\n            const appMetadata = yield IncomingRequestInterceptor.getAppMetadata(appMetadataManager, message.senderId);\n            const request = Object.assign({\n              appMetadata\n            }, message);\n            interceptorCallback(request, connectionInfo);\n          }\n          break;\n\n        default:\n          logger.log('intercept', 'Message not handled');\n          assertNever(message);\n      }\n    });\n  }\n\n  static getAppMetadata(appMetadataManager, senderId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const appMetadata = yield appMetadataManager.getAppMetadata(senderId);\n\n      if (!appMetadata) {\n        throw new Error('AppMetadata not found');\n      }\n\n      return appMetadata;\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/interceptors/IncomingRequestInterceptor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { assertNever } from '../utils/assert-never';\nimport { BeaconMessageType } from '..';\nimport { Logger } from '../utils/Logger';\nconst logger = new Logger('IncomingRequestInterceptor');\n/**\n * @internalapi\n *\n * The IncomingRequestInterceptor is used in the WalletClient to intercept an incoming request and enrich it with data, like app metadata.\n */\nexport class IncomingRequestInterceptor {\n    /**\n     * The method that is called during the interception\n     *\n     * @param config\n     */\n    static intercept(config) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { message, connectionInfo, appMetadataManager, interceptorCallback } = config;\n            // TODO: Remove v1 compatibility in later version\n            if (message.beaconId && !message.senderId) {\n                message.senderId = message.beaconId;\n                delete message.beaconId;\n            }\n            switch (message.type) {\n                case BeaconMessageType.PermissionRequest:\n                    {\n                        // TODO: Remove v1 compatibility in later version\n                        if (message.appMetadata.beaconId && !message.appMetadata.senderId) {\n                            message.appMetadata.senderId = message.appMetadata.beaconId;\n                            delete message.appMetadata.beaconId;\n                        }\n                        yield appMetadataManager.addAppMetadata(message.appMetadata);\n                        const request = message;\n                        interceptorCallback(request, connectionInfo);\n                    }\n                    break;\n                case BeaconMessageType.OperationRequest:\n                    {\n                        const appMetadata = yield IncomingRequestInterceptor.getAppMetadata(appMetadataManager, message.senderId);\n                        const request = Object.assign({ appMetadata }, message);\n                        interceptorCallback(request, connectionInfo);\n                    }\n                    break;\n                case BeaconMessageType.SignPayloadRequest:\n                    {\n                        const appMetadata = yield IncomingRequestInterceptor.getAppMetadata(appMetadataManager, message.senderId);\n                        const request = Object.assign({ appMetadata }, message);\n                        interceptorCallback(request, connectionInfo);\n                    }\n                    break;\n                // TODO: ENCRYPTION\n                // case BeaconMessageType.EncryptPayloadRequest:\n                //   {\n                //     const appMetadata: AppMetadata = await IncomingRequestInterceptor.getAppMetadata(\n                //       appMetadataManager,\n                //       message.senderId\n                //     )\n                //     const request: EncryptPayloadRequestOutput = {\n                //       appMetadata,\n                //       ...message\n                //     }\n                //     interceptorCallback(request, connectionInfo)\n                //   }\n                //   break\n                case BeaconMessageType.BroadcastRequest:\n                    {\n                        const appMetadata = yield IncomingRequestInterceptor.getAppMetadata(appMetadataManager, message.senderId);\n                        const request = Object.assign({ appMetadata }, message);\n                        interceptorCallback(request, connectionInfo);\n                    }\n                    break;\n                default:\n                    logger.log('intercept', 'Message not handled');\n                    assertNever(message);\n            }\n        });\n    }\n    static getAppMetadata(appMetadataManager, senderId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const appMetadata = yield appMetadataManager.getAppMetadata(senderId);\n            if (!appMetadata) {\n                throw new Error('AppMetadata not found');\n            }\n            return appMetadata;\n        });\n    }\n}\n//# sourceMappingURL=IncomingRequestInterceptor.js.map"]},"metadata":{},"sourceType":"module"}