{"ast":null,"code":"import { OpKind, RpcClient } from '@taquito/rpc';\nexport { OpKind } from '@taquito/rpc';\nimport { combineLatest, ReplaySubject, from, defer, timer, throwError, of, range, concat, Subject, NEVER, Observable } from 'rxjs';\nimport { distinctUntilChanged, map, takeWhile, tap, shareReplay, filter, first, switchMap, distinctUntilKeyChanged, timeoutWith, startWith, concatMap, mapTo, switchMapTo, retry, takeUntil, catchError, pluck, publishReplay, refCount } from 'rxjs/operators';\nimport BigNumber from 'bignumber.js';\nimport { Schema, ParameterSchema, MichelsonMap } from '@taquito/michelson-encoder';\nexport { MichelsonMap, UnitValue } from '@taquito/michelson-encoder';\nimport { HttpResponseError, STATUS_CODE } from '@taquito/http-utils';\nimport { encodeExpr } from '@taquito/utils';\nimport { Parser, packDataBytes } from '@taquito/michel-codec';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\n\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n\nfunction __spreadArray(to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n}\n\nvar RpcForger =\n/** @class */\nfunction () {\n  function RpcForger(context) {\n    this.context = context;\n  }\n\n  RpcForger.prototype.forge = function (_a) {\n    var branch = _a.branch,\n        contents = _a.contents;\n    return this.context.rpc.forgeOperations({\n      branch: branch,\n      contents: contents\n    });\n  };\n\n  return RpcForger;\n}();\n\nvar RpcInjector =\n/** @class */\nfunction () {\n  function RpcInjector(context) {\n    this.context = context;\n  }\n\n  RpcInjector.prototype.inject = function (signedOperationBytes) {\n    return this.context.rpc.injectOperation(signedOperationBytes);\n  };\n\n  return RpcInjector;\n}();\n\nvar UnconfiguredSignerError =\n/** @class */\nfunction () {\n  function UnconfiguredSignerError() {\n    this.name = 'UnconfiguredSignerError';\n    this.message = 'No signer has been configured. Please configure one by calling setProvider({signer}) on your TezosToolkit instance.';\n  }\n\n  return UnconfiguredSignerError;\n}();\n/**\r\n * @description Default signer implementation which does nothing and produce invalid signature\r\n */\n\n\nvar NoopSigner =\n/** @class */\nfunction () {\n  function NoopSigner() {}\n\n  NoopSigner.prototype.publicKey = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        throw new UnconfiguredSignerError();\n      });\n    });\n  };\n\n  NoopSigner.prototype.publicKeyHash = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        throw new UnconfiguredSignerError();\n      });\n    });\n  };\n\n  NoopSigner.prototype.secretKey = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        throw new UnconfiguredSignerError();\n      });\n    });\n  };\n\n  NoopSigner.prototype.sign = function (_bytes, _watermark) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        throw new UnconfiguredSignerError();\n      });\n    });\n  };\n\n  return NoopSigner;\n}();\n\nvar attachKind = function (op, kind) {\n  return __assign(__assign({}, op), {\n    kind: kind\n  });\n};\n\nvar findWithKind = function (arr, kind) {\n  if (Array.isArray(arr)) {\n    var found = arr.find(function (op) {\n      return op.kind === kind;\n    });\n\n    if (found && isKind(found, kind)) {\n      return found;\n    }\n  }\n};\n\nvar isKind = function (op, kind) {\n  return op.kind === kind;\n};\n\nvar isOpWithFee = function (op) {\n  return ['transaction', 'delegation', 'origination', 'reveal'].indexOf(op.kind) !== -1;\n};\n\nvar isOpRequireReveal = function (op) {\n  return ['transaction', 'delegation', 'origination'].indexOf(op.kind) !== -1;\n};\n\nvar hasMetadata = function (op) {\n  return 'metadata' in op;\n};\n\nvar hasMetadataWithResult = function (op) {\n  return hasMetadata(op) && 'operation_result' in op.metadata;\n};\n\nvar hasMetadataWithInternalOperationResult = function (op) {\n  return hasMetadata(op) && 'internal_operation_results' in op.metadata;\n};\n\nvar isErrorWithMessage = function (error) {\n  return 'with' in error;\n};\n\nvar TezosOperationError =\n/** @class */\nfunction () {\n  function TezosOperationError(errors) {\n    this.errors = errors;\n    this.name = 'TezosOperationError'; // Last error is 'often' the one with more detail\n\n    var lastError = errors[errors.length - 1];\n    this.id = lastError.id;\n    this.kind = lastError.kind;\n    this.message = \"(\" + this.kind + \") \" + this.id;\n\n    if (isErrorWithMessage(lastError) && lastError.with.string) {\n      this.message = lastError.with.string;\n    }\n  }\n\n  return TezosOperationError;\n}();\n\nvar TezosPreapplyFailureError =\n/** @class */\nfunction () {\n  function TezosPreapplyFailureError(result) {\n    this.result = result;\n    this.name = 'TezosPreapplyFailureError';\n    this.message = 'Preapply returned an unexpected result';\n  }\n\n  return TezosPreapplyFailureError;\n}(); // Flatten all operation content results and internal operation results into a single array\n// Some cases where we can have multiple operation results or internal operation results are:\n// - When an operation includes a reveal operation\n// - When an operation is made using the batch API\n// - Smart contract call can contains internal operation results when they call other smart contract internally or originate contracts\n\n\nvar flattenOperationResult = function (response) {\n  var results = Array.isArray(response) ? response : [response];\n  var returnedResults = [];\n\n  for (var i = 0; i < results.length; i++) {\n    for (var j = 0; j < results[i].contents.length; j++) {\n      var content = results[i].contents[j];\n\n      if (hasMetadataWithResult(content)) {\n        returnedResults.push(__assign({\n          fee: content.fee\n        }, content.metadata.operation_result));\n\n        if (Array.isArray(content.metadata.internal_operation_results)) {\n          content.metadata.internal_operation_results.forEach(function (x) {\n            return returnedResults.push(x.result);\n          });\n        }\n      }\n    }\n  }\n\n  return returnedResults;\n};\n/***\r\n * @description Flatten all error from preapply response (including internal error)\r\n */\n\n\nvar flattenErrors = function (response, status) {\n  var e_1, _a;\n\n  if (status === void 0) {\n    status = 'failed';\n  }\n\n  var results = Array.isArray(response) ? response : [response];\n  var errors = []; // Transaction that do not fail will be backtracked in case one failure occur\n\n  for (var i = 0; i < results.length; i++) {\n    for (var j = 0; j < results[i].contents.length; j++) {\n      var content = results[i].contents[j];\n\n      if (hasMetadata(content)) {\n        if (hasMetadataWithResult(content) && content.metadata.operation_result.status === status) {\n          errors = errors.concat(content.metadata.operation_result.errors || []);\n        }\n\n        if (hasMetadataWithInternalOperationResult(content) && Array.isArray(content.metadata.internal_operation_results)) {\n          try {\n            for (var _b = (e_1 = void 0, __values(content.metadata.internal_operation_results)), _c = _b.next(); !_c.done; _c = _b.next()) {\n              var internalResult = _c.value;\n\n              if ('result' in internalResult && internalResult.result.status === status) {\n                errors = errors.concat(internalResult.result.errors || []);\n              }\n            }\n          } catch (e_1_1) {\n            e_1 = {\n              error: e_1_1\n            };\n          } finally {\n            try {\n              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return errors;\n};\n\nvar receiptFromOperation = function (op, _a) {\n  var _b = _a === void 0 ? {\n    ALLOCATION_BURN: 257,\n    ORIGINATION_BURN: 257\n  } : _a,\n      ALLOCATION_BURN = _b.ALLOCATION_BURN,\n      ORIGINATION_BURN = _b.ORIGINATION_BURN;\n\n  var operationResults = flattenOperationResult({\n    contents: op\n  });\n  var totalGas = new BigNumber(0);\n  var totalStorage = new BigNumber(0);\n  var totalFee = new BigNumber(0);\n  var totalOriginationBurn = new BigNumber(0);\n  var totalAllocationBurn = new BigNumber(0);\n  var totalPaidStorageDiff = new BigNumber(0);\n  operationResults.forEach(function (result) {\n    totalFee = totalFee.plus(result.fee || 0);\n    totalOriginationBurn = totalOriginationBurn.plus(Array.isArray(result.originated_contracts) ? result.originated_contracts.length * ORIGINATION_BURN : 0);\n    totalAllocationBurn = totalAllocationBurn.plus('allocated_destination_contract' in result ? ALLOCATION_BURN : 0);\n    totalGas = totalGas.plus(result.consumed_gas || 0);\n    totalPaidStorageDiff = totalPaidStorageDiff.plus('paid_storage_size_diff' in result ? Number(result.paid_storage_size_diff) || 0 : 0);\n  });\n  totalStorage = totalStorage.plus(totalAllocationBurn).plus(totalOriginationBurn).plus(totalPaidStorageDiff);\n  return {\n    totalFee: totalFee,\n    totalGas: totalGas,\n    totalStorage: totalStorage,\n    totalAllocationBurn: totalAllocationBurn,\n    totalOriginationBurn: totalOriginationBurn,\n    totalPaidStorageDiff: totalPaidStorageDiff,\n    totalStorageBurn: new BigNumber(totalStorage.multipliedBy(1000))\n  };\n};\n\nvar MissedBlockDuringConfirmationError =\n/** @class */\nfunction () {\n  function MissedBlockDuringConfirmationError() {\n    this.name = 'MissedBlockDuringConfirmationError';\n    this.message = 'Taquito missed a block while waiting for operation confirmation and was not able to find the operation';\n  }\n\n  return MissedBlockDuringConfirmationError;\n}();\n\nvar MAX_BRANCH_ANCESTORS = 60;\n/**\r\n * @description WalletOperation allows to monitor operation inclusion on chains and surface information related to the operation\r\n */\n\nvar WalletOperation =\n/** @class */\nfunction () {\n  /**\r\n   *\r\n   * @param opHash Operation hash\r\n   * @param raw Raw operation that was injected\r\n   * @param context Taquito context allowing access to rpc and signer\r\n   */\n  function WalletOperation(opHash, context, _newHead$) {\n    var _this = this;\n\n    this.opHash = opHash;\n    this.context = context;\n    this._newHead$ = _newHead$;\n    this._operationResult = new ReplaySubject(1);\n    this._includedInBlock = new ReplaySubject(1);\n    this._included = false;\n    this.newHead$ = this._newHead$.pipe(tap(function (newHead) {\n      if (!_this._included && _this.lastHead && newHead.header.level - _this.lastHead.header.level > 1) {\n        throw new MissedBlockDuringConfirmationError();\n      }\n\n      _this.lastHead = newHead;\n    }), shareReplay({\n      bufferSize: 1,\n      refCount: true\n    })); // Observable that emit once operation is seen in a block\n\n    this.confirmed$ = this.newHead$.pipe(map(function (head) {\n      var e_1, _a, e_2, _b;\n\n      try {\n        for (var _c = __values(head.operations), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var opGroup = _d.value;\n\n          try {\n            for (var opGroup_1 = (e_2 = void 0, __values(opGroup)), opGroup_1_1 = opGroup_1.next(); !opGroup_1_1.done; opGroup_1_1 = opGroup_1.next()) {\n              var op = opGroup_1_1.value;\n\n              if (op.hash === _this.opHash) {\n                _this._included = true;\n\n                _this._includedInBlock.next(head);\n\n                _this._operationResult.next(op.contents); // Return the block where the operation was found\n\n\n                return head;\n              }\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (opGroup_1_1 && !opGroup_1_1.done && (_b = opGroup_1.return)) _b.call(opGroup_1);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }), filter(function (x) {\n      return typeof x !== 'undefined';\n    }), first(), shareReplay({\n      bufferSize: 1,\n      refCount: true\n    }));\n    this.confirmed$.pipe(first()).subscribe();\n  }\n\n  WalletOperation.prototype.operationResults = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this._operationResult.pipe(first()).toPromise()];\n      });\n    });\n  };\n  /**\r\n   * @description Receipt expose the total amount of tezos token burn and spent on fees\r\n   * The promise returned by receipt will resolve only once the transaction is included\r\n   */\n\n\n  WalletOperation.prototype.receipt = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = receiptFromOperation;\n            return [4\n            /*yield*/\n            , this.operationResults()];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.apply(void 0, [_b.sent()])];\n        }\n      });\n    });\n  };\n\n  WalletOperation.prototype.getCurrentConfirmation = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        if (!this._included) {\n          return [2\n          /*return*/\n          , 0];\n        }\n\n        return [2\n        /*return*/\n        , combineLatest([this._includedInBlock, from(this.context.rpc.getBlock())]).pipe(map(function (_a) {\n          var _b = __read(_a, 2),\n              foundAtBlock = _b[0],\n              head = _b[1];\n\n          return head.header.level - foundAtBlock.header.level + 1;\n        }), first()).toPromise()];\n      });\n    });\n  };\n\n  WalletOperation.prototype.isInCurrentBranch = function (tipBlockIdentifier) {\n    if (tipBlockIdentifier === void 0) {\n      tipBlockIdentifier = 'head';\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var tipBlockHeader, inclusionBlock, levelDiff, tipBlockLevel, blocks, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            // By default it is assumed that the operation is in the current branch\n            if (!this._included) {\n              return [2\n              /*return*/\n              , true];\n            }\n\n            return [4\n            /*yield*/\n            , this.context.rpc.getBlockHeader({\n              block: tipBlockIdentifier\n            })];\n\n          case 1:\n            tipBlockHeader = _b.sent();\n            return [4\n            /*yield*/\n            , this._includedInBlock.pipe(first()).toPromise()];\n\n          case 2:\n            inclusionBlock = _b.sent();\n            levelDiff = tipBlockHeader.level - inclusionBlock.header.level; // Block produced before the operation is included are assumed to be part of the current branch\n\n            if (levelDiff <= 0) {\n              return [2\n              /*return*/\n              , true];\n            }\n\n            tipBlockLevel = Math.min(inclusionBlock.header.level + levelDiff, inclusionBlock.header.level + MAX_BRANCH_ANCESTORS);\n            _a = Set.bind;\n            return [4\n            /*yield*/\n            , this.context.rpc.getLiveBlocks({\n              block: String(tipBlockLevel)\n            })];\n\n          case 3:\n            blocks = new (_a.apply(Set, [void 0, _b.sent()]))();\n            return [2\n            /*return*/\n            , blocks.has(inclusionBlock.hash)];\n        }\n      });\n    });\n  };\n\n  WalletOperation.prototype.confirmationObservable = function (confirmations) {\n    var _this = this;\n\n    if (typeof confirmations !== 'undefined' && confirmations < 1) {\n      throw new Error('Confirmation count must be at least 1');\n    }\n\n    var defaultConfirmationCount = this.context.config.defaultConfirmationCount;\n    var conf = confirmations !== undefined ? confirmations : defaultConfirmationCount;\n\n    if (conf === undefined) {\n      throw new Error('Default confirmation count can not be undefined!');\n    }\n\n    return combineLatest([this._includedInBlock, this.newHead$]).pipe(distinctUntilChanged(function (_a, _b) {\n      var _c = __read(_a, 2),\n          previousHead = _c[1];\n\n      var _d = __read(_b, 2),\n          newHead = _d[1];\n\n      return previousHead.hash === newHead.hash;\n    }), map(function (_a) {\n      var _b = __read(_a, 2),\n          foundAtBlock = _b[0],\n          head = _b[1];\n\n      return {\n        block: head,\n        expectedConfirmation: conf,\n        currentConfirmation: head.header.level - foundAtBlock.header.level + 1,\n        completed: head.header.level - foundAtBlock.header.level >= conf - 1,\n        isInCurrentBranch: function () {\n          return _this.isInCurrentBranch(head.hash);\n        }\n      };\n    }), takeWhile(function (_a) {\n      var completed = _a.completed;\n      return !completed;\n    }, true));\n  };\n  /**\r\n   *\r\n   * @param confirmations [0] Number of confirmation to wait for\r\n   */\n\n\n  WalletOperation.prototype.confirmation = function (confirmations) {\n    return this.confirmationObservable(confirmations).toPromise();\n  };\n\n  return WalletOperation;\n}();\n\nvar DelegationWalletOperation =\n/** @class */\nfunction (_super) {\n  __extends(DelegationWalletOperation, _super);\n\n  function DelegationWalletOperation(opHash, context, newHead$) {\n    var _this = _super.call(this, opHash, context, newHead$) || this;\n\n    _this.opHash = opHash;\n    _this.context = context;\n    return _this;\n  }\n\n  DelegationWalletOperation.prototype.revealOperation = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var operationResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.operationResults()];\n\n          case 1:\n            operationResult = _a.sent();\n            return [2\n            /*return*/\n            , operationResult.find(function (x) {\n              return x.kind === OpKind.REVEAL;\n            })];\n        }\n      });\n    });\n  };\n\n  DelegationWalletOperation.prototype.delegationOperation = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var operationResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.operationResults()];\n\n          case 1:\n            operationResult = _a.sent();\n            return [2\n            /*return*/\n            , operationResult.find(function (x) {\n              return x.kind === OpKind.DELEGATION;\n            })];\n        }\n      });\n    });\n  };\n\n  DelegationWalletOperation.prototype.status = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var op;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this._included) {\n              return [2\n              /*return*/\n              , 'pending'];\n            }\n\n            return [4\n            /*yield*/\n            , this.delegationOperation()];\n\n          case 1:\n            op = _a.sent();\n\n            if (!op) {\n              return [2\n              /*return*/\n              , 'unknown'];\n            }\n\n            return [2\n            /*return*/\n            , op.metadata.operation_result.status];\n        }\n      });\n    });\n  };\n\n  return DelegationWalletOperation;\n}(WalletOperation);\n\nvar OriginationWalletOperation =\n/** @class */\nfunction (_super) {\n  __extends(OriginationWalletOperation, _super);\n\n  function OriginationWalletOperation(opHash, context, newHead$) {\n    var _this = _super.call(this, opHash, context, newHead$) || this;\n\n    _this.opHash = opHash;\n    _this.context = context;\n    return _this;\n  }\n\n  OriginationWalletOperation.prototype.originationOperation = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var operationResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.operationResults()];\n\n          case 1:\n            operationResult = _a.sent();\n            return [2\n            /*return*/\n            , findWithKind(operationResult, OpKind.ORIGINATION)];\n        }\n      });\n    });\n  };\n\n  OriginationWalletOperation.prototype.revealOperation = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var operationResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.operationResults()];\n\n          case 1:\n            operationResult = _a.sent();\n            return [2\n            /*return*/\n            , findWithKind(operationResult, OpKind.REVEAL)];\n        }\n      });\n    });\n  };\n\n  OriginationWalletOperation.prototype.status = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var op;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this._included) {\n              return [2\n              /*return*/\n              , 'pending'];\n            }\n\n            return [4\n            /*yield*/\n            , this.originationOperation()];\n\n          case 1:\n            op = _a.sent();\n\n            if (!op) {\n              return [2\n              /*return*/\n              , 'unknown'];\n            }\n\n            return [2\n            /*return*/\n            , op.metadata.operation_result.status];\n        }\n      });\n    });\n  };\n\n  OriginationWalletOperation.prototype.contract = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var op, address;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.originationOperation()];\n\n          case 1:\n            op = _a.sent();\n            address = (op.metadata.operation_result.originated_contracts || [])[0];\n            return [2\n            /*return*/\n            , this.context.wallet.at(address)];\n        }\n      });\n    });\n  };\n\n  return OriginationWalletOperation;\n}(WalletOperation);\n\nvar TransactionWalletOperation =\n/** @class */\nfunction (_super) {\n  __extends(TransactionWalletOperation, _super);\n\n  function TransactionWalletOperation(opHash, context, newHead$) {\n    var _this = _super.call(this, opHash, context, newHead$) || this;\n\n    _this.opHash = opHash;\n    _this.context = context;\n    return _this;\n  }\n\n  TransactionWalletOperation.prototype.revealOperation = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var operationResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.operationResults()];\n\n          case 1:\n            operationResult = _a.sent();\n            return [2\n            /*return*/\n            , operationResult.find(function (x) {\n              return x.kind === OpKind.REVEAL;\n            })];\n        }\n      });\n    });\n  };\n\n  TransactionWalletOperation.prototype.transactionOperation = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var operationResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.operationResults()];\n\n          case 1:\n            operationResult = _a.sent();\n            return [2\n            /*return*/\n            , operationResult.find(function (x) {\n              return x.kind === OpKind.TRANSACTION;\n            })];\n        }\n      });\n    });\n  };\n\n  TransactionWalletOperation.prototype.status = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var op;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this._included) {\n              return [2\n              /*return*/\n              , 'pending'];\n            }\n\n            return [4\n            /*yield*/\n            , this.transactionOperation()];\n\n          case 1:\n            op = _a.sent();\n\n            if (!op) {\n              return [2\n              /*return*/\n              , 'unknown'];\n            }\n\n            return [2\n            /*return*/\n            , op.metadata.operation_result.status];\n        }\n      });\n    });\n  };\n\n  return TransactionWalletOperation;\n}(WalletOperation);\n\nvar cacheUntil = function (cacheUntilObs) {\n  return function (source) {\n    var subject = null;\n    return defer(function () {\n      if (!subject) {\n        subject = new ReplaySubject();\n        source.pipe(first()).subscribe(subject);\n        cacheUntilObs.pipe(first()).subscribe(function () {\n          subject = null;\n        });\n      }\n\n      return subject;\n    });\n  };\n};\n\nvar createNewPollingBasedHeadObservable = function (pollingTimer, sharedHeadOb, context, scheduler) {\n  if (context.config.confirmationPollingTimeoutSecond === undefined) {\n    throw new Error('Confirmation polling timeout second can not be undefined!');\n  }\n\n  return pollingTimer.pipe(switchMap(function () {\n    return sharedHeadOb;\n  }), distinctUntilKeyChanged('hash'), timeoutWith(context.config.confirmationPollingTimeoutSecond * 1000, throwError(new Error('Confirmation polling timed out')), scheduler), shareReplay({\n    refCount: true,\n    scheduler: scheduler\n  }));\n};\n\nvar OperationFactory =\n/** @class */\nfunction () {\n  function OperationFactory(context) {\n    var _this = this;\n\n    this.context = context; // Cache the last block for one second across all operations\n\n    this.sharedHeadObs = defer(function () {\n      return from(_this.context.rpc.getBlock());\n    }).pipe(cacheUntil(timer(0, 1000)));\n  }\n\n  OperationFactory.prototype.createNewHeadObservable = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var confirmationPollingIntervalSecond, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(this.context.config.confirmationPollingIntervalSecond !== undefined)) return [3\n            /*break*/\n            , 1];\n            _a = this.context.config.confirmationPollingIntervalSecond;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.context.getConfirmationPollingInterval()];\n\n          case 2:\n            _a = _b.sent();\n            _b.label = 3;\n\n          case 3:\n            confirmationPollingIntervalSecond = _a;\n            return [2\n            /*return*/\n            , createNewPollingBasedHeadObservable(timer(0, confirmationPollingIntervalSecond * 1000), this.sharedHeadObs, this.context)];\n        }\n      });\n    });\n  };\n\n  OperationFactory.prototype.createPastBlockWalker = function (startBlock, count) {\n    var _this = this;\n\n    if (count === void 0) {\n      count = 1;\n    }\n\n    return from(this.context.rpc.getBlock({\n      block: startBlock\n    })).pipe(switchMap(function (block) {\n      if (count === 1) {\n        return of(block);\n      }\n\n      return range(block.header.level, count - 1).pipe(startWith(block), concatMap(function (level) {\n        return __awaiter(_this, void 0, void 0, function () {\n          return __generator(this, function (_a) {\n            return [2\n            /*return*/\n            , this.context.rpc.getBlock({\n              block: String(level)\n            })];\n          });\n        });\n      }));\n    }));\n  };\n\n  OperationFactory.prototype.createHeadObservableFromConfig = function (_a) {\n    var blockIdentifier = _a.blockIdentifier;\n    return __awaiter(this, void 0, void 0, function () {\n      var observableSequence, _b, _c;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            observableSequence = [];\n\n            if (blockIdentifier) {\n              observableSequence.push(this.createPastBlockWalker(blockIdentifier));\n            }\n\n            _c = (_b = observableSequence).push;\n            return [4\n            /*yield*/\n            , this.createNewHeadObservable()];\n\n          case 1:\n            _c.apply(_b, [_d.sent()]);\n\n            return [2\n            /*return*/\n            , concat.apply(void 0, __spreadArray([], __read(observableSequence)))];\n        }\n      });\n    });\n  };\n\n  OperationFactory.prototype.createOperation = function (hash, config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, _b;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _a = WalletOperation.bind;\n            _b = [void 0, hash, this.context.clone()];\n            return [4\n            /*yield*/\n            , this.createHeadObservableFromConfig(config)];\n\n          case 1:\n            return [2\n            /*return*/\n            , new (_a.apply(WalletOperation, _b.concat([_c.sent()])))()];\n        }\n      });\n    });\n  };\n\n  OperationFactory.prototype.createTransactionOperation = function (hash, config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, _b;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _a = TransactionWalletOperation.bind;\n            _b = [void 0, hash, this.context.clone()];\n            return [4\n            /*yield*/\n            , this.createHeadObservableFromConfig(config)];\n\n          case 1:\n            return [2\n            /*return*/\n            , new (_a.apply(TransactionWalletOperation, _b.concat([_c.sent()])))()];\n        }\n      });\n    });\n  };\n\n  OperationFactory.prototype.createDelegationOperation = function (hash, config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, _b;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _a = DelegationWalletOperation.bind;\n            _b = [void 0, hash, this.context.clone()];\n            return [4\n            /*yield*/\n            , this.createHeadObservableFromConfig(config)];\n\n          case 1:\n            return [2\n            /*return*/\n            , new (_a.apply(DelegationWalletOperation, _b.concat([_c.sent()])))()];\n        }\n      });\n    });\n  };\n\n  OperationFactory.prototype.createOriginationOperation = function (hash, config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, _b;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _a = OriginationWalletOperation.bind;\n            _b = [void 0, hash, this.context.clone()];\n            return [4\n            /*yield*/\n            , this.createHeadObservableFromConfig(config)];\n\n          case 1:\n            return [2\n            /*return*/\n            , new (_a.apply(OriginationWalletOperation, _b.concat([_c.sent()])))()];\n        }\n      });\n    });\n  };\n\n  return OperationFactory;\n}();\n\nvar DEFAULT_GAS_LIMIT;\n\n(function (DEFAULT_GAS_LIMIT) {\n  DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT[\"DELEGATION\"] = 10600] = \"DELEGATION\";\n  DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT[\"ORIGINATION\"] = 10600] = \"ORIGINATION\";\n  DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT[\"TRANSFER\"] = 10600] = \"TRANSFER\";\n  DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT[\"REVEAL\"] = 10600] = \"REVEAL\";\n})(DEFAULT_GAS_LIMIT || (DEFAULT_GAS_LIMIT = {}));\n\nvar DEFAULT_FEE;\n\n(function (DEFAULT_FEE) {\n  DEFAULT_FEE[DEFAULT_FEE[\"DELEGATION\"] = 1257] = \"DELEGATION\";\n  DEFAULT_FEE[DEFAULT_FEE[\"ORIGINATION\"] = 10000] = \"ORIGINATION\";\n  DEFAULT_FEE[DEFAULT_FEE[\"TRANSFER\"] = 10000] = \"TRANSFER\";\n  DEFAULT_FEE[DEFAULT_FEE[\"REVEAL\"] = 1420] = \"REVEAL\";\n})(DEFAULT_FEE || (DEFAULT_FEE = {}));\n\nvar DEFAULT_STORAGE_LIMIT;\n\n(function (DEFAULT_STORAGE_LIMIT) {\n  DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT[\"DELEGATION\"] = 0] = \"DELEGATION\";\n  DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT[\"ORIGINATION\"] = 257] = \"ORIGINATION\";\n  DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT[\"TRANSFER\"] = 257] = \"TRANSFER\";\n  DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT[\"REVEAL\"] = 0] = \"REVEAL\";\n})(DEFAULT_STORAGE_LIMIT || (DEFAULT_STORAGE_LIMIT = {}));\n\nvar Protocols;\n\n(function (Protocols) {\n  Protocols[\"Pt24m4xi\"] = \"Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd\";\n  Protocols[\"PsBABY5H\"] = \"PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU\";\n  Protocols[\"PsBabyM1\"] = \"PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS\";\n  Protocols[\"PsCARTHA\"] = \"PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb\";\n  Protocols[\"PsDELPH1\"] = \"PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo\";\n  Protocols[\"PtEdo2Zk\"] = \"PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA\";\n  Protocols[\"PsFLorena\"] = \"PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i\";\n  Protocols[\"PtGRANADs\"] = \"PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV\";\n})(Protocols || (Protocols = {}));\n\nvar protocols = {\n  '004': [Protocols.Pt24m4xi],\n  '005': [Protocols.PsBABY5H, Protocols.PsBabyM1],\n  '006': [Protocols.PsCARTHA],\n  '007': [Protocols.PsDELPH1],\n  '008': [Protocols.PtEdo2Zk],\n  '009': [Protocols.PsFLorena],\n  '010': [Protocols.PtGRANADs]\n};\nvar DefaultLambdaAddresses;\n\n(function (DefaultLambdaAddresses) {\n  DefaultLambdaAddresses[\"MAINNET\"] = \"KT1CPuTzwC7h7uLXd5WQmpMFso1HxrLBUtpE\";\n  DefaultLambdaAddresses[\"CARTHAGENET\"] = \"KT1VAy1o1FGiXYfD3YT7x7k5eF5HSHhmc1u6\";\n  DefaultLambdaAddresses[\"DELPHINET\"] = \"KT19abMFs3haqyKYwqdLjK9GbtofryZLvpiK\";\n  DefaultLambdaAddresses[\"EDONET\"] = \"KT1A64nVZDccAHGAsf1ZyVajXZcbiwjV3SnN\";\n  DefaultLambdaAddresses[\"FLORENCENET\"] = \"KT1KCe3YqGnudsiCWb5twbe2DH5T3EMdLpSE\";\n  DefaultLambdaAddresses[\"GRANADANET\"] = \"KT1BCun2vsA4GBQvsKAuGD5x873MfW2jsN9z\";\n})(DefaultLambdaAddresses || (DefaultLambdaAddresses = {}));\n\nvar ChainIds;\n\n(function (ChainIds) {\n  ChainIds[\"MAINNET\"] = \"NetXdQprcVkpaWU\";\n  ChainIds[\"CARTHAGENET\"] = \"NetXjD3HPJJjmcd\";\n  ChainIds[\"DELPHINET\"] = \"NetXm8tYqnMWky1\";\n  ChainIds[\"EDONET\"] = \"NetXSgo1ZT2DRUG\";\n  ChainIds[\"FLORENCENET\"] = \"NetXxkAx4woPLyu\";\n  ChainIds[\"GRANADANET\"] = \"NetXz969SFaFn8k\";\n})(ChainIds || (ChainIds = {})); // RPC requires a signature but does not verify it\n\n\nvar SIGNATURE_STUB = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg';\n\nvar OperationEmitter =\n/** @class */\nfunction () {\n  function OperationEmitter(context) {\n    var _this = this;\n\n    this.context = context;\n\n    this.constructOps = function (cOps, publicKeyHash, headCounter, counterFunction, source) {\n      var counters = {}; // tslint:disable strict-type-predicates\n\n      return cOps.map(function (op) {\n        switch (op.kind) {\n          case OpKind.ACTIVATION:\n            return __assign({}, op);\n\n          case OpKind.REVEAL:\n            return __assign(__assign(__assign(__assign({}, op), _this.getSource(op, publicKeyHash, source)), counterFunction(publicKeyHash, headCounter, counters)), _this.getFee(op));\n\n          case OpKind.ORIGINATION:\n            return __assign(__assign(__assign(__assign(__assign({}, op), {\n              balance: typeof op.balance !== 'undefined' ? \"\" + op.balance : '0'\n            }), _this.getSource(op, publicKeyHash, source)), counterFunction(publicKeyHash, headCounter, counters)), _this.getFee(op));\n\n          case OpKind.TRANSACTION:\n            var cops = __assign(__assign(__assign(__assign(__assign({}, op), {\n              amount: typeof op.amount !== 'undefined' ? \"\" + op.amount : '0'\n            }), _this.getSource(op, publicKeyHash, source)), counterFunction(publicKeyHash, headCounter, counters)), _this.getFee(op));\n\n            if (cops.source.toLowerCase().startsWith('kt1')) {\n              throw new Error(\"KT1 addresses are not supported as source since \" + Protocols.PsBabyM1);\n            }\n\n            return cops;\n\n          case OpKind.DELEGATION:\n            return __assign(__assign(__assign(__assign({}, op), _this.getSource(op, publicKeyHash, source)), counterFunction(publicKeyHash, headCounter, counters)), _this.getFee(op));\n\n          default:\n            throw new Error('Unsupported operation');\n        }\n      });\n    };\n\n    this.getFee = function (op) {\n      return {\n        // tslint:disable-next-line: strict-type-predicates\n        fee: typeof op.fee === 'undefined' ? '0' : \"\" + op.fee,\n        // tslint:disable-next-line: strict-type-predicates\n        gas_limit: typeof op.gas_limit === 'undefined' ? '0' : \"\" + op.gas_limit,\n        // tslint:disable-next-line: strict-type-predicates\n        storage_limit: typeof op.storage_limit === 'undefined' ? '0' : \"\" + op.storage_limit\n      };\n    };\n\n    this.getSource = function (op, publicKeyHash, source) {\n      return {\n        source: typeof op.source === 'undefined' ? source || publicKeyHash : op.source\n      };\n    };\n\n    this.getContextCounter = function (publicKeyHash, headCounter) {\n      if (!_this.context.counters[publicKeyHash] || _this.context.counters[publicKeyHash] < headCounter) {\n        _this.context.counters[publicKeyHash] = headCounter;\n      }\n\n      var opCounter = ++_this.context.counters[publicKeyHash];\n      return {\n        counter: \"\" + opCounter\n      };\n    };\n\n    this.getScopeCounter = function (publicKeyHash, headCounter, countersScope) {\n      if (!countersScope[publicKeyHash] || countersScope[publicKeyHash] < headCounter) {\n        countersScope[publicKeyHash] = headCounter;\n      }\n\n      return {\n        counter: \"\" + ++countersScope[publicKeyHash]\n      };\n    };\n  }\n\n  Object.defineProperty(OperationEmitter.prototype, \"rpc\", {\n    get: function () {\n      return this.context.rpc;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(OperationEmitter.prototype, \"signer\", {\n    get: function () {\n      return this.context.signer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  OperationEmitter.prototype.isRevealOpNeeded = function (op, pkh) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.isAccountRevealRequired(pkh)];\n\n          case 1:\n            return [2\n            /*return*/\n            , !_a.sent() || !this.isRevealRequiredForOpType(op) ? false : true];\n        }\n      });\n    });\n  };\n\n  OperationEmitter.prototype.isAccountRevealRequired = function (publicKeyHash) {\n    return __awaiter(this, void 0, void 0, function () {\n      var manager, haveManager;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.rpc.getManagerKey(publicKeyHash)];\n\n          case 1:\n            manager = _a.sent();\n            haveManager = manager && typeof manager === 'object' ? !!manager.key : !!manager;\n            return [2\n            /*return*/\n            , !haveManager];\n        }\n      });\n    });\n  };\n\n  OperationEmitter.prototype.isRevealRequiredForOpType = function (op) {\n    var e_1, _a;\n\n    var opRequireReveal = false;\n\n    try {\n      for (var op_1 = __values(op), op_1_1 = op_1.next(); !op_1_1.done; op_1_1 = op_1.next()) {\n        var operation = op_1_1.value;\n\n        if (isOpRequireReveal(operation)) {\n          opRequireReveal = true;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (op_1_1 && !op_1_1.done && (_a = op_1.return)) _a.call(op_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return opRequireReveal;\n  };\n\n  OperationEmitter.prototype.prepareOpAndSimulation = function (_a) {\n    var operation = _a.operation,\n        source = _a.source;\n    return __awaiter(this, void 0, void 0, function () {\n      var ops, publicKeyHash, _b, counter, hash, protocol, preparedOpSimulation, preparedOp;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            ops = [];\n\n            if (Array.isArray(operation)) {\n              ops = __spreadArray([], __read(operation));\n            } else {\n              ops = [operation];\n            }\n\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 1:\n            publicKeyHash = _c.sent();\n            return [4\n            /*yield*/\n            , this.getCounterHashAndProtocol(ops, publicKeyHash)];\n\n          case 2:\n            _b = _c.sent(), counter = _b.counter, hash = _b.hash, protocol = _b.protocol;\n\n            if (!this.context.counters[publicKeyHash] || this.context.counters[publicKeyHash] < counter) {\n              this.context.counters[publicKeyHash] = counter;\n            } // This is a work around to the counter_in_the_future error returned by the RPC when calling the run_operation\n            // The preparedOpSimulation will be used to prevalidate the operation instead of the preparedOp\n            // The counter of an operation in preparedOpSimulation will be the head counter + 1\n            // The counter in preparedOp will be incremented accordingly if sending many operations in a row by keeping it on the context\n\n\n            if (counter !== this.context.counters[publicKeyHash]) {\n              preparedOpSimulation = {\n                opOb: {\n                  branch: hash,\n                  contents: this.constructOps(ops, publicKeyHash, counter, this.getScopeCounter, source)\n                },\n                counter: counter\n              };\n            }\n\n            preparedOp = {\n              opOb: {\n                branch: hash,\n                contents: this.constructOps(ops, publicKeyHash, counter, this.getContextCounter, source),\n                protocol: protocol\n              },\n              counter: counter\n            };\n            return [2\n            /*return*/\n            , {\n              preparedOp: preparedOp,\n              preparedOpSimulation: preparedOpSimulation\n            }];\n        }\n      });\n    });\n  };\n\n  OperationEmitter.prototype.getCounterHashAndProtocol = function (ops, publicKeyHash) {\n    return __awaiter(this, void 0, void 0, function () {\n      var blockHeaderPromise, blockMetaPromise, counterPromise, i, counter_1, _a, header, metadata, headCounter, counter;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            blockHeaderPromise = this.rpc.getBlockHeader();\n            blockMetaPromise = this.rpc.getBlockMetadata();\n            counterPromise = Promise.resolve(undefined);\n            i = 0;\n            _b.label = 1;\n\n          case 1:\n            if (!(i < ops.length)) return [3\n            /*break*/\n            , 4];\n            if (!(isOpRequireReveal(ops[i]) || ops[i].kind === 'reveal')) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , this.rpc.getContract(publicKeyHash)];\n\n          case 2:\n            counter_1 = _b.sent().counter;\n            counterPromise = Promise.resolve(counter_1);\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            i++;\n            return [3\n            /*break*/\n            , 1];\n\n          case 4:\n            return [4\n            /*yield*/\n            , Promise.all([blockHeaderPromise, blockMetaPromise, counterPromise])];\n\n          case 5:\n            _a = __read.apply(void 0, [_b.sent(), 3]), header = _a[0], metadata = _a[1], headCounter = _a[2];\n\n            if (!header) {\n              throw new Error('Unable to fetch latest block header');\n            }\n\n            if (!metadata) {\n              throw new Error('Unable to fetch latest metadata');\n            }\n\n            counter = parseInt(headCounter || '0', 10);\n            return [2\n            /*return*/\n            , {\n              counter: counter,\n              hash: header.hash,\n              protocol: metadata.next_protocol\n            }];\n        }\n      });\n    });\n  };\n\n  OperationEmitter.prototype.prepareOperationEstimation = function (_a) {\n    var operation = _a.operation,\n        source = _a.source;\n    return __awaiter(this, void 0, void 0, function () {\n      var countersScope, ops, publicKeyHash, _b, _c, counter, hash;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            countersScope = {};\n            ops = [];\n\n            if (Array.isArray(operation)) {\n              ops = __spreadArray([], __read(operation));\n            } else {\n              ops = [operation];\n            }\n\n            if (!source) return [3\n            /*break*/\n            , 1];\n            _b = source;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 2:\n            _b = _d.sent();\n            _d.label = 3;\n\n          case 3:\n            publicKeyHash = _b;\n            return [4\n            /*yield*/\n            , this.getCounterHashAndProtocol(ops, publicKeyHash)];\n\n          case 4:\n            _c = _d.sent(), counter = _c.counter, hash = _c.hash;\n\n            if (!countersScope[publicKeyHash] || countersScope[publicKeyHash] < counter) {\n              countersScope[publicKeyHash] = counter;\n            }\n\n            return [2\n            /*return*/\n            , {\n              opOb: {\n                branch: hash,\n                contents: this.constructOps(ops, publicKeyHash, counter, this.getScopeCounter, source)\n              },\n              counter: counter\n            }];\n        }\n      });\n    });\n  };\n\n  OperationEmitter.prototype.preValidate = function (prepared, forgedOperation) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, _b;\n\n      var _c;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            if (!prepared.preparedOpSimulation) return [3\n            /*break*/\n            , 2]; // we call runOperation instead of preapply\n            // to avoid having to produce 2 signatures (op with incremented counter and op used for simulation)\n\n            _b = this.runOperation;\n            _c = {\n              operation: __assign({\n                signature: SIGNATURE_STUB\n              }, prepared.preparedOpSimulation.opOb)\n            };\n            return [4\n            /*yield*/\n            , this.rpc.getChainId()];\n\n          case 1:\n            // we call runOperation instead of preapply\n            // to avoid having to produce 2 signatures (op with incremented counter and op used for simulation)\n            _a = _b.apply( // If we want to inject many operations in a same block\n            this, [(_c.chain_id = _d.sent(), _c)]);\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            _a = this.preapplyOperation(forgedOperation.opOb);\n            _d.label = 3;\n\n          case 3:\n            return [2\n            /*return*/\n            , _a];\n        }\n      });\n    });\n  };\n\n  OperationEmitter.prototype.forgeOperation = function (_a) {\n    var _b = _a.opOb,\n        branch = _b.branch,\n        contents = _b.contents;\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_c) {\n        return [2\n        /*return*/\n        , this.context.forger.forge({\n          branch: branch,\n          contents: contents\n        })];\n      });\n    });\n  };\n\n  OperationEmitter.prototype.forge = function (_a) {\n    var _b = _a.opOb,\n        branch = _b.branch,\n        contents = _b.contents,\n        protocol = _b.protocol,\n        counter = _a.counter;\n    return __awaiter(this, void 0, void 0, function () {\n      var forgedBytes;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.context.forger.forge({\n              branch: branch,\n              contents: contents\n            })];\n\n          case 1:\n            forgedBytes = _c.sent();\n            return [2\n            /*return*/\n            , {\n              opbytes: forgedBytes,\n              opOb: {\n                branch: branch,\n                contents: contents,\n                protocol: protocol\n              },\n              counter: counter\n            }];\n        }\n      });\n    });\n  };\n\n  OperationEmitter.prototype.simulate = function (op) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = {};\n            return [4\n            /*yield*/\n            , this.rpc.runOperation(op)];\n\n          case 1:\n            return [2\n            /*return*/\n            , (_a.opResponse = _b.sent(), _a.op = op, _a.context = this.context.clone(), _a)];\n        }\n      });\n    });\n  };\n\n  OperationEmitter.prototype.estimate = function (_a, estimator) {\n    var fee = _a.fee,\n        gasLimit = _a.gasLimit,\n        storageLimit = _a.storageLimit,\n        rest = __rest(_a, [\"fee\", \"gasLimit\", \"storageLimit\"]);\n\n    return __awaiter(this, void 0, void 0, function () {\n      var calculatedFee, calculatedGas, calculatedStorage, estimation;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            calculatedFee = fee;\n            calculatedGas = gasLimit;\n            calculatedStorage = storageLimit;\n            if (!(fee === undefined || gasLimit === undefined || storageLimit === undefined)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , estimator(__assign({\n              fee: fee,\n              gasLimit: gasLimit,\n              storageLimit: storageLimit\n            }, rest))];\n\n          case 1:\n            estimation = _b.sent();\n\n            if (calculatedFee === undefined) {\n              calculatedFee = estimation.suggestedFeeMutez;\n            }\n\n            if (calculatedGas === undefined) {\n              calculatedGas = estimation.gasLimit;\n            }\n\n            if (calculatedStorage === undefined) {\n              calculatedStorage = estimation.storageLimit;\n            }\n\n            _b.label = 2;\n\n          case 2:\n            return [2\n            /*return*/\n            , {\n              fee: calculatedFee,\n              gasLimit: calculatedGas,\n              storageLimit: calculatedStorage\n            }];\n        }\n      });\n    });\n  };\n\n  OperationEmitter.prototype.signOperation = function (forgedBytes) {\n    return __awaiter(this, void 0, void 0, function () {\n      var signed;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.signer.sign(forgedBytes.opbytes, new Uint8Array([3]))];\n\n          case 1:\n            signed = _a.sent();\n            forgedBytes.opbytes = signed.sbytes;\n            forgedBytes.opOb.signature = signed.prefixSig;\n            return [2\n            /*return*/\n            , forgedBytes];\n        }\n      });\n    });\n  };\n\n  OperationEmitter.prototype.runOperation = function (op) {\n    return __awaiter(this, void 0, void 0, function () {\n      var opResponse, results, j, errors;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            opResponse = [];\n            return [4\n            /*yield*/\n            , this.rpc.runOperation(op)];\n\n          case 1:\n            results = _a.sent();\n\n            for (j = 0; j < results.contents.length; j++) {\n              opResponse.push(results.contents[j]);\n            }\n\n            errors = flattenErrors(results);\n\n            if (errors.length) {\n              // @ts-ignore\n              throw new TezosOperationError(errors);\n            }\n\n            return [2\n            /*return*/\n            , opResponse];\n        }\n      });\n    });\n  };\n\n  OperationEmitter.prototype.preapplyOperation = function (opOb) {\n    return __awaiter(this, void 0, void 0, function () {\n      var opResponse, results, i, j, errors;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            opResponse = [];\n            return [4\n            /*yield*/\n            , this.rpc.preapplyOperations([opOb])];\n\n          case 1:\n            results = _a.sent();\n\n            if (!Array.isArray(results)) {\n              throw new TezosPreapplyFailureError(results);\n            }\n\n            for (i = 0; i < results.length; i++) {\n              for (j = 0; j < results[i].contents.length; j++) {\n                opResponse.push(results[i].contents[j]);\n              }\n            }\n\n            errors = flattenErrors(results);\n\n            if (errors.length) {\n              // @ts-ignore\n              throw new TezosOperationError(errors);\n            }\n\n            return [2\n            /*return*/\n            , opResponse];\n        }\n      });\n    });\n  };\n\n  OperationEmitter.prototype.injectOperation = function (signedOperationBytes) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.context.injector.inject(signedOperationBytes)];\n      });\n    });\n  };\n\n  return OperationEmitter;\n}();\n/**\r\n * @description Utility class to interact with Tezos operations\r\n */\n\n\nvar Operation =\n/** @class */\nfunction () {\n  /**\r\n   *\r\n   * @param hash Operation hash\r\n   * @param raw Raw operation that was injected\r\n   * @param context Taquito context allowing access to rpc and signer\r\n   */\n  function Operation(hash, raw, results, context) {\n    var _this = this;\n\n    this.hash = hash;\n    this.raw = raw;\n    this.results = results;\n    this.context = context;\n    this._pollingConfig$ = new ReplaySubject(1);\n    this._currentHeadPromise = undefined; // Caching the current head for one second\n\n    this.currentHead$ = defer(function () {\n      if (!_this._currentHeadPromise) {\n        _this._currentHeadPromise = _this.context.rpc.getBlock();\n        timer(1000).pipe(first()).subscribe(function () {\n          _this._currentHeadPromise = undefined;\n        });\n      }\n\n      return from(_this._currentHeadPromise);\n    }); // Polling observable that emit until timeout is reached\n\n    this.polling$ = defer(function () {\n      return _this._pollingConfig$.pipe(tap(function (_a) {\n        var timeout = _a.timeout,\n            interval = _a.interval;\n\n        if (timeout <= 0) {\n          throw new Error('Timeout must be more than 0');\n        }\n\n        if (interval <= 0) {\n          throw new Error('Interval must be more than 0');\n        }\n      }), map(function (config) {\n        return __assign(__assign({}, config), {\n          timeoutAt: Math.ceil(config.timeout / config.interval) + 1,\n          count: 0\n        });\n      }), switchMap(function (config) {\n        return timer(0, config.interval * 1000).pipe(mapTo(config));\n      }), tap(function (config) {\n        config.count++;\n\n        if (config.count > config.timeoutAt) {\n          throw new Error(\"Confirmation polling timed out\");\n        }\n      }));\n    }); // Observable that emit once operation is seen in a block\n\n    this.confirmed$ = this.polling$.pipe(switchMapTo(this.currentHead$), map(function (head) {\n      for (var i = 3; i >= 0; i--) {\n        head.operations[i].forEach(function (op) {\n          if (op.hash === _this.hash) {\n            _this._foundAt = head.header.level;\n          }\n        });\n      }\n\n      if (head.header.level - _this._foundAt >= 0) {\n        return _this._foundAt;\n      }\n    }), filter(function (x) {\n      return x !== undefined;\n    }), first(), shareReplay());\n    this._foundAt = Number.POSITIVE_INFINITY;\n    this.confirmed$.pipe(first()).subscribe();\n  }\n\n  Object.defineProperty(Operation.prototype, \"includedInBlock\", {\n    get: function () {\n      return this._foundAt;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Operation.prototype, \"revealOperation\", {\n    get: function () {\n      return Array.isArray(this.results) && this.results.find(function (op) {\n        return op.kind === 'reveal';\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Operation.prototype, \"revealStatus\", {\n    get: function () {\n      if (this.revealOperation) {\n        return this.revealOperation.metadata.operation_result.status;\n      } else {\n        return 'unknown';\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Operation.prototype, \"status\", {\n    get: function () {\n      return this.results.map(function (result) {\n        if (hasMetadataWithResult(result)) {\n          return result.metadata.operation_result.status;\n        } else {\n          return 'unknown';\n        }\n      })[0] || 'unknown';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   *\r\n   * @param confirmations [0] Number of confirmation to wait for\r\n   * @param interval [10] Polling interval\r\n   * @param timeout [180] Timeout\r\n   */\n\n  Operation.prototype.confirmation = function (confirmations, interval, timeout) {\n    return __awaiter(this, void 0, void 0, function () {\n      var confirmationPollingIntervalSecond, _a, _b, defaultConfirmationCount, confirmationPollingTimeoutSecond, conf;\n\n      var _this = this;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (typeof confirmations !== 'undefined' && confirmations < 1) {\n              throw new Error('Confirmation count must be at least 1');\n            }\n\n            if (!(this.context.config.confirmationPollingIntervalSecond !== undefined)) return [3\n            /*break*/\n            , 1];\n            _a = this.context.config.confirmationPollingIntervalSecond;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.context.getConfirmationPollingInterval()];\n\n          case 2:\n            _a = _c.sent();\n            _c.label = 3;\n\n          case 3:\n            confirmationPollingIntervalSecond = _a;\n            _b = this.context.config, defaultConfirmationCount = _b.defaultConfirmationCount, confirmationPollingTimeoutSecond = _b.confirmationPollingTimeoutSecond;\n\n            this._pollingConfig$.next({\n              interval: interval || confirmationPollingIntervalSecond,\n              timeout: timeout || confirmationPollingTimeoutSecond\n            });\n\n            conf = confirmations !== undefined ? confirmations : defaultConfirmationCount;\n\n            if (conf === undefined) {\n              throw new Error('Default confirmation count can not be undefined!');\n            }\n\n            return [2\n            /*return*/\n            , new Promise(function (resolve, reject) {\n              _this.confirmed$.pipe(switchMap(function () {\n                return _this.polling$;\n              }), switchMap(function () {\n                return _this.currentHead$;\n              }), filter(function (head) {\n                return head.header.level - _this._foundAt >= conf - 1;\n              }), first()).subscribe(function (_) {\n                resolve(_this._foundAt + (conf - 1));\n              }, reject);\n            })];\n        }\n      });\n    });\n  };\n\n  return Operation;\n}();\n\nvar RpcTzProvider =\n/** @class */\nfunction (_super) {\n  __extends(RpcTzProvider, _super);\n\n  function RpcTzProvider(context) {\n    return _super.call(this, context) || this;\n  }\n\n  RpcTzProvider.prototype.getBalance = function (address) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.rpc.getBalance(address)];\n      });\n    });\n  };\n\n  RpcTzProvider.prototype.getDelegate = function (address) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.rpc.getDelegate(address)];\n      });\n    });\n  };\n\n  RpcTzProvider.prototype.activate = function (pkh, secret) {\n    return __awaiter(this, void 0, void 0, function () {\n      var operation, prepared, forgedBytes, bytes, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            operation = {\n              kind: OpKind.ACTIVATION,\n              pkh: pkh,\n              secret: secret\n            };\n            return [4\n            /*yield*/\n            , this.prepareOpAndSimulation({\n              operation: [operation],\n              source: pkh\n            })];\n\n          case 1:\n            prepared = _b.sent();\n            return [4\n            /*yield*/\n            , this.forge(prepared.preparedOp)];\n\n          case 2:\n            forgedBytes = _b.sent();\n            bytes = forgedBytes.opbytes + \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\";\n            _a = Operation.bind;\n            return [4\n            /*yield*/\n            , this.rpc.injectOperation(bytes)];\n\n          case 3:\n            return [2\n            /*return*/\n            , new (_a.apply(Operation, [void 0, _b.sent(), __assign(__assign({}, forgedBytes), {\n              opbytes: bytes\n            }), [], this.context.clone()]))()];\n        }\n      });\n    });\n  };\n\n  return RpcTzProvider;\n}(OperationEmitter);\n\nvar MINIMAL_FEE_MUTEZ = 100;\nvar MINIMAL_FEE_PER_BYTE_MUTEZ = 1;\nvar MINIMAL_FEE_PER_GAS_MUTEZ = 0.1;\nvar GAS_BUFFER = 100;\n/**\r\n * Examples of use :\r\n *\r\n *  Estimate a transfer operation :\r\n * ```\r\n * // Assuming that provider and signer are already configured...\r\n *\r\n * const amount = 2;\r\n * const address = 'tz1h3rQ8wBxFd8L9B3d7Jhaawu6Z568XU3xY';\r\n *\r\n * // Estimate gasLimit, storageLimit and fees for a transfer operation\r\n * const est = await Tezos.estimate.transfer({ to: address, amount: amount })\r\n * console.log(est.burnFeeMutez, est.gasLimit, est.minimalFeeMutez, est.storageLimit,\r\n *  est.suggestedFeeMutez, est.totalCost, est.usingBaseFeeMutez)\r\n *\r\n * ```\r\n *\r\n * Estimate a contract origination :\r\n * ```\r\n * // generic.json is referring to a Michelson Smart Contract\r\n *\r\n * const genericMultisigJSON = require('./generic.json')\r\n * const est = await Tezos.estimate.originate({\r\n *   code: genericMultisigJSON,\r\n *   storage: {\r\n *     stored_counter: 0,\r\n *     threshold: 1,\r\n *     keys: ['edpkuLxx9PQD8fZ45eUzrK3BhfDZJHhBuK4Zi49DcEGANwd2rpX82t']\r\n *   }\r\n * })\r\n * console.log(est.burnFeeMutez, est.gasLimit, est.minimalFeeMutez, est.storageLimit,\r\n *   est.suggestedFeeMutez, est.totalCost, est.usingBaseFeeMutez)\r\n *\r\n * ```\r\n */\n\nvar Estimate =\n/** @class */\nfunction () {\n  function Estimate(_milligasLimit, _storageLimit, opSize, minimalFeePerStorageByteMutez,\n  /**\r\n   * @description Base fee in mutez (1 mutez = 1e10−6 tez)\r\n   */\n  baseFeeMutez) {\n    if (baseFeeMutez === void 0) {\n      baseFeeMutez = MINIMAL_FEE_MUTEZ;\n    }\n\n    this._milligasLimit = _milligasLimit;\n    this._storageLimit = _storageLimit;\n    this.opSize = opSize;\n    this.minimalFeePerStorageByteMutez = minimalFeePerStorageByteMutez;\n    this.baseFeeMutez = baseFeeMutez;\n  }\n\n  Object.defineProperty(Estimate.prototype, \"burnFeeMutez\", {\n    /**\r\n     * @description The number of Mutez that will be burned for the storage of the [operation](https://tezos.gitlab.io/user/glossary.html#operations). (Storage + Allocation fees)\r\n     */\n    get: function () {\n      return this.roundUp(Number(this.storageLimit) * Number(this.minimalFeePerStorageByteMutez));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Estimate.prototype, \"storageLimit\", {\n    /**\r\n     * @description  The limit on the amount of storage an [operation](https://tezos.gitlab.io/user/glossary.html#operations) can use.\r\n     */\n    get: function () {\n      var limit = Math.max(Number(this._storageLimit), 0);\n      return limit > 0 ? limit : 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Estimate.prototype, \"gasLimit\", {\n    /**\r\n     * @description The limit on the amount of [gas](https://tezos.gitlab.io/user/glossary.html#gas) a given operation can consume.\r\n     */\n    get: function () {\n      return this.roundUp(Number(this._milligasLimit) / 1000 + GAS_BUFFER);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Estimate.prototype, \"operationFeeMutez\", {\n    get: function () {\n      return (Number(this._milligasLimit) / 1000 + GAS_BUFFER) * MINIMAL_FEE_PER_GAS_MUTEZ + Number(this.opSize) * MINIMAL_FEE_PER_BYTE_MUTEZ;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Estimate.prototype.roundUp = function (nanotez) {\n    return Math.ceil(Number(nanotez));\n  };\n\n  Object.defineProperty(Estimate.prototype, \"minimalFeeMutez\", {\n    /**\r\n     * @description Minimum fees for the [operation](https://tezos.gitlab.io/user/glossary.html#operations) according to [baker](https://tezos.gitlab.io/user/glossary.html#baker) defaults.\r\n     */\n    get: function () {\n      return this.roundUp(MINIMAL_FEE_MUTEZ + this.operationFeeMutez);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Estimate.prototype, \"suggestedFeeMutez\", {\n    /**\r\n     * @description The suggested fee for the operation which includes minimal fees and a small buffer.\r\n     */\n    get: function () {\n      return this.roundUp(this.operationFeeMutez + MINIMAL_FEE_MUTEZ * 2);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Estimate.prototype, \"usingBaseFeeMutez\", {\n    /**\r\n     * @description Fees according to your specified base fee will ensure that at least minimum fees are used.\r\n     */\n    get: function () {\n      return Math.max(Number(this.baseFeeMutez), MINIMAL_FEE_MUTEZ) + this.roundUp(this.operationFeeMutez);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Estimate.prototype, \"totalCost\", {\n    /**\r\n     * @description The sum of `minimalFeeMutez` + `burnFeeMutez`.\r\n     */\n    get: function () {\n      return this.minimalFeeMutez + this.burnFeeMutez;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Estimate.prototype, \"consumedMilligas\", {\n    /**\r\n     * @description Since Delphinet, consumed gas is provided in milligas for more precision.\r\n     * This function returns an estimation of the gas that operation will consume in milligas.\r\n     */\n    get: function () {\n      return Number(this._milligasLimit);\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Estimate.createEstimateInstanceFromProperties = function (estimateProperties) {\n    var milligasLimit = 0;\n    var storageLimit = 0;\n    var opSize = 0;\n    var minimalFeePerStorageByteMutez = 0;\n    var baseFeeMutez;\n    estimateProperties.forEach(function (estimate) {\n      milligasLimit += estimate.milligasLimit;\n      storageLimit += estimate.storageLimit;\n      opSize += estimate.opSize;\n      minimalFeePerStorageByteMutez = Math.max(estimate.minimalFeePerStorageByteMutez, minimalFeePerStorageByteMutez);\n\n      if (estimate.baseFeeMutez) {\n        baseFeeMutez = baseFeeMutez ? baseFeeMutez + estimate.baseFeeMutez : estimate.baseFeeMutez;\n      }\n    });\n    return new Estimate(milligasLimit, storageLimit, opSize, minimalFeePerStorageByteMutez, baseFeeMutez);\n  };\n\n  Estimate.createArrayEstimateInstancesFromProperties = function (estimateProperties) {\n    return estimateProperties.map(function (x) {\n      return new Estimate(x.milligasLimit, x.storageLimit, x.opSize, x.minimalFeePerStorageByteMutez, x.baseFeeMutez);\n    });\n  };\n\n  return Estimate;\n}();\n\nvar TZ_DECIMALS = 6;\nvar MTZ_DECIMALS = 3;\n\nfunction getDecimal(format) {\n  switch (format) {\n    case 'tz':\n      return TZ_DECIMALS;\n\n    case 'mtz':\n      return MTZ_DECIMALS;\n\n    case 'mutez':\n    default:\n      return 0;\n  }\n}\n\nfunction format(from, to, amount) {\n  if (from === void 0) {\n    from = 'mutez';\n  }\n\n  if (to === void 0) {\n    to = 'mutez';\n  }\n\n  var bigNum = new BigNumber(amount);\n\n  if (bigNum.isNaN()) {\n    return amount;\n  }\n\n  return bigNum.multipliedBy(Math.pow(10, getDecimal(from))).dividedBy(Math.pow(10, getDecimal(to)));\n}\n\nvar InvalidParameterError =\n/** @class */\nfunction () {\n  function InvalidParameterError(smartContractMethodName, sigs, args) {\n    this.smartContractMethodName = smartContractMethodName;\n    this.sigs = sigs;\n    this.args = args;\n    this.name = 'Invalid parameters error';\n    this.message = smartContractMethodName + \" Received \" + args.length + \" arguments while expecting one of the following signatures (\" + JSON.stringify(sigs) + \")\";\n  }\n\n  return InvalidParameterError;\n}();\n\nvar UndefinedLambdaContractError =\n/** @class */\nfunction () {\n  function UndefinedLambdaContractError() {\n    this.name = 'Undefined LambdaContract error';\n    this.message = \"This might happen if you are using a sandbox. Please provide the address of a lambda contract as a parameter of the read method.\";\n  }\n\n  return UndefinedLambdaContractError;\n}();\n\nvar InvalidDelegationSource =\n/** @class */\nfunction () {\n  function InvalidDelegationSource(source) {\n    this.source = source;\n    this.name = 'Invalid delegation source error';\n    this.message = \"Since Babylon delegation source can no longer be a contract address \" + source + \". Please use the smart contract abstraction to set your delegate.\";\n  }\n\n  return InvalidDelegationSource;\n}();\n\nvar InvalidCodeParameter =\n/** @class */\nfunction () {\n  function InvalidCodeParameter(message, data) {\n    this.message = message;\n    this.data = data;\n    this.name = 'InvalidCodeParameter';\n  }\n\n  return InvalidCodeParameter;\n}();\n\nvar InvalidInitParameter =\n/** @class */\nfunction () {\n  function InvalidInitParameter(message, data) {\n    this.message = message;\n    this.data = data;\n    this.name = 'InvalidInitParameter';\n  }\n\n  return InvalidInitParameter;\n}();\n\nvar createOriginationOperation = function (_a) {\n  var code = _a.code,\n      init = _a.init,\n      _b = _a.balance,\n      balance = _b === void 0 ? \"0\" : _b,\n      delegate = _a.delegate,\n      storage = _a.storage,\n      _c = _a.fee,\n      fee = _c === void 0 ? DEFAULT_FEE.ORIGINATION : _c,\n      _d = _a.gasLimit,\n      gasLimit = _d === void 0 ? DEFAULT_GAS_LIMIT.ORIGINATION : _d,\n      _e = _a.storageLimit,\n      storageLimit = _e === void 0 ? DEFAULT_STORAGE_LIMIT.ORIGINATION : _e,\n      _f = _a.mutez,\n      mutez = _f === void 0 ? false : _f;\n  return __awaiter(void 0, void 0, void 0, function () {\n    var contractStorage, storageType, schema, script, operation;\n    return __generator(this, function (_g) {\n      // tslint:disable-next-line: strict-type-predicates\n      if (storage !== undefined && init !== undefined) {\n        throw new Error(\"Storage and Init cannot be set a the same time. Please either use storage or init but not both.\");\n      }\n\n      if (!Array.isArray(code)) {\n        throw new InvalidCodeParameter('Wrong code parameter type, expected an array', code);\n      }\n\n      if (storage !== undefined) {\n        storageType = code.find(function (p) {\n          return 'prim' in p && p.prim === 'storage';\n        });\n\n        if ((storageType === null || storageType === void 0 ? void 0 : storageType.args) === undefined) {\n          throw new InvalidCodeParameter('The storage section is missing from the script', code);\n        }\n\n        schema = new Schema(storageType.args[0]);\n        contractStorage = schema.Encode(storage);\n      } else if (init !== undefined && typeof init === 'object') {\n        contractStorage = init;\n      } else {\n        throw new InvalidInitParameter('Wrong init parameter type, expected JSON Michelson', init);\n      }\n\n      script = {\n        code: code,\n        storage: contractStorage\n      };\n      operation = {\n        kind: OpKind.ORIGINATION,\n        fee: fee,\n        gas_limit: gasLimit,\n        storage_limit: storageLimit,\n        balance: mutez ? balance.toString() : format('tz', 'mutez', balance).toString(),\n        script: script\n      };\n\n      if (delegate) {\n        operation.delegate = delegate;\n      }\n\n      return [2\n      /*return*/\n      , operation];\n    });\n  });\n};\n\nvar createTransferOperation = function (_a) {\n  var to = _a.to,\n      amount = _a.amount,\n      parameter = _a.parameter,\n      _b = _a.fee,\n      fee = _b === void 0 ? DEFAULT_FEE.TRANSFER : _b,\n      _c = _a.gasLimit,\n      gasLimit = _c === void 0 ? DEFAULT_GAS_LIMIT.TRANSFER : _c,\n      _d = _a.storageLimit,\n      storageLimit = _d === void 0 ? DEFAULT_STORAGE_LIMIT.TRANSFER : _d,\n      _e = _a.mutez,\n      mutez = _e === void 0 ? false : _e;\n  return __awaiter(void 0, void 0, void 0, function () {\n    var operation;\n    return __generator(this, function (_f) {\n      operation = {\n        kind: OpKind.TRANSACTION,\n        fee: fee,\n        gas_limit: gasLimit,\n        storage_limit: storageLimit,\n        amount: mutez ? amount.toString() : format(\"tz\", \"mutez\", amount).toString(),\n        destination: to,\n        parameters: parameter\n      };\n      return [2\n      /*return*/\n      , operation];\n    });\n  });\n};\n\nvar createSetDelegateOperation = function (_a) {\n  var delegate = _a.delegate,\n      source = _a.source,\n      _b = _a.fee,\n      fee = _b === void 0 ? DEFAULT_FEE.DELEGATION : _b,\n      _c = _a.gasLimit,\n      gasLimit = _c === void 0 ? DEFAULT_GAS_LIMIT.DELEGATION : _c,\n      _d = _a.storageLimit,\n      storageLimit = _d === void 0 ? DEFAULT_STORAGE_LIMIT.DELEGATION : _d;\n  return __awaiter(void 0, void 0, void 0, function () {\n    var operation;\n    return __generator(this, function (_e) {\n      operation = {\n        kind: OpKind.DELEGATION,\n        source: source,\n        fee: fee,\n        gas_limit: gasLimit,\n        storage_limit: storageLimit,\n        delegate: delegate\n      };\n      return [2\n      /*return*/\n      , operation];\n    });\n  });\n};\n\nvar createRegisterDelegateOperation = function (_a, source) {\n  var _b = _a.fee,\n      fee = _b === void 0 ? DEFAULT_FEE.DELEGATION : _b,\n      _c = _a.gasLimit,\n      gasLimit = _c === void 0 ? DEFAULT_GAS_LIMIT.DELEGATION : _c,\n      _d = _a.storageLimit,\n      storageLimit = _d === void 0 ? DEFAULT_STORAGE_LIMIT.DELEGATION : _d;\n  return __awaiter(void 0, void 0, void 0, function () {\n    return __generator(this, function (_e) {\n      return [2\n      /*return*/\n      , {\n        kind: OpKind.DELEGATION,\n        fee: fee,\n        gas_limit: gasLimit,\n        storage_limit: storageLimit,\n        delegate: source\n      }];\n    });\n  });\n};\n\nvar createRevealOperation = function (_a, source, publicKey) {\n  var _b = _a.fee,\n      fee = _b === void 0 ? DEFAULT_FEE.REVEAL : _b,\n      _c = _a.gasLimit,\n      gasLimit = _c === void 0 ? DEFAULT_GAS_LIMIT.REVEAL : _c,\n      _d = _a.storageLimit,\n      storageLimit = _d === void 0 ? DEFAULT_STORAGE_LIMIT.REVEAL : _d;\n  return __awaiter(void 0, void 0, void 0, function () {\n    return __generator(this, function (_e) {\n      return [2\n      /*return*/\n      , {\n        kind: OpKind.REVEAL,\n        fee: fee,\n        public_key: publicKey,\n        source: source,\n        gas_limit: gasLimit,\n        storage_limit: storageLimit\n      }];\n    });\n  });\n};\n\nvar mergeLimits = function (userDefinedLimit, defaultLimits) {\n  return {\n    fee: typeof userDefinedLimit.fee === 'undefined' ? defaultLimits.fee : userDefinedLimit.fee,\n    gasLimit: typeof userDefinedLimit.gasLimit === 'undefined' ? defaultLimits.gasLimit : userDefinedLimit.gasLimit,\n    storageLimit: typeof userDefinedLimit.storageLimit === 'undefined' ? defaultLimits.storageLimit : userDefinedLimit.storageLimit\n  };\n};\n\nvar RPCEstimateProvider =\n/** @class */\nfunction (_super) {\n  __extends(RPCEstimateProvider, _super);\n\n  function RPCEstimateProvider() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.ALLOCATION_STORAGE = 257;\n    _this.ORIGINATION_STORAGE = 257;\n    _this.OP_SIZE_REVEAL = 128;\n    return _this;\n  } // Maximum values defined by the protocol\n\n\n  RPCEstimateProvider.prototype.getAccountLimits = function (pkh, numberOfOps) {\n    return __awaiter(this, void 0, void 0, function () {\n      var balance, _a, hard_gas_limit_per_operation, hard_gas_limit_per_block, hard_storage_limit_per_operation, cost_per_byte;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.rpc.getBalance(pkh)];\n\n          case 1:\n            balance = _b.sent();\n            return [4\n            /*yield*/\n            , this.rpc.getConstants()];\n\n          case 2:\n            _a = _b.sent(), hard_gas_limit_per_operation = _a.hard_gas_limit_per_operation, hard_gas_limit_per_block = _a.hard_gas_limit_per_block, hard_storage_limit_per_operation = _a.hard_storage_limit_per_operation, cost_per_byte = _a.cost_per_byte;\n            return [2\n            /*return*/\n            , {\n              fee: 0,\n              gasLimit: numberOfOps ? Math.floor(this.ajustGasForBatchOperation(hard_gas_limit_per_block, hard_gas_limit_per_operation, numberOfOps).toNumber()) : hard_gas_limit_per_operation.toNumber(),\n              storageLimit: Math.floor(BigNumber.min(balance.dividedBy(cost_per_byte), hard_storage_limit_per_operation).toNumber())\n            }];\n        }\n      });\n    });\n  }; // Fix for Granada where the total gasLimit of a batch can not exceed the hard_gas_limit_per_block.\n  // If the total gasLimit of the batch is higher than the hard_gas_limit_per_block,\n  // the gasLimit is calculated by dividing the hard_gas_limit_per_block by the number of operation in the batch (numberOfOps).\n  // numberOfOps is incremented by 1 for safety in case a reveal operation is needed\n\n\n  RPCEstimateProvider.prototype.ajustGasForBatchOperation = function (gasLimitBlock, gaslimitOp, numberOfOps) {\n    return BigNumber.min(gaslimitOp, gasLimitBlock.div(numberOfOps + 1));\n  };\n\n  RPCEstimateProvider.prototype.getEstimationPropertiesFromOperationContent = function (content, size, costPerByte) {\n    var _this = this;\n\n    var operationResults = flattenOperationResult({\n      contents: [content]\n    });\n    var totalGas = 0;\n    var totalMilligas = 0;\n    var totalStorage = 0;\n    operationResults.forEach(function (result) {\n      totalStorage += 'originated_contracts' in result && typeof result.originated_contracts !== 'undefined' ? result.originated_contracts.length * _this.ORIGINATION_STORAGE : 0;\n      totalStorage += 'allocated_destination_contract' in result ? _this.ALLOCATION_STORAGE : 0;\n      totalGas += Number(result.consumed_gas) || 0;\n      totalMilligas += Number(result.consumed_milligas) || 0;\n      totalStorage += 'paid_storage_size_diff' in result ? Number(result.paid_storage_size_diff) || 0 : 0;\n    });\n\n    if (totalGas !== 0 && totalMilligas === 0) {\n      // This will convert gas to milligas for Carthagenet where result does not contain consumed gas in milligas.\n      totalMilligas = totalGas * 1000;\n    }\n\n    if (isOpWithFee(content)) {\n      return {\n        milligasLimit: totalMilligas || 0,\n        storageLimit: Number(totalStorage || 0),\n        opSize: size,\n        minimalFeePerStorageByteMutez: costPerByte.toNumber()\n      };\n    } else {\n      return {\n        milligasLimit: 0,\n        storageLimit: 0,\n        opSize: size,\n        minimalFeePerStorageByteMutez: costPerByte.toNumber(),\n        baseFeeMutez: 0\n      };\n    }\n  };\n\n  RPCEstimateProvider.prototype.prepareEstimate = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var preparedSimulation, opbytes, operation, opResponse, cost_per_byte, errors, numberOfOps;\n\n      var _a;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.prepareOperationEstimation(params)];\n\n          case 1:\n            preparedSimulation = _b.sent();\n            return [4\n            /*yield*/\n            , this.forgeOperation(preparedSimulation)];\n\n          case 2:\n            opbytes = _b.sent();\n            _a = {\n              operation: {\n                branch: preparedSimulation.opOb.branch,\n                contents: preparedSimulation.opOb.contents,\n                signature: SIGNATURE_STUB\n              }\n            };\n            return [4\n            /*yield*/\n            , this.rpc.getChainId()];\n\n          case 3:\n            operation = (_a.chain_id = _b.sent(), _a);\n            return [4\n            /*yield*/\n            , this.simulate(operation)];\n\n          case 4:\n            opResponse = _b.sent().opResponse;\n            return [4\n            /*yield*/\n            , this.rpc.getConstants()];\n\n          case 5:\n            cost_per_byte = _b.sent().cost_per_byte;\n            errors = __spreadArray(__spreadArray([], __read(flattenErrors(opResponse, 'backtracked'))), __read(flattenErrors(opResponse))); // Fail early in case of errors\n\n            if (errors.length) {\n              throw new TezosOperationError(errors);\n            }\n\n            numberOfOps = 1;\n\n            if (Array.isArray(params.operation) && params.operation.length > 1) {\n              numberOfOps = opResponse.contents[0].kind === 'reveal' ? params.operation.length - 1 : params.operation.length;\n            }\n\n            return [2\n            /*return*/\n            , opResponse.contents.map(function (x) {\n              return _this.getEstimationPropertiesFromOperationContent(x, // TODO: Calculate a specific opSize for each operation.\n              x.kind === 'reveal' ? _this.OP_SIZE_REVEAL / 2 : opbytes.length / 2 / numberOfOps, cost_per_byte);\n            })];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees for an origination operation\r\n   *\r\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n   *\r\n   * @param OriginationOperation Originate operation parameter\r\n   */\n\n\n  RPCEstimateProvider.prototype.originate = function (_a) {\n    var fee = _a.fee,\n        storageLimit = _a.storageLimit,\n        gasLimit = _a.gasLimit,\n        rest = __rest(_a, [\"fee\", \"storageLimit\", \"gasLimit\"]);\n\n    return __awaiter(this, void 0, void 0, function () {\n      var pkh, DEFAULT_PARAMS, op, _b, isRevealNeeded, ops, _c, estimateProperties;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 1:\n            pkh = _d.sent();\n            return [4\n            /*yield*/\n            , this.getAccountLimits(pkh)];\n\n          case 2:\n            DEFAULT_PARAMS = _d.sent();\n            _b = createOriginationOperation;\n            return [4\n            /*yield*/\n            , this.context.parser.prepareCodeOrigination(__assign(__assign({}, rest), mergeLimits({\n              fee: fee,\n              storageLimit: storageLimit,\n              gasLimit: gasLimit\n            }, DEFAULT_PARAMS)))];\n\n          case 3:\n            return [4\n            /*yield*/\n            , _b.apply(void 0, [_d.sent()])];\n\n          case 4:\n            op = _d.sent();\n            return [4\n            /*yield*/\n            , this.isRevealOpNeeded([op], pkh)];\n\n          case 5:\n            isRevealNeeded = _d.sent();\n            if (!isRevealNeeded) return [3\n            /*break*/\n            , 7];\n            return [4\n            /*yield*/\n            , this.addRevealOp([op], pkh)];\n\n          case 6:\n            _c = _d.sent();\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            _c = op;\n            _d.label = 8;\n\n          case 8:\n            ops = _c;\n            return [4\n            /*yield*/\n            , this.prepareEstimate({\n              operation: ops,\n              source: pkh\n            })];\n\n          case 9:\n            estimateProperties = _d.sent();\n\n            if (isRevealNeeded) {\n              estimateProperties.shift();\n            }\n\n            return [2\n            /*return*/\n            , Estimate.createEstimateInstanceFromProperties(estimateProperties)];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees for an transfer operation\r\n   *\r\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n   *\r\n   * @param TransferOperation Originate operation parameter\r\n   */\n\n\n  RPCEstimateProvider.prototype.transfer = function (_a) {\n    var fee = _a.fee,\n        storageLimit = _a.storageLimit,\n        gasLimit = _a.gasLimit,\n        rest = __rest(_a, [\"fee\", \"storageLimit\", \"gasLimit\"]);\n\n    return __awaiter(this, void 0, void 0, function () {\n      var pkh, DEFAULT_PARAMS, op, isRevealNeeded, ops, _b, estimateProperties;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 1:\n            pkh = _c.sent();\n            return [4\n            /*yield*/\n            , this.getAccountLimits(pkh)];\n\n          case 2:\n            DEFAULT_PARAMS = _c.sent();\n            return [4\n            /*yield*/\n            , createTransferOperation(__assign(__assign({}, rest), mergeLimits({\n              fee: fee,\n              storageLimit: storageLimit,\n              gasLimit: gasLimit\n            }, DEFAULT_PARAMS)))];\n\n          case 3:\n            op = _c.sent();\n            return [4\n            /*yield*/\n            , this.isRevealOpNeeded([op], pkh)];\n\n          case 4:\n            isRevealNeeded = _c.sent();\n            if (!isRevealNeeded) return [3\n            /*break*/\n            , 6];\n            return [4\n            /*yield*/\n            , this.addRevealOp([op], pkh)];\n\n          case 5:\n            _b = _c.sent();\n            return [3\n            /*break*/\n            , 7];\n\n          case 6:\n            _b = op;\n            _c.label = 7;\n\n          case 7:\n            ops = _b;\n            return [4\n            /*yield*/\n            , this.prepareEstimate({\n              operation: ops,\n              source: pkh\n            })];\n\n          case 8:\n            estimateProperties = _c.sent();\n\n            if (isRevealNeeded) {\n              estimateProperties.shift();\n            }\n\n            return [2\n            /*return*/\n            , Estimate.createEstimateInstanceFromProperties(estimateProperties)];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees for a delegate operation\r\n   *\r\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n   *\r\n   * @param Estimate\r\n   */\n\n\n  RPCEstimateProvider.prototype.setDelegate = function (_a) {\n    var fee = _a.fee,\n        gasLimit = _a.gasLimit,\n        storageLimit = _a.storageLimit,\n        rest = __rest(_a, [\"fee\", \"gasLimit\", \"storageLimit\"]);\n\n    return __awaiter(this, void 0, void 0, function () {\n      var pkh, sourceOrDefault, DEFAULT_PARAMS, op, isRevealNeeded, ops, _b, estimateProperties;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 1:\n            pkh = _c.sent();\n            sourceOrDefault = rest.source || pkh;\n            return [4\n            /*yield*/\n            , this.getAccountLimits(sourceOrDefault)];\n\n          case 2:\n            DEFAULT_PARAMS = _c.sent();\n            return [4\n            /*yield*/\n            , createSetDelegateOperation(__assign(__assign({}, rest), mergeLimits({\n              fee: fee,\n              storageLimit: storageLimit,\n              gasLimit: gasLimit\n            }, DEFAULT_PARAMS)))];\n\n          case 3:\n            op = _c.sent();\n            return [4\n            /*yield*/\n            , this.isRevealOpNeeded([op], pkh)];\n\n          case 4:\n            isRevealNeeded = _c.sent();\n            if (!isRevealNeeded) return [3\n            /*break*/\n            , 6];\n            return [4\n            /*yield*/\n            , this.addRevealOp([op], pkh)];\n\n          case 5:\n            _b = _c.sent();\n            return [3\n            /*break*/\n            , 7];\n\n          case 6:\n            _b = op;\n            _c.label = 7;\n\n          case 7:\n            ops = _b;\n            return [4\n            /*yield*/\n            , this.prepareEstimate({\n              operation: ops,\n              source: pkh\n            })];\n\n          case 8:\n            estimateProperties = _c.sent();\n\n            if (isRevealNeeded) {\n              estimateProperties.shift();\n            }\n\n            return [2\n            /*return*/\n            , Estimate.createEstimateInstanceFromProperties(estimateProperties)];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees for a each operation in the batch\r\n   *\r\n   * @returns An array of Estimate objects. If a reveal operation is needed, the first element of the array is the Estimate for the reveal operation.\r\n   */\n\n\n  RPCEstimateProvider.prototype.batch = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var pkh, operations, DEFAULT_PARAMS, params_1, params_1_1, param, _a, _b, _c, _d, _e, _f, _g, _h, e_1_1, isRevealNeeded, _j, estimateProperties;\n\n      var e_1, _k;\n\n      return __generator(this, function (_l) {\n        switch (_l.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 1:\n            pkh = _l.sent();\n            operations = [];\n            return [4\n            /*yield*/\n            , this.getAccountLimits(pkh, params.length)];\n\n          case 2:\n            DEFAULT_PARAMS = _l.sent();\n            _l.label = 3;\n\n          case 3:\n            _l.trys.push([3, 16, 17, 18]);\n\n            params_1 = __values(params), params_1_1 = params_1.next();\n            _l.label = 4;\n\n          case 4:\n            if (!!params_1_1.done) return [3\n            /*break*/\n            , 15];\n            param = params_1_1.value;\n            _a = param.kind;\n\n            switch (_a) {\n              case OpKind.TRANSACTION:\n                return [3\n                /*break*/\n                , 5];\n\n              case OpKind.ORIGINATION:\n                return [3\n                /*break*/\n                , 7];\n\n              case OpKind.DELEGATION:\n                return [3\n                /*break*/\n                , 10];\n\n              case OpKind.ACTIVATION:\n                return [3\n                /*break*/\n                , 12];\n            }\n\n            return [3\n            /*break*/\n            , 13];\n\n          case 5:\n            _c = (_b = operations).push;\n            return [4\n            /*yield*/\n            , createTransferOperation(__assign(__assign({}, param), mergeLimits(param, DEFAULT_PARAMS)))];\n\n          case 6:\n            _c.apply(_b, [_l.sent()]);\n\n            return [3\n            /*break*/\n            , 14];\n\n          case 7:\n            _e = (_d = operations).push;\n            _f = createOriginationOperation;\n            return [4\n            /*yield*/\n            , this.context.parser.prepareCodeOrigination(__assign(__assign({}, param), mergeLimits(param, DEFAULT_PARAMS)))];\n\n          case 8:\n            return [4\n            /*yield*/\n            , _f.apply(void 0, [_l.sent()])];\n\n          case 9:\n            _e.apply(_d, [_l.sent()]);\n\n            return [3\n            /*break*/\n            , 14];\n\n          case 10:\n            _h = (_g = operations).push;\n            return [4\n            /*yield*/\n            , createSetDelegateOperation(__assign(__assign({}, param), mergeLimits(param, DEFAULT_PARAMS)))];\n\n          case 11:\n            _h.apply(_g, [_l.sent()]);\n\n            return [3\n            /*break*/\n            , 14];\n\n          case 12:\n            operations.push(__assign(__assign({}, param), DEFAULT_PARAMS));\n            return [3\n            /*break*/\n            , 14];\n\n          case 13:\n            throw new Error(\"Unsupported operation kind: \" + param.kind);\n\n          case 14:\n            params_1_1 = params_1.next();\n            return [3\n            /*break*/\n            , 4];\n\n          case 15:\n            return [3\n            /*break*/\n            , 18];\n\n          case 16:\n            e_1_1 = _l.sent();\n            e_1 = {\n              error: e_1_1\n            };\n            return [3\n            /*break*/\n            , 18];\n\n          case 17:\n            try {\n              if (params_1_1 && !params_1_1.done && (_k = params_1.return)) _k.call(params_1);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 18:\n            return [4\n            /*yield*/\n            , this.isRevealOpNeeded(operations, pkh)];\n\n          case 19:\n            isRevealNeeded = _l.sent();\n            if (!isRevealNeeded) return [3\n            /*break*/\n            , 21];\n            return [4\n            /*yield*/\n            , this.addRevealOp(operations, pkh)];\n\n          case 20:\n            _j = _l.sent();\n            return [3\n            /*break*/\n            , 22];\n\n          case 21:\n            _j = operations;\n            _l.label = 22;\n\n          case 22:\n            operations = _j;\n            return [4\n            /*yield*/\n            , this.prepareEstimate({\n              operation: operations,\n              source: pkh\n            })];\n\n          case 23:\n            estimateProperties = _l.sent();\n            return [2\n            /*return*/\n            , Estimate.createArrayEstimateInstancesFromProperties(estimateProperties)];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees for a delegate operation\r\n   *\r\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n   *\r\n   * @param Estimate\r\n   */\n\n\n  RPCEstimateProvider.prototype.registerDelegate = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var pkh, DEFAULT_PARAMS, op, isRevealNeeded, ops, _a, estimateProperties;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 1:\n            pkh = _b.sent();\n            return [4\n            /*yield*/\n            , this.getAccountLimits(pkh)];\n\n          case 2:\n            DEFAULT_PARAMS = _b.sent();\n            return [4\n            /*yield*/\n            , createRegisterDelegateOperation(__assign(__assign({}, params), DEFAULT_PARAMS), pkh)];\n\n          case 3:\n            op = _b.sent();\n            return [4\n            /*yield*/\n            , this.isRevealOpNeeded([op], pkh)];\n\n          case 4:\n            isRevealNeeded = _b.sent();\n            if (!isRevealNeeded) return [3\n            /*break*/\n            , 6];\n            return [4\n            /*yield*/\n            , this.addRevealOp([op], pkh)];\n\n          case 5:\n            _a = _b.sent();\n            return [3\n            /*break*/\n            , 7];\n\n          case 6:\n            _a = op;\n            _b.label = 7;\n\n          case 7:\n            ops = _a;\n            return [4\n            /*yield*/\n            , this.prepareEstimate({\n              operation: ops,\n              source: pkh\n            })];\n\n          case 8:\n            estimateProperties = _b.sent();\n\n            if (isRevealNeeded) {\n              estimateProperties.shift();\n            }\n\n            return [2\n            /*return*/\n            , Estimate.createEstimateInstanceFromProperties(estimateProperties)];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees to reveal the current account\r\n   *\r\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation or undefined if the account is already revealed\r\n   *\r\n   * @param Estimate\r\n   */\n\n\n  RPCEstimateProvider.prototype.reveal = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var pkh, DEFAULT_PARAMS, op, _a, _b, estimateProperties;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 1:\n            pkh = _c.sent();\n            return [4\n            /*yield*/\n            , this.isAccountRevealRequired(pkh)];\n\n          case 2:\n            if (!_c.sent()) return [3\n            /*break*/\n            , 7];\n            return [4\n            /*yield*/\n            , this.getAccountLimits(pkh)];\n\n          case 3:\n            DEFAULT_PARAMS = _c.sent();\n            _a = createRevealOperation;\n            _b = [__assign(__assign({}, params), DEFAULT_PARAMS), pkh];\n            return [4\n            /*yield*/\n            , this.signer.publicKey()];\n\n          case 4:\n            return [4\n            /*yield*/\n            , _a.apply(void 0, _b.concat([_c.sent()]))];\n\n          case 5:\n            op = _c.sent();\n            return [4\n            /*yield*/\n            , this.prepareEstimate({\n              operation: op,\n              source: pkh\n            })];\n\n          case 6:\n            estimateProperties = _c.sent();\n            return [2\n            /*return*/\n            , Estimate.createEstimateInstanceFromProperties(estimateProperties)];\n\n          case 7:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  RPCEstimateProvider.prototype.addRevealOp = function (op, pkh) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, _b, _c, _d;\n\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            _b = (_a = op).unshift;\n            _c = createRevealOperation;\n            _d = [__assign({\n              fee: DEFAULT_FEE.REVEAL,\n              gasLimit: DEFAULT_GAS_LIMIT.REVEAL,\n              storageLimit: DEFAULT_STORAGE_LIMIT.REVEAL\n            }), pkh];\n            return [4\n            /*yield*/\n            , this.signer.publicKey()];\n\n          case 1:\n            return [4\n            /*yield*/\n            , _c.apply(void 0, _d.concat([_e.sent()]))];\n\n          case 2:\n            _b.apply(_a, [_e.sent()]);\n\n            return [2\n            /*return*/\n            , op];\n        }\n      });\n    });\n  };\n\n  return RPCEstimateProvider;\n}(OperationEmitter);\n\nvar BatchOperation =\n/** @class */\nfunction (_super) {\n  __extends(BatchOperation, _super);\n\n  function BatchOperation(hash, params, source, raw, results, context) {\n    var _this = _super.call(this, hash, raw, results, context) || this;\n\n    _this.params = params;\n    _this.source = source;\n    return _this;\n  }\n\n  BatchOperation.prototype.sumProp = function (arr, prop) {\n    return arr.reduce(function (prev, current) {\n      return prop in current ? Number(current[prop]) + prev : prev;\n    }, 0);\n  };\n\n  Object.defineProperty(BatchOperation.prototype, \"status\", {\n    get: function () {\n      return this.results.filter(function (result) {\n        return BATCH_KINDS.indexOf(result.kind) !== -1;\n      }).map(function (result) {\n        if (hasMetadataWithResult(result)) {\n          return result.metadata.operation_result.status;\n        } else {\n          return 'unknown';\n        }\n      })[0] || 'unknown';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BatchOperation.prototype, \"fee\", {\n    get: function () {\n      return this.sumProp(this.params, 'fee');\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BatchOperation.prototype, \"gasLimit\", {\n    get: function () {\n      return this.sumProp(this.params, 'gas_limit');\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BatchOperation.prototype, \"storageLimit\", {\n    get: function () {\n      return this.sumProp(this.params, 'storage_limit');\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BatchOperation.prototype, \"consumedGas\", {\n    get: function () {\n      return String(this.sumProp(flattenOperationResult({\n        contents: this.results\n      }), 'consumed_gas'));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BatchOperation.prototype, \"storageDiff\", {\n    get: function () {\n      return String(this.sumProp(flattenOperationResult({\n        contents: this.results\n      }), 'paid_storage_size_diff'));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BatchOperation.prototype, \"errors\", {\n    get: function () {\n      return flattenErrors({\n        contents: this.results\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return BatchOperation;\n}(Operation);\n\nvar BATCH_KINDS = [OpKind.ACTIVATION, OpKind.ORIGINATION, OpKind.TRANSACTION, OpKind.DELEGATION];\n\nvar OperationBatch =\n/** @class */\nfunction (_super) {\n  __extends(OperationBatch, _super);\n\n  function OperationBatch(context, estimator) {\n    var _this = _super.call(this, context) || this;\n\n    _this.estimator = estimator;\n    _this.operations = [];\n    return _this;\n  }\n  /**\r\n   *\r\n   * @description Add a transaction operation to the batch\r\n   *\r\n   * @param params Transfer operation parameter\r\n   */\n\n\n  OperationBatch.prototype.withTransfer = function (params) {\n    this.operations.push(__assign({\n      kind: OpKind.TRANSACTION\n    }, params));\n    return this;\n  };\n  /**\r\n   *\r\n   * @description Add a transaction operation to the batch\r\n   *\r\n   * @param params Transfer operation parameter\r\n   */\n\n\n  OperationBatch.prototype.withContractCall = function (params) {\n    return this.withTransfer(params.toTransferParams());\n  };\n  /**\r\n   *\r\n   * @description Add a delegation operation to the batch\r\n   *\r\n   * @param params Delegation operation parameter\r\n   */\n\n\n  OperationBatch.prototype.withDelegation = function (params) {\n    this.operations.push(__assign({\n      kind: OpKind.DELEGATION\n    }, params));\n    return this;\n  };\n  /**\r\n   *\r\n   * @description Add an activation operation to the batch\r\n   *\r\n   * @param params Activation operation parameter\r\n   */\n\n\n  OperationBatch.prototype.withActivation = function (_a) {\n    var pkh = _a.pkh,\n        secret = _a.secret;\n    this.operations.push({\n      kind: OpKind.ACTIVATION,\n      pkh: pkh,\n      secret: secret\n    });\n    return this;\n  };\n  /**\r\n   *\r\n   * @description Add an origination operation to the batch\r\n   *\r\n   * @param params Origination operation parameter\r\n   */\n\n\n  OperationBatch.prototype.withOrigination = function (params) {\n    this.operations.push(__assign({\n      kind: OpKind.ORIGINATION\n    }, params));\n    return this;\n  };\n\n  OperationBatch.prototype.getRPCOp = function (param) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, _b;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _a = param.kind;\n\n            switch (_a) {\n              case OpKind.TRANSACTION:\n                return [3\n                /*break*/\n                , 1];\n\n              case OpKind.ORIGINATION:\n                return [3\n                /*break*/\n                , 2];\n\n              case OpKind.DELEGATION:\n                return [3\n                /*break*/\n                , 4];\n\n              case OpKind.ACTIVATION:\n                return [3\n                /*break*/\n                , 5];\n            }\n\n            return [3\n            /*break*/\n            , 6];\n\n          case 1:\n            return [2\n            /*return*/\n            , createTransferOperation(__assign({}, param))];\n\n          case 2:\n            _b = createOriginationOperation;\n            return [4\n            /*yield*/\n            , this.context.parser.prepareCodeOrigination(__assign({}, param))];\n\n          case 3:\n            return [2\n            /*return*/\n            , _b.apply(void 0, [_c.sent()])];\n\n          case 4:\n            return [2\n            /*return*/\n            , createSetDelegateOperation(__assign({}, param))];\n\n          case 5:\n            return [2\n            /*return*/\n            , __assign({}, param)];\n\n          case 6:\n            throw new Error(\"Unsupported operation kind: \" + param.kind);\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array\r\n   *\r\n   * @param params Operations parameter\r\n   */\n\n\n  OperationBatch.prototype.with = function (params) {\n    var e_1, _a;\n\n    try {\n      for (var params_1 = __values(params), params_1_1 = params_1.next(); !params_1_1.done; params_1_1 = params_1.next()) {\n        var param = params_1_1.value;\n\n        switch (param.kind) {\n          case OpKind.TRANSACTION:\n            this.withTransfer(param);\n            break;\n\n          case OpKind.ORIGINATION:\n            this.withOrigination(param);\n            break;\n\n          case OpKind.DELEGATION:\n            this.withDelegation(param);\n            break;\n\n          case OpKind.ACTIVATION:\n            this.withActivation(param);\n            break;\n\n          default:\n            throw new Error(\"Unsupported operation kind: \" + param.kind);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (params_1_1 && !params_1_1.done && (_a = params_1.return)) _a.call(params_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   *\r\n   * @description Forge and Inject the operation batch\r\n   *\r\n   * @param params Optionally specify the source of the operation\r\n   */\n\n\n  OperationBatch.prototype.send = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var publicKeyHash, publicKey, estimates, revealNeeded, i, ops, _a, _b, op, estimated, _c, _d, e_2_1, reveal, estimatedReveal, _e, _f, source, prepared, forgedBytes, signedOperation, opResponse, hash;\n\n      var e_2, _g;\n\n      var _this = this;\n\n      return __generator(this, function (_h) {\n        switch (_h.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 1:\n            publicKeyHash = _h.sent();\n            return [4\n            /*yield*/\n            , this.signer.publicKey()];\n\n          case 2:\n            publicKey = _h.sent();\n            return [4\n            /*yield*/\n            , this.estimator.batch(this.operations)];\n\n          case 3:\n            estimates = _h.sent();\n            return [4\n            /*yield*/\n            , this.isRevealOpNeeded(this.operations, publicKeyHash)];\n\n          case 4:\n            revealNeeded = _h.sent();\n            i = revealNeeded ? 1 : 0;\n            ops = [];\n            _h.label = 5;\n\n          case 5:\n            _h.trys.push([5, 13, 14, 15]);\n\n            _a = __values(this.operations), _b = _a.next();\n            _h.label = 6;\n\n          case 6:\n            if (!!_b.done) return [3\n            /*break*/\n            , 12];\n            op = _b.value;\n            if (!isOpWithFee(op)) return [3\n            /*break*/\n            , 9];\n            return [4\n            /*yield*/\n            , this.estimate(op, function () {\n              return __awaiter(_this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                  return [2\n                  /*return*/\n                  , estimates[i]];\n                });\n              });\n            })];\n\n          case 7:\n            estimated = _h.sent();\n            _d = (_c = ops).push;\n            return [4\n            /*yield*/\n            , this.getRPCOp(__assign(__assign({}, op), estimated))];\n\n          case 8:\n            _d.apply(_c, [_h.sent()]);\n\n            return [3\n            /*break*/\n            , 10];\n\n          case 9:\n            ops.push(__assign({}, op));\n            _h.label = 10;\n\n          case 10:\n            i++;\n            _h.label = 11;\n\n          case 11:\n            _b = _a.next();\n            return [3\n            /*break*/\n            , 6];\n\n          case 12:\n            return [3\n            /*break*/\n            , 15];\n\n          case 13:\n            e_2_1 = _h.sent();\n            e_2 = {\n              error: e_2_1\n            };\n            return [3\n            /*break*/\n            , 15];\n\n          case 14:\n            try {\n              if (_b && !_b.done && (_g = _a.return)) _g.call(_a);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 15:\n            if (!revealNeeded) return [3\n            /*break*/\n            , 18];\n            reveal = {\n              kind: OpKind.REVEAL\n            };\n            return [4\n            /*yield*/\n            , this.estimate(reveal, function () {\n              return __awaiter(_this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                  return [2\n                  /*return*/\n                  , estimates[0]];\n                });\n              });\n            })];\n\n          case 16:\n            estimatedReveal = _h.sent();\n            _f = (_e = ops).unshift;\n            return [4\n            /*yield*/\n            , createRevealOperation(__assign({}, estimatedReveal), publicKeyHash, publicKey)];\n\n          case 17:\n            _f.apply(_e, [_h.sent()]);\n\n            _h.label = 18;\n\n          case 18:\n            source = params && params.source || publicKeyHash;\n            return [4\n            /*yield*/\n            , this.prepareOpAndSimulation({\n              operation: ops,\n              source: source\n            })];\n\n          case 19:\n            prepared = _h.sent();\n            return [4\n            /*yield*/\n            , this.forge(prepared.preparedOp)];\n\n          case 20:\n            forgedBytes = _h.sent();\n            return [4\n            /*yield*/\n            , this.signOperation(forgedBytes)];\n\n          case 21:\n            signedOperation = _h.sent();\n            return [4\n            /*yield*/\n            , this.preValidate(prepared, signedOperation)];\n\n          case 22:\n            opResponse = _h.sent();\n            return [4\n            /*yield*/\n            , this.injectOperation(signedOperation.opbytes)];\n\n          case 23:\n            hash = _h.sent();\n            return [2\n            /*return*/\n            , new BatchOperation(hash, ops, source, forgedBytes, opResponse, this.context.clone())];\n        }\n      });\n    });\n  };\n\n  return OperationBatch;\n}(OperationEmitter);\n\nvar RPCBatchProvider =\n/** @class */\nfunction () {\n  function RPCBatchProvider(context, estimator) {\n    this.context = context;\n    this.estimator = estimator;\n  }\n  /***\r\n   *\r\n   * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch\r\n   *\r\n   * @param params List of operation to batch together\r\n   */\n\n\n  RPCBatchProvider.prototype.batch = function (params) {\n    var batch = new OperationBatch(this.context, this.estimator);\n\n    if (Array.isArray(params)) {\n      batch.with(params);\n    }\n\n    return batch;\n  };\n\n  return RPCBatchProvider;\n}();\n/**\r\n * @description Delegation operation provide utility function to fetch newly issued delegation\r\n *\r\n * @warn Currently support only one delegation per operation\r\n */\n\n\nvar DelegateOperation =\n/** @class */\nfunction (_super) {\n  __extends(DelegateOperation, _super);\n\n  function DelegateOperation(hash, params, source, raw, results, context) {\n    var _this = _super.call(this, hash, raw, results, context) || this;\n\n    _this.params = params;\n    _this.source = source;\n    return _this;\n  }\n\n  Object.defineProperty(DelegateOperation.prototype, \"operationResults\", {\n    get: function () {\n      var delegationOp = Array.isArray(this.results) && this.results.find(function (op) {\n        return op.kind === 'delegation';\n      });\n      var result = delegationOp && delegationOp.metadata && delegationOp.metadata.operation_result;\n      return result ? result : undefined;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DelegateOperation.prototype, \"status\", {\n    get: function () {\n      var operationResults = this.operationResults;\n\n      if (operationResults) {\n        return operationResults.status;\n      } else {\n        return 'unknown';\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DelegateOperation.prototype, \"delegate\", {\n    get: function () {\n      return this.delegate;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DelegateOperation.prototype, \"isRegisterOperation\", {\n    get: function () {\n      return this.delegate === this.source;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DelegateOperation.prototype, \"fee\", {\n    get: function () {\n      return this.params.fee;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DelegateOperation.prototype, \"gasLimit\", {\n    get: function () {\n      return this.params.gas_limit;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DelegateOperation.prototype, \"storageLimit\", {\n    get: function () {\n      return this.params.storage_limit;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DelegateOperation.prototype, \"consumedGas\", {\n    get: function () {\n      var consumedGas = this.operationResults && this.operationResults.consumed_gas;\n      return consumedGas ? consumedGas : undefined;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DelegateOperation.prototype, \"errors\", {\n    get: function () {\n      return this.operationResults && this.operationResults.errors;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return DelegateOperation;\n}(Operation);\n/**\r\n * @description Origination operation provide utility function to fetch newly originated contract\r\n *\r\n * @warn Currently support only one origination per operation\r\n */\n\n\nvar OriginationOperation =\n/** @class */\nfunction (_super) {\n  __extends(OriginationOperation, _super);\n\n  function OriginationOperation(hash, params, raw, results, context, contractProvider) {\n    var _this = _super.call(this, hash, raw, results, context) || this;\n\n    _this.params = params;\n    _this.contractProvider = contractProvider;\n    var originatedContracts = _this.operationResults && _this.operationResults.originated_contracts;\n\n    if (Array.isArray(originatedContracts)) {\n      _this.contractAddress = originatedContracts[0];\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(OriginationOperation.prototype, \"status\", {\n    get: function () {\n      var operationResults = this.operationResults;\n\n      if (operationResults) {\n        return operationResults.status;\n      } else {\n        return 'unknown';\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(OriginationOperation.prototype, \"operationResults\", {\n    get: function () {\n      var originationOp = Array.isArray(this.results) && this.results.find(function (op) {\n        return op.kind === 'origination';\n      });\n      var result = originationOp && hasMetadataWithResult(originationOp) && originationOp.metadata.operation_result;\n      return result ? result : undefined;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(OriginationOperation.prototype, \"fee\", {\n    get: function () {\n      return this.params.fee;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(OriginationOperation.prototype, \"gasLimit\", {\n    get: function () {\n      return this.params.gas_limit;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(OriginationOperation.prototype, \"storageLimit\", {\n    get: function () {\n      return this.params.storage_limit;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(OriginationOperation.prototype, \"consumedGas\", {\n    get: function () {\n      var consumedGas = this.operationResults && this.operationResults.consumed_gas;\n      return consumedGas ? consumedGas : undefined;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(OriginationOperation.prototype, \"storageDiff\", {\n    get: function () {\n      var storageDiff = this.operationResults && this.operationResults.paid_storage_size_diff;\n      return storageDiff ? storageDiff : undefined;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(OriginationOperation.prototype, \"storageSize\", {\n    get: function () {\n      var storageSize = this.operationResults && this.operationResults.storage_size;\n      return storageSize ? storageSize : undefined;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(OriginationOperation.prototype, \"errors\", {\n    get: function () {\n      return this.operationResults && this.operationResults.errors;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * @description Provide the contract abstract of the newly originated contract\r\n   */\n\n  OriginationOperation.prototype.contract = function (confirmations, interval, timeout) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.contractAddress) {\n              throw new Error('No contract was originated in this operation');\n            }\n\n            return [4\n            /*yield*/\n            , this.confirmation(confirmations, interval, timeout)];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , this.contractProvider.at(this.contractAddress)];\n        }\n      });\n    });\n  };\n\n  return OriginationOperation;\n}(Operation);\n/**\r\n * @description Reveal operation provides utility functions to fetch a newly issued revelation\r\n */\n\n\nvar RevealOperation =\n/** @class */\nfunction (_super) {\n  __extends(RevealOperation, _super);\n\n  function RevealOperation(hash, params, source, raw, results, context) {\n    var _this = _super.call(this, hash, raw, results, context) || this;\n\n    _this.params = params;\n    _this.source = source;\n    return _this;\n  }\n\n  Object.defineProperty(RevealOperation.prototype, \"operationResults\", {\n    get: function () {\n      var revealOp = Array.isArray(this.results) && this.results.find(function (op) {\n        return op.kind === 'reveal';\n      });\n      return revealOp ? [revealOp] : [];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RevealOperation.prototype, \"status\", {\n    get: function () {\n      var operationResults = this.operationResults;\n      var txResult = operationResults[0];\n\n      if (txResult) {\n        return txResult.metadata.operation_result.status;\n      } else {\n        return 'unknown';\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RevealOperation.prototype, \"fee\", {\n    get: function () {\n      return this.params.fee;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RevealOperation.prototype, \"gasLimit\", {\n    get: function () {\n      return this.params.gas_limit;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RevealOperation.prototype, \"storageLimit\", {\n    get: function () {\n      return this.params.storage_limit;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RevealOperation.prototype, \"publicKey\", {\n    get: function () {\n      return this.params.public_key;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  RevealOperation.prototype.sumProp = function (arr, prop) {\n    return arr.reduce(function (prev, current) {\n      return prop in current ? Number(current[prop]) + prev : prev;\n    }, 0);\n  };\n\n  Object.defineProperty(RevealOperation.prototype, \"consumedGas\", {\n    get: function () {\n      return String(this.sumProp(flattenOperationResult({\n        contents: this.operationResults\n      }), 'consumed_gas'));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RevealOperation.prototype, \"storageDiff\", {\n    get: function () {\n      return String(this.sumProp(flattenOperationResult({\n        contents: this.operationResults\n      }), 'paid_storage_size_diff'));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RevealOperation.prototype, \"storageSize\", {\n    get: function () {\n      return String(this.sumProp(flattenOperationResult({\n        contents: this.operationResults\n      }), 'storage_size'));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RevealOperation.prototype, \"errors\", {\n    get: function () {\n      return flattenErrors({\n        contents: this.operationResults\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return RevealOperation;\n}(Operation);\n/**\r\n * @description Transaction operation provides utility functions to fetch a newly issued transaction\r\n *\r\n * @warn Currently supports one transaction per operation\r\n */\n\n\nvar TransactionOperation =\n/** @class */\nfunction (_super) {\n  __extends(TransactionOperation, _super);\n\n  function TransactionOperation(hash, params, source, raw, results, context) {\n    var _this = _super.call(this, hash, raw, results, context) || this;\n\n    _this.params = params;\n    _this.source = source;\n    return _this;\n  }\n\n  Object.defineProperty(TransactionOperation.prototype, \"operationResults\", {\n    get: function () {\n      var transactionOp = Array.isArray(this.results) && this.results.find(function (op) {\n        return op.kind === 'transaction';\n      });\n      return transactionOp ? [transactionOp] : [];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"status\", {\n    get: function () {\n      var operationResults = this.operationResults;\n      var txResult = operationResults[0];\n\n      if (txResult) {\n        return txResult.metadata.operation_result.status;\n      } else {\n        return 'unknown';\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"amount\", {\n    get: function () {\n      return new BigNumber(this.params.amount);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"destination\", {\n    get: function () {\n      return this.params.destination;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"fee\", {\n    get: function () {\n      return this.params.fee;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"gasLimit\", {\n    get: function () {\n      return this.params.gas_limit;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"storageLimit\", {\n    get: function () {\n      return this.params.storage_limit;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  TransactionOperation.prototype.sumProp = function (arr, prop) {\n    return arr.reduce(function (prev, current) {\n      return prop in current ? Number(current[prop]) + prev : prev;\n    }, 0);\n  };\n\n  Object.defineProperty(TransactionOperation.prototype, \"consumedGas\", {\n    get: function () {\n      return String(this.sumProp(flattenOperationResult({\n        contents: this.operationResults\n      }), 'consumed_gas'));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"storageDiff\", {\n    get: function () {\n      return String(this.sumProp(flattenOperationResult({\n        contents: this.operationResults\n      }), 'paid_storage_size_diff'));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"storageSize\", {\n    get: function () {\n      return String(this.sumProp(flattenOperationResult({\n        contents: this.operationResults\n      }), 'storage_size'));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TransactionOperation.prototype, \"errors\", {\n    get: function () {\n      return flattenErrors({\n        contents: this.operationResults\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return TransactionOperation;\n}(Operation);\n\nvar setDelegate = function (key) {\n  return [{\n    prim: 'DROP'\n  }, {\n    prim: 'NIL',\n    args: [{\n      prim: 'operation'\n    }]\n  }, {\n    prim: 'PUSH',\n    args: [{\n      prim: 'key_hash'\n    }, {\n      string: key\n    }]\n  }, {\n    prim: 'SOME'\n  }, {\n    prim: 'SET_DELEGATE'\n  }, {\n    prim: 'CONS'\n  }];\n};\n\nvar transferImplicit = function (key, mutez) {\n  return [{\n    prim: 'DROP'\n  }, {\n    prim: 'NIL',\n    args: [{\n      prim: 'operation'\n    }]\n  }, {\n    prim: 'PUSH',\n    args: [{\n      prim: 'key_hash'\n    }, {\n      string: key\n    }]\n  }, {\n    prim: 'IMPLICIT_ACCOUNT'\n  }, {\n    prim: 'PUSH',\n    args: [{\n      prim: 'mutez'\n    }, {\n      int: \"\" + mutez\n    }]\n  }, {\n    prim: 'UNIT'\n  }, {\n    prim: 'TRANSFER_TOKENS'\n  }, {\n    prim: 'CONS'\n  }];\n};\n\nvar removeDelegate = function () {\n  return [{\n    prim: 'DROP'\n  }, {\n    prim: 'NIL',\n    args: [{\n      prim: 'operation'\n    }]\n  }, {\n    prim: 'NONE',\n    args: [{\n      prim: 'key_hash'\n    }]\n  }, {\n    prim: 'SET_DELEGATE'\n  }, {\n    prim: 'CONS'\n  }];\n};\n\nvar transferToContract = function (key, amount) {\n  return [{\n    prim: 'DROP'\n  }, {\n    prim: 'NIL',\n    args: [{\n      prim: 'operation'\n    }]\n  }, {\n    prim: 'PUSH',\n    args: [{\n      prim: 'address'\n    }, {\n      string: key\n    }]\n  }, {\n    prim: 'CONTRACT',\n    args: [{\n      prim: 'unit'\n    }]\n  }, [{\n    prim: 'IF_NONE',\n    args: [[[{\n      prim: 'UNIT'\n    }, {\n      prim: 'FAILWITH'\n    }]], []]\n  }], {\n    prim: 'PUSH',\n    args: [{\n      prim: 'mutez'\n    }, {\n      int: \"\" + amount\n    }]\n  }, {\n    prim: 'UNIT'\n  }, {\n    prim: 'TRANSFER_TOKENS'\n  }, {\n    prim: 'CONS'\n  }];\n};\n\nvar MANAGER_LAMBDA = {\n  setDelegate: setDelegate,\n  removeDelegate: removeDelegate,\n  transferImplicit: transferImplicit,\n  transferToContract: transferToContract\n};\nvar code = [{\n  prim: 'parameter',\n  args: [{\n    prim: 'lambda',\n    args: [{\n      prim: 'unit'\n    }, {\n      prim: 'pair',\n      args: [{\n        prim: 'list',\n        args: [{\n          prim: 'operation'\n        }]\n      }, {\n        prim: 'unit'\n      }]\n    }]\n  }]\n}, {\n  prim: 'storage',\n  args: [{\n    prim: 'unit'\n  }]\n}, {\n  prim: 'code',\n  args: [[{\n    prim: 'CAR'\n  }, {\n    prim: 'UNIT'\n  }, {\n    prim: 'EXEC'\n  }]]\n}];\nvar storage = 'Unit';\nvar VIEW_LAMBDA = {\n  code: code,\n  storage: storage\n};\n\nfunction compose(functioncomposer1, functioncomposer2) {\n  return function (contractAbstraction, context) {\n    return functioncomposer2(functioncomposer1(contractAbstraction, context), context);\n  };\n}\n\nvar WalletOperationBatch =\n/** @class */\nfunction () {\n  function WalletOperationBatch(walletProvider, context) {\n    this.walletProvider = walletProvider;\n    this.context = context;\n    this.operations = [];\n  }\n  /**\r\n   *\r\n   * @description Add a transaction operation to the batch\r\n   *\r\n   * @param params Transfer operation parameter\r\n   */\n\n\n  WalletOperationBatch.prototype.withTransfer = function (params) {\n    this.operations.push(__assign({\n      kind: OpKind.TRANSACTION\n    }, params));\n    return this;\n  };\n  /**\r\n   *\r\n   * @description Add a transaction operation to the batch\r\n   *\r\n   * @param params Transfer operation parameter\r\n   */\n\n\n  WalletOperationBatch.prototype.withContractCall = function (params) {\n    return this.withTransfer(params.toTransferParams());\n  };\n  /**\r\n   *\r\n   * @description Add a delegation operation to the batch\r\n   *\r\n   * @param params Delegation operation parameter\r\n   */\n\n\n  WalletOperationBatch.prototype.withDelegation = function (params) {\n    this.operations.push(__assign({\n      kind: OpKind.DELEGATION\n    }, params));\n    return this;\n  };\n  /**\r\n   *\r\n   * @description Add an origination operation to the batch\r\n   *\r\n   * @param params Origination operation parameter\r\n   */\n\n\n  WalletOperationBatch.prototype.withOrigination = function (params) {\n    this.operations.push(__assign({\n      kind: OpKind.ORIGINATION\n    }, params));\n    return this;\n  };\n\n  WalletOperationBatch.prototype.mapOperation = function (param) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, _b, _c;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            _a = param.kind;\n\n            switch (_a) {\n              case OpKind.TRANSACTION:\n                return [3\n                /*break*/\n                , 1];\n\n              case OpKind.ORIGINATION:\n                return [3\n                /*break*/\n                , 2];\n\n              case OpKind.DELEGATION:\n                return [3\n                /*break*/\n                , 4];\n            }\n\n            return [3\n            /*break*/\n            , 5];\n\n          case 1:\n            return [2\n            /*return*/\n            , this.walletProvider.mapTransferParamsToWalletParams(__assign({}, param))];\n\n          case 2:\n            _c = (_b = this.walletProvider).mapOriginateParamsToWalletParams;\n            return [4\n            /*yield*/\n            , this.context.parser.prepareCodeOrigination(__assign({}, param))];\n\n          case 3:\n            return [2\n            /*return*/\n            , _c.apply(_b, [_d.sent()])];\n\n          case 4:\n            return [2\n            /*return*/\n            , this.walletProvider.mapDelegateParamsToWalletParams(__assign({}, param))];\n\n          case 5:\n            throw new Error(\"Unsupported operation kind: \" + param.kind);\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array\r\n   *\r\n   * @param params Operations parameter\r\n   */\n\n\n  WalletOperationBatch.prototype.with = function (params) {\n    var e_1, _a;\n\n    try {\n      for (var params_1 = __values(params), params_1_1 = params_1.next(); !params_1_1.done; params_1_1 = params_1.next()) {\n        var param = params_1_1.value;\n\n        switch (param.kind) {\n          case OpKind.TRANSACTION:\n            this.withTransfer(param);\n            break;\n\n          case OpKind.ORIGINATION:\n            this.withOrigination(param);\n            break;\n\n          case OpKind.DELEGATION:\n            this.withDelegation(param);\n            break;\n\n          default:\n            throw new Error(\"Unsupported operation kind: \" + param.kind);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (params_1_1 && !params_1_1.done && (_a = params_1.return)) _a.call(params_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   *\r\n   * @description Submit batch operation to wallet\r\n   *\r\n   */\n\n\n  WalletOperationBatch.prototype.send = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var ops, _a, _b, op, _c, _d, e_2_1, opHash;\n\n      var e_2, _e;\n\n      return __generator(this, function (_f) {\n        switch (_f.label) {\n          case 0:\n            ops = [];\n            _f.label = 1;\n\n          case 1:\n            _f.trys.push([1, 6, 7, 8]);\n\n            _a = __values(this.operations), _b = _a.next();\n            _f.label = 2;\n\n          case 2:\n            if (!!_b.done) return [3\n            /*break*/\n            , 5];\n            op = _b.value;\n            _d = (_c = ops).push;\n            return [4\n            /*yield*/\n            , this.mapOperation(op)];\n\n          case 3:\n            _d.apply(_c, [_f.sent()]);\n\n            _f.label = 4;\n\n          case 4:\n            _b = _a.next();\n            return [3\n            /*break*/\n            , 2];\n\n          case 5:\n            return [3\n            /*break*/\n            , 8];\n\n          case 6:\n            e_2_1 = _f.sent();\n            e_2 = {\n              error: e_2_1\n            };\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            try {\n              if (_b && !_b.done && (_e = _a.return)) _e.call(_a);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 8:\n            return [4\n            /*yield*/\n            , this.walletProvider.sendOperations(ops)];\n\n          case 9:\n            opHash = _f.sent();\n            return [2\n            /*return*/\n            , this.context.operationFactory.createOperation(opHash)];\n        }\n      });\n    });\n  };\n\n  return WalletOperationBatch;\n}();\n\nvar Wallet =\n/** @class */\nfunction () {\n  function Wallet(context) {\n    this.context = context;\n\n    this.walletCommand = function (send) {\n      return {\n        send: send\n      };\n    };\n  }\n\n  Object.defineProperty(Wallet.prototype, \"walletProvider\", {\n    get: function () {\n      return this.context.walletProvider;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * @description Retrieve the PKH of the account that is currently in use by the wallet\r\n   *\r\n   * @param option Option to use while fetching the PKH.\r\n   * If forceRefetch is specified the wallet provider implementation will refetch the PKH from the wallet\r\n   */\n\n  Wallet.prototype.pkh = function (_a) {\n    var _b = _a === void 0 ? {} : _a,\n        forceRefetch = _b.forceRefetch;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _c;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            if (!(!this._pkh || forceRefetch)) return [3\n            /*break*/\n            , 2];\n            _c = this;\n            return [4\n            /*yield*/\n            , this.walletProvider.getPKH()];\n\n          case 1:\n            _c._pkh = _d.sent();\n            _d.label = 2;\n\n          case 2:\n            return [2\n            /*return*/\n            , this._pkh];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Originate a new contract according to the script in parameters.\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   * @param originateParams Originate operation parameter\r\n   */\n\n\n  Wallet.prototype.originate = function (params) {\n    var _this = this;\n\n    return this.walletCommand(function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var mappedParams, _a, _b, opHash, _c;\n\n        return __generator(this, function (_d) {\n          switch (_d.label) {\n            case 0:\n              _b = (_a = this.walletProvider).mapOriginateParamsToWalletParams;\n              return [4\n              /*yield*/\n              , this.context.parser.prepareCodeOrigination(__assign({}, params))];\n\n            case 1:\n              return [4\n              /*yield*/\n              , _b.apply(_a, [_d.sent()])];\n\n            case 2:\n              mappedParams = _d.sent();\n              return [4\n              /*yield*/\n              , this.walletProvider.sendOperations([mappedParams])];\n\n            case 3:\n              opHash = _d.sent();\n              if (!!this.context.proto) return [3\n              /*break*/\n              , 5];\n              _c = this.context;\n              return [4\n              /*yield*/\n              , this.context.rpc.getBlock()];\n\n            case 4:\n              _c.proto = _d.sent().protocol;\n              _d.label = 5;\n\n            case 5:\n              return [2\n              /*return*/\n              , this.context.operationFactory.createOriginationOperation(opHash)];\n          }\n        });\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Set the delegate for a contract.\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   * @param delegateParams operation parameter\r\n   */\n\n\n  Wallet.prototype.setDelegate = function (params) {\n    var _this = this;\n\n    return this.walletCommand(function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var mappedParams, opHash;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.walletProvider.mapDelegateParamsToWalletParams(__assign({}, params))];\n\n            case 1:\n              mappedParams = _a.sent();\n              return [4\n              /*yield*/\n              , this.walletProvider.sendOperations([mappedParams])];\n\n            case 2:\n              opHash = _a.sent();\n              return [2\n              /*return*/\n              , this.context.operationFactory.createDelegationOperation(opHash)];\n          }\n        });\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Register the current address as delegate.\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   */\n\n\n  Wallet.prototype.registerDelegate = function () {\n    var _this = this;\n\n    return this.walletCommand(function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var mappedParams, _a, _b, opHash;\n\n        var _c;\n\n        return __generator(this, function (_d) {\n          switch (_d.label) {\n            case 0:\n              _b = (_a = this.walletProvider).mapDelegateParamsToWalletParams;\n              _c = {};\n              return [4\n              /*yield*/\n              , this.pkh()];\n\n            case 1:\n              return [4\n              /*yield*/\n              , _b.apply(_a, [(_c.delegate = _d.sent(), _c)])];\n\n            case 2:\n              mappedParams = _d.sent();\n              return [4\n              /*yield*/\n              , this.walletProvider.sendOperations([mappedParams])];\n\n            case 3:\n              opHash = _d.sent();\n              return [2\n              /*return*/\n              , this.context.operationFactory.createDelegationOperation(opHash)];\n          }\n        });\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Transfer tezos tokens from current address to a specific address or call a smart contract.\r\n   *\r\n   * @returns A wallet command from which we can send the operation to the wallet\r\n   *\r\n   * @param params operation parameter\r\n   */\n\n\n  Wallet.prototype.transfer = function (params) {\n    var _this = this;\n\n    return this.walletCommand(function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var mappedParams, opHash;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.walletProvider.mapTransferParamsToWalletParams(params)];\n\n            case 1:\n              mappedParams = _a.sent();\n              return [4\n              /*yield*/\n              , this.walletProvider.sendOperations([mappedParams])];\n\n            case 2:\n              opHash = _a.sent();\n              return [2\n              /*return*/\n              , this.context.operationFactory.createTransactionOperation(opHash)];\n          }\n        });\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Create a batch of operation\r\n   *\r\n   * @returns A batch object from which we can add more operation or send a command to the wallet to execute the batch\r\n   *\r\n   * @param params List of operation to initialize the batch with\r\n   */\n\n\n  Wallet.prototype.batch = function (params) {\n    var batch = new WalletOperationBatch(this.walletProvider, this.context);\n\n    if (Array.isArray(params)) {\n      batch.with(params);\n    }\n\n    return batch;\n  };\n  /**\r\n   *\r\n   * @description Create an smart contract abstraction for the address specified. Calling entrypoints with the returned\r\n   * smart contract abstraction will leverage the wallet provider to make smart contract calls\r\n   *\r\n   * @param address Smart contract address\r\n   */\n\n\n  Wallet.prototype.at = function (address, contractAbstractionComposer) {\n    if (contractAbstractionComposer === void 0) {\n      contractAbstractionComposer = function (x) {\n        return x;\n      };\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var script, entrypoints, blockHeader, chainId, abs;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.context.rpc.getScript(address)];\n\n          case 1:\n            script = _a.sent();\n            return [4\n            /*yield*/\n            , this.context.rpc.getEntrypoints(address)];\n\n          case 2:\n            entrypoints = _a.sent();\n            return [4\n            /*yield*/\n            , this.context.rpc.getBlockHeader()];\n\n          case 3:\n            blockHeader = _a.sent();\n            chainId = blockHeader.chain_id;\n            abs = new ContractAbstraction(address, script, this, this.context.contract, entrypoints, chainId);\n            return [2\n            /*return*/\n            , contractAbstractionComposer(abs, this.context)];\n        }\n      });\n    });\n  };\n\n  return Wallet;\n}();\n\nvar LegacyWalletProvider =\n/** @class */\nfunction () {\n  function LegacyWalletProvider(context) {\n    this.context = context;\n  }\n\n  LegacyWalletProvider.prototype.getPKH = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.context.signer.publicKeyHash()];\n      });\n    });\n  };\n\n  LegacyWalletProvider.prototype.mapTransferParamsToWalletParams = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , attachKind(params, OpKind.TRANSACTION)];\n      });\n    });\n  };\n\n  LegacyWalletProvider.prototype.mapOriginateParamsToWalletParams = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , attachKind(params, OpKind.ORIGINATION)];\n      });\n    });\n  };\n\n  LegacyWalletProvider.prototype.mapDelegateParamsToWalletParams = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , attachKind(params, OpKind.DELEGATION)];\n      });\n    });\n  };\n\n  LegacyWalletProvider.prototype.sendOperations = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var op;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.context.batch.batch(params).send()];\n\n          case 1:\n            op = _a.sent();\n            return [2\n            /*return*/\n            , op.hash];\n        }\n      });\n    });\n  };\n\n  return LegacyWalletProvider;\n}();\n\nvar LambdaView =\n/** @class */\nfunction () {\n  function LambdaView(lambdaContract, viewContract, viewMethod, contractParameter) {\n    if (viewMethod === void 0) {\n      viewMethod = 'default';\n    }\n\n    if (contractParameter === void 0) {\n      contractParameter = {\n        prim: 'Unit'\n      };\n    }\n\n    this.lambdaContract = lambdaContract;\n    this.viewContract = viewContract;\n    this.viewMethod = viewMethod;\n    this.contractParameter = contractParameter;\n    this.voidLambda = this.createVoidLambda();\n  }\n\n  LambdaView.prototype.execute = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var ex_1, lastError, failedWith;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , this.lambdaContract.methods.default(this.voidLambda).send()];\n\n          case 1:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            ex_1 = _a.sent();\n\n            if (ex_1 instanceof TezosOperationError) {\n              lastError = ex_1.errors[ex_1.errors.length - 1];\n              failedWith = lastError.with;\n              return [2\n              /*return*/\n              , failedWith];\n            } else {\n              throw ex_1;\n            }\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  LambdaView.prototype.createVoidLambda = function () {\n    var _a = __read(this.getView(), 2),\n        parameter = _a[0],\n        callback = _a[1];\n\n    var contractArgs = [{\n      prim: 'pair',\n      args: [parameter, {\n        prim: 'contract',\n        args: [callback]\n      }]\n    }];\n\n    if (this.viewMethod === 'default') {\n      contractArgs = [{\n        string: '%default'\n      }].concat(contractArgs);\n    }\n\n    return [{\n      prim: 'PUSH',\n      args: [{\n        prim: 'mutez'\n      }, {\n        int: '0'\n      }]\n    }, {\n      prim: 'NONE',\n      args: [{\n        prim: 'key_hash'\n      }]\n    }, {\n      prim: 'CREATE_CONTRACT',\n      args: [[{\n        prim: 'parameter',\n        args: [callback]\n      }, {\n        prim: 'storage',\n        args: [{\n          prim: 'unit'\n        }]\n      }, {\n        prim: 'code',\n        args: [[{\n          prim: 'CAR'\n        }, {\n          prim: 'FAILWITH'\n        }]]\n      }]]\n    }, {\n      prim: 'DIP',\n      args: [[{\n        prim: 'DIP',\n        args: [[{\n          prim: 'LAMBDA',\n          args: [{\n            prim: 'pair',\n            args: [{\n              prim: 'address'\n            }, {\n              prim: 'unit'\n            }]\n          }, {\n            prim: 'pair',\n            args: [{\n              prim: 'list',\n              args: [{\n                prim: 'operation'\n              }]\n            }, {\n              prim: 'unit'\n            }]\n          }, [{\n            prim: 'CAR'\n          }, {\n            prim: 'CONTRACT',\n            args: [callback]\n          }, {\n            prim: 'IF_NONE',\n            args: [[{\n              prim: 'PUSH',\n              args: [{\n                prim: 'string'\n              }, {\n                string: \"Callback type unmatched\"\n              }]\n            }, {\n              prim: 'FAILWITH'\n            }], []]\n          }, {\n            prim: 'PUSH',\n            args: [parameter, this.contractParameter]\n          }, {\n            prim: 'PAIR'\n          }, {\n            prim: 'DIP',\n            args: [[{\n              prim: 'PUSH',\n              args: [{\n                prim: 'address'\n              }, {\n                string: this.viewContract.address + \"%\" + this.viewMethod\n              }]\n            }, {\n              prim: 'DUP'\n            }, {\n              prim: 'CONTRACT',\n              args: contractArgs\n            }, {\n              prim: 'IF_NONE',\n              args: [[{\n                prim: 'PUSH',\n                args: [{\n                  prim: 'string'\n                }, {\n                  string: \"Contract does not exist\"\n                }]\n              }, {\n                prim: 'FAILWITH'\n              }], [{\n                prim: 'DIP',\n                args: [[{\n                  prim: 'DROP'\n                }]]\n              }]]\n            }, {\n              prim: 'PUSH',\n              args: [{\n                prim: 'mutez'\n              }, {\n                int: '0'\n              }]\n            }]]\n          }, {\n            prim: 'TRANSFER_TOKENS'\n          }, {\n            prim: 'DIP',\n            args: [[{\n              prim: 'NIL',\n              args: [{\n                prim: 'operation'\n              }]\n            }]]\n          }, {\n            prim: 'CONS'\n          }, {\n            prim: 'DIP',\n            args: [[{\n              prim: 'UNIT'\n            }]]\n          }, {\n            prim: 'PAIR'\n          }]]\n        }]]\n      }, {\n        prim: 'APPLY'\n      }, {\n        prim: 'DIP',\n        args: [[{\n          prim: 'PUSH',\n          args: [{\n            prim: 'address'\n          }, {\n            string: this.lambdaContract.address\n          }]\n        }, {\n          prim: 'DUP'\n        }, {\n          prim: 'CONTRACT',\n          args: [{\n            prim: 'lambda',\n            args: [{\n              prim: 'unit'\n            }, {\n              prim: 'pair',\n              args: [{\n                prim: 'list',\n                args: [{\n                  prim: 'operation'\n                }]\n              }, {\n                prim: 'unit'\n              }]\n            }]\n          }]\n        }, {\n          prim: 'IF_NONE',\n          args: [[{\n            prim: 'PUSH',\n            args: [{\n              prim: 'string'\n            }, {\n              string: \"Contract does not exists\"\n            }]\n          }, {\n            prim: 'FAILWITH'\n          }], [{\n            prim: 'DIP',\n            args: [[{\n              prim: 'DROP'\n            }]]\n          }]]\n        }, {\n          prim: 'PUSH',\n          args: [{\n            prim: 'mutez'\n          }, {\n            int: '0'\n          }]\n        }]]\n      }, {\n        prim: 'TRANSFER_TOKENS'\n      }, {\n        prim: 'DIP',\n        args: [[{\n          prim: 'NIL',\n          args: [{\n            prim: 'operation'\n          }]\n        }]]\n      }, {\n        prim: 'CONS'\n      }]]\n    }, {\n      prim: 'CONS'\n    }, {\n      prim: 'DIP',\n      args: [[{\n        prim: 'UNIT'\n      }]]\n    }, {\n      prim: 'PAIR'\n    }];\n  };\n\n  LambdaView.prototype.getView = function () {\n    var entrypoints = this.viewContract.entrypoints.entrypoints;\n    var entrypoint = entrypoints[this.viewMethod];\n\n    if (!entrypoint) {\n      throw Error(\"Contract at \" + this.viewContract.address + \" does not have entrypoint: \" + this.viewMethod);\n    }\n\n    if (!('prim' in entrypoint) || !entrypoint.args) {\n      // TODO: Enhance this error message to be more descriptive\n      throw Error('Entrypoint args undefined');\n    }\n\n    var args = Array.from(entrypoint.args);\n\n    var _a = __read(args, 2),\n        parameter = _a[0],\n        callbackContract = _a[1];\n\n    if ('annots' in parameter) {\n      delete parameter['annots'];\n    }\n\n    if (!('prim' in callbackContract) || !callbackContract.args) {\n      // TODO: Enhance this error message to be more descriptive\n      throw Error('Callback contract args undefined');\n    }\n\n    var message;\n\n    if (entrypoint.prim !== 'pair') {\n      message = \"Expected {'prim': 'pair', ..} but found {'prim': \" + entrypoint.prim + \", ..}\";\n    } else if (args.length !== 2) {\n      message = \"Expected an Array of length 2, but found: \" + args;\n    } else if (callbackContract.prim !== 'contract') {\n      message = \"Expected a {prim: 'contract', ...}, but found: \" + callbackContract.prim;\n    } else if (callbackContract.args && callbackContract.args.length !== 1) {\n      message = \"Expected a single argument to 'contract', but found: \" + callbackContract.args;\n    }\n\n    if (message) throw Error(message);\n    return [parameter, callbackContract.args[0]];\n  };\n\n  return LambdaView;\n}();\n\nvar DEFAULT_SMART_CONTRACT_METHOD_NAME = 'default';\n/**\r\n * @description Utility class to send smart contract operation\r\n */\n\nvar ContractMethod =\n/** @class */\nfunction () {\n  function ContractMethod(provider, address, parameterSchema, name, args, isMultipleEntrypoint, isAnonymous) {\n    if (isMultipleEntrypoint === void 0) {\n      isMultipleEntrypoint = true;\n    }\n\n    if (isAnonymous === void 0) {\n      isAnonymous = false;\n    }\n\n    this.provider = provider;\n    this.address = address;\n    this.parameterSchema = parameterSchema;\n    this.name = name;\n    this.args = args;\n    this.isMultipleEntrypoint = isMultipleEntrypoint;\n    this.isAnonymous = isAnonymous;\n  }\n\n  Object.defineProperty(ContractMethod.prototype, \"schema\", {\n    /**\r\n     * @description Get the schema of the smart contract method\r\n     */\n    get: function () {\n      return this.isAnonymous ? this.parameterSchema.ExtractSchema()[this.name] : this.parameterSchema.ExtractSchema();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   *\r\n   * @description Send the smart contract operation\r\n   *\r\n   * @param Options generic operation parameter\r\n   */\n\n  ContractMethod.prototype.send = function (params) {\n    if (params === void 0) {\n      params = {};\n    }\n\n    if (this.provider instanceof Wallet) {\n      // TODO got around TS2352: Conversion of type 'T & Wallet' to type 'Wallet' by adding `as unknown`. Needs clarification\n      return this.provider.transfer(this.toTransferParams(params)).send();\n    } else {\n      return this.provider.transfer(this.toTransferParams(params));\n    }\n  };\n  /**\r\n   *\r\n   * @description Create transfer params to be used with TezosToolkit.contract.transfer methods\r\n   *\r\n   * @param Options generic transfer operation parameters\r\n   */\n\n\n  ContractMethod.prototype.toTransferParams = function (_a) {\n    var _b, _c;\n\n    var _d = _a === void 0 ? {} : _a,\n        fee = _d.fee,\n        gasLimit = _d.gasLimit,\n        storageLimit = _d.storageLimit,\n        source = _d.source,\n        _e = _d.amount,\n        amount = _e === void 0 ? 0 : _e,\n        _f = _d.mutez,\n        mutez = _f === void 0 ? false : _f;\n\n    var fullTransferParams = {\n      to: this.address,\n      amount: amount,\n      fee: fee,\n      mutez: mutez,\n      source: source,\n      gasLimit: gasLimit,\n      storageLimit: storageLimit,\n      parameter: {\n        entrypoint: this.isMultipleEntrypoint ? this.name : 'default',\n        value: this.isAnonymous ? (_b = this.parameterSchema).Encode.apply(_b, __spreadArray([this.name], __read(this.args))) : (_c = this.parameterSchema).Encode.apply(_c, __spreadArray([], __read(this.args)))\n      }\n    };\n    return fullTransferParams;\n  };\n\n  return ContractMethod;\n}();\n/**\r\n * @description Utility class to retrieve data from a smart contract's storage without incurring fees via a contract's view method\r\n */\n\n\nvar ContractView =\n/** @class */\nfunction () {\n  function ContractView(currentContract, provider, name, chainId, callbackParametersSchema, parameterSchema, args) {\n    this.currentContract = currentContract;\n    this.provider = provider;\n    this.name = name;\n    this.chainId = chainId;\n    this.callbackParametersSchema = callbackParametersSchema;\n    this.parameterSchema = parameterSchema;\n    this.args = args;\n  }\n  /**\r\n   *\r\n   * @description Find which lambda contract to use based on the current network,\r\n   * encode parameters to Michelson,\r\n   * create an instance of Lambdaview to retrive data, and\r\n   * Decode Michelson response\r\n   *\r\n   * @param Options Address of a lambda contract (sandbox users)\r\n   */\n\n\n  ContractView.prototype.read = function (customLambdaAddress) {\n    return __awaiter(this, void 0, void 0, function () {\n      var lambdaAddress, lambdaContract, arg, lambdaView, failedWith, response;\n\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            // TODO Verify if the 'customLambdaAdress' is a valid originated contract and if not, return an appropriate error message. \n            if (customLambdaAddress) {\n              lambdaAddress = customLambdaAddress;\n            } else if (this.chainId === ChainIds.EDONET) {\n              lambdaAddress = DefaultLambdaAddresses.EDONET;\n            } else if (this.chainId === ChainIds.FLORENCENET) {\n              lambdaAddress = DefaultLambdaAddresses.FLORENCENET;\n            } else if (this.chainId === ChainIds.GRANADANET) {\n              lambdaAddress = DefaultLambdaAddresses.GRANADANET;\n            } else if (this.chainId === ChainIds.MAINNET) {\n              lambdaAddress = DefaultLambdaAddresses.MAINNET;\n            } else {\n              throw new UndefinedLambdaContractError();\n            }\n\n            return [4\n            /*yield*/\n            , this.provider.at(lambdaAddress)];\n\n          case 1:\n            lambdaContract = _b.sent();\n            arg = (_a = this.parameterSchema).Encode.apply(_a, __spreadArray([], __read(this.args)));\n            lambdaView = new LambdaView(lambdaContract, this.currentContract, this.name, arg);\n            return [4\n            /*yield*/\n            , lambdaView.execute()];\n\n          case 2:\n            failedWith = _b.sent();\n            response = this.callbackParametersSchema.Execute(failedWith);\n            return [2\n            /*return*/\n            , response];\n        }\n      });\n    });\n  };\n\n  return ContractView;\n}();\n\nvar validateArgs = function (args, schema, name) {\n  var sigs = schema.ExtractSignatures();\n\n  if (!sigs.find(function (x) {\n    return x.length === args.length;\n  })) {\n    throw new InvalidParameterError(name, sigs, args);\n  }\n};\n\nvar isView = function (schema) {\n  var isView = false;\n  var sigs = schema.ExtractSignatures();\n\n  if (sigs[0][sigs[0].length - 1] === 'contract') {\n    isView = true;\n  }\n\n  return isView;\n};\n\nvar isContractProvider = function (variableToCheck) {\n  return variableToCheck.contractProviderTypeSymbol !== undefined;\n};\n/**\r\n * @description Smart contract abstraction\r\n */\n\n\nvar ContractAbstraction =\n/** @class */\nfunction () {\n  function ContractAbstraction(address, script, provider, storageProvider, entrypoints, chainId) {\n    this.address = address;\n    this.script = script;\n    this.storageProvider = storageProvider;\n    this.entrypoints = entrypoints;\n    this.chainId = chainId;\n    /**\r\n     * @description Contains methods that are implemented by the target Tezos Smart Contract, and offers the user to call the Smart Contract methods as if they were native TS/JS methods.\r\n     * NB: if the contract contains annotation it will include named properties; if not it will be indexed by a number.\r\n     *\r\n     */\n\n    this.methods = {};\n    this.views = {};\n    this.schema = Schema.fromRPCResponse({\n      script: this.script\n    });\n    this.parameterSchema = ParameterSchema.fromRPCResponse({\n      script: this.script\n    });\n\n    this._initializeMethods(this, address, provider, this.entrypoints.entrypoints, this.chainId);\n  }\n\n  ContractAbstraction.prototype._initializeMethods = function (currentContract, address, provider, entrypoints, chainId) {\n    var _this = this;\n\n    var parameterSchema = this.parameterSchema;\n    var keys = Object.keys(entrypoints);\n\n    if (parameterSchema.isMultipleEntryPoint) {\n      keys.forEach(function (smartContractMethodName) {\n        var smartContractMethodSchema = new ParameterSchema(entrypoints[smartContractMethodName]);\n\n        var method = function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          validateArgs(args, smartContractMethodSchema, smartContractMethodName);\n          return new ContractMethod(provider, address, smartContractMethodSchema, smartContractMethodName, args);\n        };\n\n        _this.methods[smartContractMethodName] = method;\n\n        if (isContractProvider(provider)) {\n          if (isView(smartContractMethodSchema)) {\n            var view = function () {\n              var args = [];\n\n              for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n              }\n\n              var entrypointParamWithoutCallback = entrypoints[smartContractMethodName].args[0];\n              var smartContractMethodSchemaWithoutCallback = new ParameterSchema(entrypointParamWithoutCallback);\n              var parametersCallback = entrypoints[smartContractMethodName].args[1].args[0];\n              var smartContractMethodCallbackSchema = new ParameterSchema(parametersCallback);\n              validateArgs(args, smartContractMethodSchemaWithoutCallback, smartContractMethodName);\n              return new ContractView(currentContract, provider, smartContractMethodName, chainId, smartContractMethodCallbackSchema, smartContractMethodSchemaWithoutCallback, args);\n            };\n\n            _this.views[smartContractMethodName] = view;\n          }\n        }\n      }); // Deal with methods with no annotations which were not discovered by the RPC endpoint\n      // Methods with no annotations are discovered using parameter schema\n\n      var anonymousMethods = Object.keys(parameterSchema.ExtractSchema()).filter(function (key) {\n        return Object.keys(entrypoints).indexOf(key) === -1;\n      });\n      anonymousMethods.forEach(function (smartContractMethodName) {\n        var method = function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          validateArgs(__spreadArray([smartContractMethodName], __read(args)), parameterSchema, smartContractMethodName);\n          return new ContractMethod(provider, address, parameterSchema, smartContractMethodName, args, false, true);\n        };\n\n        _this.methods[smartContractMethodName] = method;\n      });\n    } else {\n      var smartContractMethodSchema_1 = this.parameterSchema;\n\n      var method = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        validateArgs(args, parameterSchema, DEFAULT_SMART_CONTRACT_METHOD_NAME);\n        return new ContractMethod(provider, address, smartContractMethodSchema_1, DEFAULT_SMART_CONTRACT_METHOD_NAME, args, false);\n      };\n\n      this.methods[DEFAULT_SMART_CONTRACT_METHOD_NAME] = method;\n    }\n  };\n  /**\r\n   * @description Return a friendly representation of the smart contract storage\r\n   */\n\n\n  ContractAbstraction.prototype.storage = function () {\n    return this.storageProvider.getStorage(this.address, this.schema);\n  };\n  /**\r\n   *\r\n   * @description Return a friendly representation of the smart contract big map value\r\n   *\r\n   * @param key BigMap key to fetch\r\n   *\r\n   * @deprecated getBigMapKey has been deprecated in favor of getBigMapKeyByID\r\n   *\r\n   * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get\r\n   */\n\n\n  ContractAbstraction.prototype.bigMap = function (key) {\n    // tslint:disable-next-line: deprecation\n    return this.storageProvider.getBigMapKey(this.address, key, this.schema);\n  };\n\n  return ContractAbstraction;\n}();\n\nvar BigMapAbstraction =\n/** @class */\nfunction () {\n  function BigMapAbstraction(id, schema, provider) {\n    this.id = id;\n    this.schema = schema;\n    this.provider = provider;\n  }\n  /**\r\n   *\r\n   * @description Fetch one value in a big map\r\n   *\r\n   * @param keysToEncode Key to query (will be encoded properly according to the schema)\r\n   * @param block optional block level to fetch the values from (head will be use by default)\r\n   * @returns Return a well formatted json object of a big map value or undefined if the key is not found in the big map\r\n   *\r\n   */\n\n\n  BigMapAbstraction.prototype.get = function (keyToEncode, block) {\n    return __awaiter(this, void 0, void 0, function () {\n      var id, e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , this.provider.getBigMapKeyByID(this.id.toString(), keyToEncode, this.schema, block)];\n\n          case 1:\n            id = _a.sent();\n            return [2\n            /*return*/\n            , id];\n\n          case 2:\n            e_1 = _a.sent();\n\n            if (e_1 instanceof HttpResponseError && e_1.status === STATUS_CODE.NOT_FOUND) {\n              return [2\n              /*return*/\n              , undefined];\n            } else {\n              throw e_1;\n            }\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Fetch multiple values in a big map\r\n   * All values will be fetched on the same block level. If a block is specified in the request, the values will be fetched at it.\r\n   * Otherwise, a first request will be done to the node to fetch the level of the head and all values will be fetched at this level.\r\n   * If one of the keys does not exist in the big map, its value will be set to undefined.\r\n   *\r\n   * @param keysToEncode Array of keys to query (will be encoded properly according to the schema)\r\n   * @param block optional block level to fetch the values from\r\n   * @param batchSize optional batch size representing the number of requests to execute in parallel\r\n   * @returns A MichelsonMap containing the keys queried in the big map and their value in a well-formatted JSON object format\r\n   *\r\n   */\n\n\n  BigMapAbstraction.prototype.getMultipleValues = function (keysToEncode, block, batchSize) {\n    if (batchSize === void 0) {\n      batchSize = 5;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.provider.getBigMapKeysByID(this.id.toString(), keysToEncode, this.schema, block, batchSize)];\n      });\n    });\n  };\n\n  BigMapAbstraction.prototype.toJSON = function () {\n    return this.id.toString();\n  };\n\n  BigMapAbstraction.prototype.toString = function () {\n    return this.id.toString();\n  };\n\n  return BigMapAbstraction;\n}();\n\nvar SaplingStateAbstraction =\n/** @class */\nfunction () {\n  function SaplingStateAbstraction(id, provider) {\n    this.id = id;\n    this.provider = provider;\n  }\n  /**\r\n   *\r\n   * @description Fetch the sapling state\r\n   *\r\n   * @param block optional block level to fetch the values from (head will be use by default)\r\n   * @returns Return a json object of the sapling_state\r\n   *\r\n   */\n\n\n  SaplingStateAbstraction.prototype.getSaplingDiff = function (block) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.provider.getSaplingDiffByID(this.id.toString(), block)];\n      });\n    });\n  };\n\n  SaplingStateAbstraction.prototype.getId = function () {\n    return this.id.toString();\n  };\n\n  return SaplingStateAbstraction;\n}(); // Override the default michelson encoder semantic to provide richer abstraction over storage properties\n\n\nvar smartContractAbstractionSemantic = function (provider) {\n  return {\n    // Provide a specific abstraction for BigMaps\n    big_map: function (val, code) {\n      if (!val || !('int' in val) || val.int === undefined) {\n        // Return an empty object in case of missing big map ID\n        return {};\n      } else {\n        var schema = new Schema(code);\n        return new BigMapAbstraction(new BigNumber(val.int), schema, provider);\n      }\n    },\n    sapling_state: function (val) {\n      if (!val || !('int' in val) || val.int === undefined) {\n        // Return an empty object in case of missing sapling state ID\n        return {};\n      } else {\n        return new SaplingStateAbstraction(new BigNumber(val.int), provider);\n      }\n    }\n    /*\r\n    // TODO: embed useful other abstractions\r\n    'contract':  () => {},\r\n    'address':  () => {}\r\n    */\n\n  };\n};\n\nvar RpcContractProvider =\n/** @class */\nfunction (_super) {\n  __extends(RpcContractProvider, _super);\n\n  function RpcContractProvider(context, estimator) {\n    var _this = _super.call(this, context) || this;\n\n    _this.estimator = estimator;\n    _this.contractProviderTypeSymbol = Symbol.for('taquito--provider-type-symbol');\n    return _this;\n  }\n  /**\r\n   *\r\n   * @description Return a well formatted json object of the contract storage\r\n   *\r\n   * @param contract contract address you want to get the storage from\r\n   * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\r\n   *\r\n   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\r\n   */\n\n\n  RpcContractProvider.prototype.getStorage = function (contract, schema) {\n    return __awaiter(this, void 0, void 0, function () {\n      var contractSchema, storage;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!!schema) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.rpc.getScript(contract)];\n\n          case 1:\n            schema = _a.sent();\n            _a.label = 2;\n\n          case 2:\n            if (Schema.isSchema(schema)) {\n              contractSchema = schema;\n            } else {\n              contractSchema = Schema.fromRPCResponse({\n                script: schema\n              });\n            }\n\n            return [4\n            /*yield*/\n            , this.rpc.getStorage(contract)];\n\n          case 3:\n            storage = _a.sent();\n            return [2\n            /*return*/\n            , contractSchema.Execute(storage, smartContractAbstractionSemantic(this))];\n          // Cast into T because only the caller can know the true type of the storage\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Return a well formatted json object of the contract big map storage\r\n   *\r\n   * @param contract contract address you want to get the storage from\r\n   * @param key contract big map key to fetch value from\r\n   * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\r\n   *\r\n   * @deprecated Deprecated in favor of getBigMapKeyByID\r\n   *\r\n   * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get\r\n   */\n\n\n  RpcContractProvider.prototype.getBigMapKey = function (contract, key, schema) {\n    return __awaiter(this, void 0, void 0, function () {\n      var contractSchema, encodedKey, val;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!!schema) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.rpc.getScript(contract)];\n\n          case 1:\n            schema = _a.sent();\n            _a.label = 2;\n\n          case 2:\n            if (Schema.isSchema(schema)) {\n              contractSchema = schema;\n            } else {\n              contractSchema = Schema.fromRPCResponse({\n                script: schema\n              });\n            }\n\n            encodedKey = contractSchema.EncodeBigMapKey(key);\n            return [4\n            /*yield*/\n            , this.rpc.getBigMapKey(contract, encodedKey)];\n\n          case 3:\n            val = _a.sent();\n            return [2\n            /*return*/\n            , contractSchema.ExecuteOnBigMapValue(val)];\n          // Cast into T because only the caller can know the true type of the storage\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Return a well formatted json object of a big map value\r\n   *\r\n   * @param id Big Map ID\r\n   * @param keyToEncode key to query (will be encoded properly according to the schema)\r\n   * @param schema Big Map schema (can be determined using your contract type)\r\n   * @param block optional block level to fetch the values from\r\n   *\r\n   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr\r\n   */\n\n\n  RpcContractProvider.prototype.getBigMapKeyByID = function (id, keyToEncode, schema, block) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, key, type, packed, encodedExpr, bigMapValue, _b;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _a = schema.EncodeBigMapKey(keyToEncode), key = _a.key, type = _a.type;\n            return [4\n            /*yield*/\n            , this.context.packer.packData({\n              data: key,\n              type: type\n            })];\n\n          case 1:\n            packed = _c.sent().packed;\n            encodedExpr = encodeExpr(packed);\n            if (!block) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , this.context.rpc.getBigMapExpr(id.toString(), encodedExpr, {\n              block: String(block)\n            })];\n\n          case 2:\n            _b = _c.sent();\n            return [3\n            /*break*/\n            , 5];\n\n          case 3:\n            return [4\n            /*yield*/\n            , this.context.rpc.getBigMapExpr(id.toString(), encodedExpr)];\n\n          case 4:\n            _b = _c.sent();\n            _c.label = 5;\n\n          case 5:\n            bigMapValue = _b;\n            return [2\n            /*return*/\n            , schema.ExecuteOnBigMapValue(bigMapValue, smartContractAbstractionSemantic(this))];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Fetch multiple values in a big map\r\n   * All values will be fetched on the same block level. If a block is specified in the request, the values will be fetched at it.\r\n   * Otherwise, a first request will be done to the node to fetch the level of the head and all values will be fetched at this level.\r\n   * If one of the keys does not exist in the big map, its value will be set to undefined.\r\n   *\r\n   * @param id Big Map ID\r\n   * @param keys Array of keys to query (will be encoded properly according to the schema)\r\n   * @param schema Big Map schema (can be determined using your contract type)\r\n   * @param block optional block level to fetch the values from\r\n   * @param batchSize optional batch size representing the number of requests to execute in parallel\r\n   * @returns A MichelsonMap containing the keys queried in the big map and their value in a well-formatted JSON object format\r\n   *\r\n   */\n\n\n  RpcContractProvider.prototype.getBigMapKeysByID = function (id, keys, schema, block, batchSize) {\n    if (batchSize === void 0) {\n      batchSize = 5;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var level, bigMapValues, position, results, keysBatch, batch, _a, i;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.getBlockForRequest(keys, block)];\n\n          case 1:\n            level = _b.sent();\n            bigMapValues = new MichelsonMap();\n            position = 0;\n            results = [];\n            _b.label = 2;\n\n          case 2:\n            if (!(position < keys.length)) return [3\n            /*break*/\n            , 4];\n            keysBatch = keys.slice(position, position + batchSize);\n            batch = keysBatch.map(function (keyToEncode) {\n              return _this.getBigMapValueOrUndefined(keyToEncode, id, schema, level);\n            });\n            _a = [__spreadArray([], __read(results))];\n            return [4\n            /*yield*/\n            , Promise.all(batch)];\n\n          case 3:\n            results = __spreadArray.apply(void 0, _a.concat([__read.apply(void 0, [_b.sent()])]));\n            position += batchSize;\n            return [3\n            /*break*/\n            , 2];\n\n          case 4:\n            for (i = 0; i < results.length; i++) {\n              bigMapValues.set(keys[i], results[i]);\n            }\n\n            return [2\n            /*return*/\n            , bigMapValues];\n        }\n      });\n    });\n  };\n\n  RpcContractProvider.prototype.getBlockForRequest = function (keys, block) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _b;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (!(keys.length === 1 || typeof block !== 'undefined')) return [3\n            /*break*/\n            , 1];\n            _b = block;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.rpc.getBlock()];\n\n          case 2:\n            _b = (_a = _c.sent()) === null || _a === void 0 ? void 0 : _a.header.level;\n            _c.label = 3;\n\n          case 3:\n            return [2\n            /*return*/\n            , _b];\n        }\n      });\n    });\n  };\n\n  RpcContractProvider.prototype.getBigMapValueOrUndefined = function (keyToEncode, id, schema, level) {\n    return __awaiter(this, void 0, void 0, function () {\n      var ex_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , this.getBigMapKeyByID(id, keyToEncode, schema, level)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 2:\n            ex_1 = _a.sent();\n\n            if (ex_1 instanceof HttpResponseError && ex_1.status === STATUS_CODE.NOT_FOUND) {\n              return [2\n              /*return*/\n              ];\n            } else {\n              throw ex_1;\n            }\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Return a well formatted json object of a sapling state\r\n   *\r\n   * @param id Sapling state ID\r\n   * @param block optional block level to fetch the value from\r\n   *\r\n   */\n\n\n  RpcContractProvider.prototype.getSaplingDiffByID = function (id, block) {\n    return __awaiter(this, void 0, void 0, function () {\n      var saplingState, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!block) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.context.rpc.getSaplingDiffById(id.toString(), {\n              block: String(block)\n            })];\n\n          case 1:\n            _a = _b.sent();\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            return [4\n            /*yield*/\n            , this.context.rpc.getSaplingDiffById(id.toString())];\n\n          case 3:\n            _a = _b.sent();\n            _b.label = 4;\n\n          case 4:\n            saplingState = _a;\n            return [2\n            /*return*/\n            , saplingState];\n        }\n      });\n    });\n  };\n\n  RpcContractProvider.prototype.addRevealOperationIfNeeded = function (operation, publicKeyHash) {\n    return __awaiter(this, void 0, void 0, function () {\n      var ops, publicKey, estimateReveal_1, reveal, estimatedReveal, _a, _b;\n\n      var _this = this;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (!isOpRequireReveal(operation)) return [3\n            /*break*/\n            , 5];\n            ops = [operation];\n            return [4\n            /*yield*/\n            , this.signer.publicKey()];\n\n          case 1:\n            publicKey = _c.sent();\n            return [4\n            /*yield*/\n            , this.estimator.reveal()];\n\n          case 2:\n            estimateReveal_1 = _c.sent();\n            if (!estimateReveal_1) return [3\n            /*break*/\n            , 5];\n            reveal = {\n              kind: OpKind.REVEAL\n            };\n            return [4\n            /*yield*/\n            , this.estimate(reveal, function () {\n              return __awaiter(_this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                  return [2\n                  /*return*/\n                  , estimateReveal_1];\n                });\n              });\n            })];\n\n          case 3:\n            estimatedReveal = _c.sent();\n            _b = (_a = ops).unshift;\n            return [4\n            /*yield*/\n            , createRevealOperation(__assign({}, estimatedReveal), publicKeyHash, publicKey)];\n\n          case 4:\n            _b.apply(_a, [_c.sent()]);\n\n            return [2\n            /*return*/\n            , ops];\n\n          case 5:\n            return [2\n            /*return*/\n            , operation];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Originate a new contract according to the script in parameters. Will sign and inject an operation using the current context\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   * @warn You cannot specify storage and init at the same time (use init to pass the raw michelson representation of storage)\r\n   *\r\n   * @param OriginationOperation Originate operation parameter\r\n   */\n\n\n  RpcContractProvider.prototype.originate = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var estimate, publicKeyHash, operation, _a, ops, preparedOrigination, forgedOrigination, signedOperation, opResponse, hash;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.estimate(params, this.estimator.originate.bind(this.estimator))];\n\n          case 1:\n            estimate = _b.sent();\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 2:\n            publicKeyHash = _b.sent();\n            _a = createOriginationOperation;\n            return [4\n            /*yield*/\n            , this.context.parser.prepareCodeOrigination(__assign(__assign({}, params), estimate))];\n\n          case 3:\n            return [4\n            /*yield*/\n            , _a.apply(void 0, [_b.sent()])];\n\n          case 4:\n            operation = _b.sent();\n            return [4\n            /*yield*/\n            , this.addRevealOperationIfNeeded(operation, publicKeyHash)];\n\n          case 5:\n            ops = _b.sent();\n            return [4\n            /*yield*/\n            , this.prepareOpAndSimulation({\n              operation: ops,\n              source: publicKeyHash\n            })];\n\n          case 6:\n            preparedOrigination = _b.sent();\n            return [4\n            /*yield*/\n            , this.forge(preparedOrigination.preparedOp)];\n\n          case 7:\n            forgedOrigination = _b.sent();\n            return [4\n            /*yield*/\n            , this.signOperation(forgedOrigination)];\n\n          case 8:\n            signedOperation = _b.sent();\n            return [4\n            /*yield*/\n            , this.preValidate(preparedOrigination, signedOperation)];\n\n          case 9:\n            opResponse = _b.sent();\n            return [4\n            /*yield*/\n            , this.injectOperation(signedOperation.opbytes)];\n\n          case 10:\n            hash = _b.sent();\n            return [2\n            /*return*/\n            , new OriginationOperation(hash, operation, signedOperation, opResponse, this.context.clone(), this)];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Set the delegate for a contract. Will sign and inject an operation using the current context\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   * @param SetDelegate operation parameter\r\n   */\n\n\n  RpcContractProvider.prototype.setDelegate = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var estimate, publicKeyHash, operation, sourceOrDefault, ops, prepared, opBytes, signedOperation, opResponse, hash;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // Since babylon delegation source cannot smart contract\n            if (/kt1/i.test(params.source)) {\n              throw new InvalidDelegationSource(params.source);\n            }\n\n            return [4\n            /*yield*/\n            , this.estimate(params, this.estimator.setDelegate.bind(this.estimator))];\n\n          case 1:\n            estimate = _a.sent();\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 2:\n            publicKeyHash = _a.sent();\n            return [4\n            /*yield*/\n            , createSetDelegateOperation(__assign(__assign({}, params), estimate))];\n\n          case 3:\n            operation = _a.sent();\n            sourceOrDefault = params.source || publicKeyHash;\n            return [4\n            /*yield*/\n            , this.addRevealOperationIfNeeded(operation, publicKeyHash)];\n\n          case 4:\n            ops = _a.sent();\n            return [4\n            /*yield*/\n            , this.prepareOpAndSimulation({\n              operation: ops,\n              source: sourceOrDefault\n            })];\n\n          case 5:\n            prepared = _a.sent();\n            return [4\n            /*yield*/\n            , this.forge(prepared.preparedOp)];\n\n          case 6:\n            opBytes = _a.sent();\n            return [4\n            /*yield*/\n            , this.signOperation(opBytes)];\n\n          case 7:\n            signedOperation = _a.sent();\n            return [4\n            /*yield*/\n            , this.preValidate(prepared, signedOperation)];\n\n          case 8:\n            opResponse = _a.sent();\n            return [4\n            /*yield*/\n            , this.injectOperation(signedOperation.opbytes)];\n\n          case 9:\n            hash = _a.sent();\n            return [2\n            /*return*/\n            , new DelegateOperation(hash, operation, sourceOrDefault, signedOperation, opResponse, this.context.clone())];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Register the current address as delegate. Will sign and inject an operation using the current context\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   * @param RegisterDelegate operation parameter\r\n   */\n\n\n  RpcContractProvider.prototype.registerDelegate = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var estimate, source, operation, ops, prepared, opBytes, signedOperation, opResponse, hash;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.estimate(params, this.estimator.registerDelegate.bind(this.estimator))];\n\n          case 1:\n            estimate = _a.sent();\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 2:\n            source = _a.sent();\n            return [4\n            /*yield*/\n            , createRegisterDelegateOperation(__assign(__assign({}, params), estimate), source)];\n\n          case 3:\n            operation = _a.sent();\n            return [4\n            /*yield*/\n            , this.addRevealOperationIfNeeded(operation, source)];\n\n          case 4:\n            ops = _a.sent();\n            return [4\n            /*yield*/\n            , this.prepareOpAndSimulation({\n              operation: ops,\n              source: source\n            })];\n\n          case 5:\n            prepared = _a.sent();\n            return [4\n            /*yield*/\n            , this.forge(prepared.preparedOp)];\n\n          case 6:\n            opBytes = _a.sent();\n            return [4\n            /*yield*/\n            , this.signOperation(opBytes)];\n\n          case 7:\n            signedOperation = _a.sent();\n            return [4\n            /*yield*/\n            , this.preValidate(prepared, signedOperation)];\n\n          case 8:\n            opResponse = _a.sent();\n            return [4\n            /*yield*/\n            , this.injectOperation(signedOperation.opbytes)];\n\n          case 9:\n            hash = _a.sent();\n            return [2\n            /*return*/\n            , new DelegateOperation(hash, operation, source, signedOperation, opResponse, this.context.clone())];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Transfer tz from current address to a specific address. Will sign and inject an operation using the current context\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   * @param Transfer operation parameter\r\n   */\n\n\n  RpcContractProvider.prototype.transfer = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var publicKeyHash, estimate, operation, source, ops, prepared, forgedOperation, signedOperation, opResponse, hash;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 1:\n            publicKeyHash = _a.sent();\n            return [4\n            /*yield*/\n            , this.estimate(params, this.estimator.transfer.bind(this.estimator))];\n\n          case 2:\n            estimate = _a.sent();\n            return [4\n            /*yield*/\n            , createTransferOperation(__assign(__assign({}, params), estimate))];\n\n          case 3:\n            operation = _a.sent();\n            source = params.source || publicKeyHash;\n            return [4\n            /*yield*/\n            , this.addRevealOperationIfNeeded(operation, publicKeyHash)];\n\n          case 4:\n            ops = _a.sent();\n            return [4\n            /*yield*/\n            , this.prepareOpAndSimulation({\n              operation: ops,\n              source: source\n            })];\n\n          case 5:\n            prepared = _a.sent();\n            return [4\n            /*yield*/\n            , this.forge(prepared.preparedOp)];\n\n          case 6:\n            forgedOperation = _a.sent();\n            return [4\n            /*yield*/\n            , this.signOperation(forgedOperation)];\n\n          case 7:\n            signedOperation = _a.sent();\n            return [4\n            /*yield*/\n            , this.preValidate(prepared, signedOperation)];\n\n          case 8:\n            opResponse = _a.sent();\n            return [4\n            /*yield*/\n            , this.injectOperation(signedOperation.opbytes)];\n\n          case 9:\n            hash = _a.sent();\n            return [2\n            /*return*/\n            , new TransactionOperation(hash, operation, source, signedOperation, opResponse, this.context.clone())];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Reveal the current address. Will throw an error if the address is already revealed.\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   * @param RevealParams operation parameter\r\n   */\n\n\n  RpcContractProvider.prototype.reveal = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var publicKeyHash, estimateReveal, estimated, operation, _a, _b, prepared, opBytes, signedOperation, opResponse, hash;\n\n      var _this = this;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.signer.publicKeyHash()];\n\n          case 1:\n            publicKeyHash = _c.sent();\n            return [4\n            /*yield*/\n            , this.estimator.reveal(params)];\n\n          case 2:\n            estimateReveal = _c.sent();\n            if (!estimateReveal) return [3\n            /*break*/\n            , 11];\n            return [4\n            /*yield*/\n            , this.estimate(params, function () {\n              return __awaiter(_this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                  return [2\n                  /*return*/\n                  , estimateReveal];\n                });\n              });\n            })];\n\n          case 3:\n            estimated = _c.sent();\n            _a = createRevealOperation;\n            _b = [__assign({}, estimated), publicKeyHash];\n            return [4\n            /*yield*/\n            , this.signer.publicKey()];\n\n          case 4:\n            return [4\n            /*yield*/\n            , _a.apply(void 0, _b.concat([_c.sent()]))];\n\n          case 5:\n            operation = _c.sent();\n            return [4\n            /*yield*/\n            , this.prepareOpAndSimulation({\n              operation: operation,\n              source: publicKeyHash\n            })];\n\n          case 6:\n            prepared = _c.sent();\n            return [4\n            /*yield*/\n            , this.forge(prepared.preparedOp)];\n\n          case 7:\n            opBytes = _c.sent();\n            return [4\n            /*yield*/\n            , this.signOperation(opBytes)];\n\n          case 8:\n            signedOperation = _c.sent();\n            return [4\n            /*yield*/\n            , this.preValidate(prepared, signedOperation)];\n\n          case 9:\n            opResponse = _c.sent();\n            return [4\n            /*yield*/\n            , this.injectOperation(signedOperation.opbytes)];\n\n          case 10:\n            hash = _c.sent();\n            return [2\n            /*return*/\n            , new RevealOperation(hash, operation, publicKeyHash, signedOperation, opResponse, this.context.clone())];\n\n          case 11:\n            throw new Error('The current address is already revealed.');\n        }\n      });\n    });\n  };\n\n  RpcContractProvider.prototype.at = function (address, contractAbstractionComposer) {\n    if (contractAbstractionComposer === void 0) {\n      contractAbstractionComposer = function (x) {\n        return x;\n      };\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var script, entrypoints, blockHeader, chainId, abs;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.rpc.getScript(address)];\n\n          case 1:\n            script = _a.sent();\n            return [4\n            /*yield*/\n            , this.rpc.getEntrypoints(address)];\n\n          case 2:\n            entrypoints = _a.sent();\n            return [4\n            /*yield*/\n            , this.rpc.getBlockHeader()];\n\n          case 3:\n            blockHeader = _a.sent();\n            chainId = blockHeader.chain_id;\n            abs = new ContractAbstraction(address, script, this, this, entrypoints, chainId);\n            return [2\n            /*return*/\n            , contractAbstractionComposer(abs, this.context)];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch\r\n   *\r\n   * @returns A batch object from which we can add more operation or send a command to execute the batch\r\n   *\r\n   * @param params List of operation to batch together\r\n   */\n\n\n  RpcContractProvider.prototype.batch = function (params) {\n    var batch = new OperationBatch(this.context, this.estimator);\n\n    if (Array.isArray(params)) {\n      batch.with(params);\n    }\n\n    return batch;\n  };\n\n  return RpcContractProvider;\n}(OperationEmitter);\n\nvar MichelCodecParser =\n/** @class */\nfunction () {\n  function MichelCodecParser(context) {\n    this.context = context;\n  }\n\n  MichelCodecParser.prototype.getNextProto = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var next_protocol;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.context.rpc.getBlockMetadata()];\n\n          case 1:\n            next_protocol = _a.sent().next_protocol;\n            return [2\n            /*return*/\n            , next_protocol];\n        }\n      });\n    });\n  };\n\n  MichelCodecParser.prototype.parseScript = function (src) {\n    return __awaiter(this, void 0, void 0, function () {\n      var parser, _a;\n\n      var _b;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _a = Parser.bind;\n            _b = {};\n            return [4\n            /*yield*/\n            , this.getNextProto()];\n\n          case 1:\n            parser = new (_a.apply(Parser, [void 0, (_b.protocol = _c.sent(), _b)]))();\n            return [2\n            /*return*/\n            , parser.parseScript(src)];\n        }\n      });\n    });\n  };\n\n  MichelCodecParser.prototype.parseMichelineExpression = function (src) {\n    return __awaiter(this, void 0, void 0, function () {\n      var parser, _a;\n\n      var _b;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _a = Parser.bind;\n            _b = {};\n            return [4\n            /*yield*/\n            , this.getNextProto()];\n\n          case 1:\n            parser = new (_a.apply(Parser, [void 0, (_b.protocol = _c.sent(), _b)]))();\n            return [2\n            /*return*/\n            , parser.parseMichelineExpression(src)];\n        }\n      });\n    });\n  };\n\n  MichelCodecParser.prototype.parseJSON = function (src) {\n    return __awaiter(this, void 0, void 0, function () {\n      var parser, _a;\n\n      var _b;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _a = Parser.bind;\n            _b = {};\n            return [4\n            /*yield*/\n            , this.getNextProto()];\n\n          case 1:\n            parser = new (_a.apply(Parser, [void 0, (_b.protocol = _c.sent(), _b)]))();\n            return [2\n            /*return*/\n            , parser.parseJSON(src)];\n        }\n      });\n    });\n  };\n\n  MichelCodecParser.prototype.prepareCodeOrigination = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var parsedParams, _a, _b;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            parsedParams = params;\n            _a = parsedParams;\n            return [4\n            /*yield*/\n            , this.formatCodeParam(params.code)];\n\n          case 1:\n            _a.code = _c.sent();\n            if (!params.init) return [3\n            /*break*/\n            , 3];\n            _b = parsedParams;\n            return [4\n            /*yield*/\n            , this.formatInitParam(params.init)];\n\n          case 2:\n            _b.init = _c.sent();\n            _c.label = 3;\n\n          case 3:\n            return [2\n            /*return*/\n            , parsedParams];\n        }\n      });\n    });\n  };\n\n  MichelCodecParser.prototype.formatCodeParam = function (code) {\n    return __awaiter(this, void 0, void 0, function () {\n      var parsedCode, c, c, order_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(typeof code === 'string')) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.parseScript(code)];\n\n          case 1:\n            c = _a.sent();\n\n            if (c === null) {\n              throw new InvalidCodeParameter('Invalid code parameter', code);\n            }\n\n            parsedCode = c;\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            return [4\n            /*yield*/\n            , this.parseJSON(code)];\n\n          case 3:\n            c = _a.sent();\n            order_1 = ['parameter', 'storage', 'code']; // Ensure correct ordering for RPC\n\n            parsedCode = c.sort(function (a, b) {\n              return order_1.indexOf(a.prim) - order_1.indexOf(b.prim);\n            });\n            _a.label = 4;\n\n          case 4:\n            return [2\n            /*return*/\n            , parsedCode];\n        }\n      });\n    });\n  };\n\n  MichelCodecParser.prototype.formatInitParam = function (init) {\n    return __awaiter(this, void 0, void 0, function () {\n      var parsedInit, c;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(typeof init === 'string')) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.parseMichelineExpression(init)];\n\n          case 1:\n            c = _a.sent();\n\n            if (c === null) {\n              throw new InvalidInitParameter('Invalid init parameter', init);\n            }\n\n            parsedInit = c;\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            return [4\n            /*yield*/\n            , this.parseJSON(init)];\n\n          case 3:\n            parsedInit = _a.sent();\n            _a.label = 4;\n\n          case 4:\n            return [2\n            /*return*/\n            , parsedInit];\n        }\n      });\n    });\n  };\n\n  return MichelCodecParser;\n}();\n\nvar RpcPacker =\n/** @class */\nfunction () {\n  function RpcPacker(context) {\n    this.context = context;\n  }\n\n  RpcPacker.prototype.packData = function (data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.context.rpc.packData(data)];\n      });\n    });\n  };\n\n  return RpcPacker;\n}();\n\nvar defaultConfig = {\n  defaultConfirmationCount: 1,\n  confirmationPollingTimeoutSecond: 180,\n  shouldObservableSubscriptionRetry: false,\n  observableSubscriptionRetryFunction: retry()\n};\n/**\r\n * @description Encapsulate common service used throughout different part of the library\r\n */\n\nvar Context =\n/** @class */\nfunction () {\n  function Context(_rpc, _signer, _proto, _config, forger, injector, packer, wallet, parser) {\n    if (_signer === void 0) {\n      _signer = new NoopSigner();\n    }\n\n    this._rpc = _rpc;\n    this._signer = _signer;\n    this._proto = _proto;\n    this._config = _config;\n    this._counters = {};\n    this.tz = new RpcTzProvider(this);\n    this.estimate = new RPCEstimateProvider(this);\n    this.contract = new RpcContractProvider(this, this.estimate);\n    this.batch = new RPCBatchProvider(this, this.estimate);\n    this.wallet = new Wallet(this);\n\n    if (typeof this._rpc === 'string') {\n      this._rpcClient = new RpcClient(this._rpc);\n    } else {\n      this._rpcClient = this._rpc;\n    }\n\n    this.config = _config;\n    this._forger = forger ? forger : new RpcForger(this);\n    this._injector = injector ? injector : new RpcInjector(this);\n    this.operationFactory = new OperationFactory(this);\n    this._walletProvider = wallet ? wallet : new LegacyWalletProvider(this);\n    this._parser = parser ? parser : new MichelCodecParser(this);\n    this._packer = packer ? packer : new RpcPacker(this);\n  }\n\n  Object.defineProperty(Context.prototype, \"config\", {\n    get: function () {\n      return this._config;\n    },\n    set: function (value) {\n      this._config = __assign(__assign({}, defaultConfig), value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"rpc\", {\n    get: function () {\n      return this._rpcClient;\n    },\n    set: function (value) {\n      this._rpcClient = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"injector\", {\n    get: function () {\n      return this._injector;\n    },\n    set: function (value) {\n      this._injector = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"forger\", {\n    get: function () {\n      return this._forger;\n    },\n    set: function (value) {\n      this._forger = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"signer\", {\n    get: function () {\n      return this._signer;\n    },\n    set: function (value) {\n      this._signer = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"walletProvider\", {\n    get: function () {\n      return this._walletProvider;\n    },\n    set: function (value) {\n      this._walletProvider = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"proto\", {\n    get: function () {\n      return this._proto;\n    },\n    set: function (value) {\n      this._proto = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"parser\", {\n    get: function () {\n      return this._parser;\n    },\n    set: function (value) {\n      this._parser = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"packer\", {\n    get: function () {\n      return this._packer;\n    },\n    set: function (value) {\n      this._packer = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"counters\", {\n    get: function () {\n      return this._counters;\n    },\n    set: function (value) {\n      this._counters[value.key] = value.counter;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Context.prototype.isAnyProtocolActive = function (protocol) {\n    if (protocol === void 0) {\n      protocol = [];\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var next_protocol;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this._proto) return [3\n            /*break*/\n            , 1];\n            return [2\n            /*return*/\n            , protocol.includes(this._proto)];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.rpc.getBlockMetadata()];\n\n          case 2:\n            next_protocol = _a.sent().next_protocol;\n            return [2\n            /*return*/\n            , protocol.includes(next_protocol)];\n        }\n      });\n    });\n  };\n\n  Context.prototype.getConfirmationPollingInterval = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var constants, blockTime, confirmationPollingInterval;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , this.rpc.getConstants()];\n\n          case 1:\n            constants = _a.sent();\n            blockTime = constants.time_between_blocks[0];\n\n            if (constants.minimal_block_delay !== undefined) {\n              blockTime = constants.minimal_block_delay;\n            }\n\n            confirmationPollingInterval = BigNumber.sum(blockTime, new BigNumber(constants.delay_per_missing_endorsement).multipliedBy(Math.max(0, constants.initial_endorsers - constants.endorsers_per_block))); // Divide the polling interval by a constant 3\n            // to improvise for polling time to work in prod,\n            // testnet and sandbox enviornment.   \n\n            confirmationPollingInterval = confirmationPollingInterval.dividedBy(3);\n            this.config.confirmationPollingIntervalSecond = confirmationPollingInterval.toNumber() === 0 ? 0.1 : confirmationPollingInterval.toNumber();\n            return [2\n            /*return*/\n            , this.config.confirmationPollingIntervalSecond];\n\n          case 2:\n            _a.sent(); // Return default value if there is\n            // an issue returning from constants\n            // file.\n\n\n            return [2\n            /*return*/\n            , 10];\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * @description Create a copy of the current context. Useful when you have long running operation and you do not want a context change to affect the operation\r\n   */\n\n\n  Context.prototype.clone = function () {\n    return new Context(this.rpc, this.signer, this.proto, this.config, this.forger, this._injector, this.packer);\n  };\n\n  return Context;\n}();\n\nvar opHashFilter = function (op, filter) {\n  return op.hash === filter.opHash;\n};\n\nvar sourceFilter = function (x, filter) {\n  switch (x.kind) {\n    case 'endorsement':\n      return 'metadata' in x && x.metadata.delegate === filter.source;\n\n    case 'activate_account':\n      return 'metadata' in x && x.pkh === filter.source;\n\n    default:\n      return 'source' in x && x.source === filter.source;\n  }\n};\n\nvar kindFilter = function (x, filter) {\n  return 'kind' in x && x.kind === filter.kind;\n};\n\nvar destinationFilter = function (x, filter) {\n  switch (x.kind) {\n    case 'delegation':\n      return x.delegate === filter.destination;\n\n    case 'origination':\n      if ('metadata' in x && 'operation_result' in x.metadata && 'originated_contracts' in x.metadata.operation_result && Array.isArray(x.metadata.operation_result.originated_contracts)) {\n        return x.metadata.operation_result.originated_contracts.some(function (contract) {\n          return contract === filter.destination;\n        });\n      }\n\n      break;\n\n    case 'transaction':\n      return x.destination === filter.destination;\n\n    default:\n      return false;\n  }\n};\n\nvar evaluateOpFilter = function (op, filter) {\n  if ('opHash' in filter) {\n    return opHashFilter(op, filter);\n  } else if ('source' in filter) {\n    return sourceFilter(op, filter);\n  } else if ('kind' in filter) {\n    return kindFilter(op, filter);\n  } else if ('destination' in filter) {\n    return destinationFilter(op, filter);\n  }\n\n  return false;\n};\n\nvar evaluateExpression = function (op, exp) {\n  if (Array.isArray(exp.and)) {\n    return exp.and.every(function (x) {\n      return evaluateFilter(op, x);\n    });\n  } else if (Array.isArray(exp.or)) {\n    return exp.or.some(function (x) {\n      return evaluateFilter(op, x);\n    });\n  } else {\n    throw new Error('Filter expression must contains either and/or property');\n  }\n};\n\nvar evaluateFilter = function (op, filter) {\n  var filters = [];\n\n  if (!Array.isArray(filter)) {\n    filters.push(filter);\n  } else {\n    filters.push.apply(filters, __spreadArray([], __read(filter)));\n  }\n\n  return filters.every(function (filterOrExp) {\n    if ('and' in filterOrExp || 'or' in filterOrExp) {\n      return evaluateExpression(op, filterOrExp);\n    } else {\n      return evaluateOpFilter(op, filterOrExp);\n    }\n  });\n};\n\nvar ObservableSubscription =\n/** @class */\nfunction () {\n  function ObservableSubscription(obs, shouldRetry, operatorFunction) {\n    var _this = this;\n\n    if (shouldRetry === void 0) {\n      shouldRetry = false;\n    }\n\n    if (operatorFunction === void 0) {\n      operatorFunction = retry();\n    }\n\n    this.shouldRetry = shouldRetry;\n    this.operatorFunction = operatorFunction;\n    this.errorListeners = [];\n    this.messageListeners = [];\n    this.closeListeners = [];\n    this.completed$ = new Subject();\n    obs.pipe(takeUntil(this.completed$), tap(function (data) {\n      _this.call(_this.messageListeners, data);\n    }, function (error) {\n      _this.call(_this.errorListeners, error);\n    }, function () {\n      _this.call(_this.closeListeners);\n    }), this.shouldRetry ? operatorFunction : tap(), catchError(function () {\n      return NEVER;\n    })).subscribe();\n  }\n\n  ObservableSubscription.prototype.call = function (listeners, value) {\n    var e_1, _a;\n\n    try {\n      for (var listeners_1 = __values(listeners), listeners_1_1 = listeners_1.next(); !listeners_1_1.done; listeners_1_1 = listeners_1.next()) {\n        var l = listeners_1_1.value;\n\n        try {\n          l(value);\n        } catch (ex) {\n          console.error(ex);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (listeners_1_1 && !listeners_1_1.done && (_a = listeners_1.return)) _a.call(listeners_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n\n  ObservableSubscription.prototype.remove = function (listeners, value) {\n    var idx = listeners.indexOf(value);\n\n    if (idx !== -1) {\n      listeners.splice(idx, 1);\n    }\n  };\n\n  ObservableSubscription.prototype.on = function (type, cb) {\n    switch (type) {\n      case 'data':\n        this.messageListeners.push(cb);\n        break;\n\n      case 'error':\n        this.errorListeners.push(cb);\n        break;\n\n      case 'close':\n        this.closeListeners.push(cb);\n        break;\n\n      default:\n        throw new Error(\"Trying to register on an unsupported event: \" + type);\n    }\n  };\n\n  ObservableSubscription.prototype.off = function (type, cb) {\n    switch (type) {\n      case 'data':\n        this.remove(this.messageListeners, cb);\n        break;\n\n      case 'error':\n        this.remove(this.errorListeners, cb);\n        break;\n\n      case 'close':\n        this.remove(this.closeListeners, cb);\n        break;\n\n      default:\n        throw new Error(\"Trying to unregister on an unsupported event: \" + type);\n    }\n  };\n\n  ObservableSubscription.prototype.close = function () {\n    this.completed$.next();\n  };\n\n  return ObservableSubscription;\n}();\n\nvar getLastBlock = function (context) {\n  return from(context.rpc.getBlock()).pipe(first());\n};\n\nvar applyFilter = function (filter) {\n  return concatMap(function (block) {\n    return new Observable(function (sub) {\n      var e_1, _a, e_2, _b, e_3, _c;\n\n      try {\n        for (var _d = __values(block.operations), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var ops = _e.value;\n\n          try {\n            for (var ops_1 = (e_2 = void 0, __values(ops)), ops_1_1 = ops_1.next(); !ops_1_1.done; ops_1_1 = ops_1.next()) {\n              var op = ops_1_1.value;\n\n              try {\n                for (var _f = (e_3 = void 0, __values(op.contents)), _g = _f.next(); !_g.done; _g = _f.next()) {\n                  var content = _g.value;\n\n                  if (evaluateFilter(__assign({\n                    hash: op.hash\n                  }, content), filter)) {\n                    sub.next(__assign({\n                      hash: op.hash\n                    }, content));\n                  }\n                }\n              } catch (e_3_1) {\n                e_3 = {\n                  error: e_3_1\n                };\n              } finally {\n                try {\n                  if (_g && !_g.done && (_c = _f.return)) _c.call(_f);\n                } finally {\n                  if (e_3) throw e_3.error;\n                }\n              }\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (ops_1_1 && !ops_1_1.done && (_b = ops_1.return)) _b.call(ops_1);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      sub.complete();\n    });\n  });\n};\n\nvar PollingSubscribeProvider =\n/** @class */\nfunction () {\n  function PollingSubscribeProvider(context, POLL_INTERVAL) {\n    var _this = this;\n\n    if (POLL_INTERVAL === void 0) {\n      POLL_INTERVAL = 20000;\n    }\n\n    this.context = context;\n    this.POLL_INTERVAL = POLL_INTERVAL;\n    this.newBlock$ = timer(0, this.POLL_INTERVAL).pipe(map(function () {\n      return _this.context;\n    }), switchMap(getLastBlock), distinctUntilKeyChanged('hash'), publishReplay(), refCount());\n  }\n\n  PollingSubscribeProvider.prototype.subscribe = function (_filter) {\n    return new ObservableSubscription(this.newBlock$.pipe(pluck('hash')), this.context.config.shouldObservableSubscriptionRetry, this.context.config.observableSubscriptionRetryFunction);\n  };\n\n  PollingSubscribeProvider.prototype.subscribeOperation = function (filter) {\n    return new ObservableSubscription(this.newBlock$.pipe(applyFilter(filter)), this.context.config.shouldObservableSubscriptionRetry, this.context.config.observableSubscriptionRetryFunction);\n  };\n\n  return PollingSubscribeProvider;\n}(); // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\n\n/* tslint:disable */\n\n\nvar VERSION = {\n  \"commitHash\": \"a8e9548e650215186f661033b59299ace72c9ee6\",\n  \"version\": \"9.2.0\"\n};\n/* tslint:enable */\n\nvar ForgingMismatchError =\n/** @class */\nfunction () {\n  function ForgingMismatchError(results) {\n    this.results = results;\n    this.name = 'ForgingMismatchError';\n    this.message = 'Forging mismatch error';\n  }\n\n  return ForgingMismatchError;\n}();\n\nvar CompositeForger =\n/** @class */\nfunction () {\n  function CompositeForger(forgers) {\n    this.forgers = forgers;\n\n    if (forgers.length === 0) {\n      throw new Error('At least one forger must be specified');\n    }\n  }\n\n  CompositeForger.prototype.forge = function (_a) {\n    var branch = _a.branch,\n        contents = _a.contents;\n    return __awaiter(this, void 0, void 0, function () {\n      var results, lastResult, currentResult;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , Promise.all(this.forgers.map(function (forger) {\n              return forger.forge({\n                branch: branch,\n                contents: contents\n              });\n            }))];\n\n          case 1:\n            results = _b.sent();\n\n            if (results.length === 0) {\n              throw new Error('At least one forger must be specified');\n            }\n\n            lastResult = results.pop();\n\n            while (results.length) {\n              currentResult = results.pop();\n\n              if (currentResult !== lastResult) {\n                throw new ForgingMismatchError([lastResult, currentResult]);\n              }\n\n              lastResult = currentResult;\n            }\n\n            return [2\n            /*return*/\n            , lastResult];\n        }\n      });\n    });\n  };\n\n  return CompositeForger;\n}();\n\nvar NoopParser =\n/** @class */\nfunction () {\n  function NoopParser() {}\n\n  NoopParser.prototype.prepareCodeOrigination = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , params];\n      });\n    });\n  };\n\n  return NoopParser;\n}();\n\nvar MichelCodecPacker =\n/** @class */\nfunction () {\n  function MichelCodecPacker() {}\n\n  MichelCodecPacker.prototype.packData = function (data) {\n    return __awaiter(this, void 0, void 0, function () {\n      var bytes;\n      return __generator(this, function (_a) {\n        bytes = packDataBytes(data.data, data.type).bytes;\n        return [2\n        /*return*/\n        , {\n          packed: bytes\n        }];\n      });\n    });\n  };\n\n  return MichelCodecPacker;\n}();\n/**\r\n * @packageDocumentation\r\n * @module @taquito/taquito\r\n */\n\n/**\r\n * @description Facade class that surfaces all of the libraries capability and allow it's configuration\r\n *\r\n * @param _rpc The RPC server to use\r\n */\n\n\nvar TezosToolkit =\n/** @class */\nfunction () {\n  function TezosToolkit(_rpc) {\n    this._rpc = _rpc;\n    this._options = {};\n    this.format = format;\n\n    if (typeof this._rpc === 'string') {\n      this._rpcClient = new RpcClient(this._rpc);\n    } else {\n      this._rpcClient = this._rpc;\n    }\n\n    this._context = new Context(_rpc);\n    this._wallet = new Wallet(this._context);\n    this.setProvider({\n      rpc: this._rpcClient\n    }); // tslint:disable-next-line: deprecation\n\n    this.batch = this._context.batch.batch.bind(this._context.batch);\n  }\n  /**\r\n   * @description Sets configuration on the Tezos Taquito instance. Allows user to choose which signer, rpc client, rpc url, forger and so forth\r\n   *\r\n   * @param options rpc url or rpcClient to use to interact with the Tezos network\r\n   *\r\n   * @example Tezos.setProvider({rpc: 'https://api.tez.ie/rpc/mainnet', signer: new InMemorySigner.fromSecretKey(“edsk...”)})\r\n   * @example Tezos.setProvider({ config: { confirmationPollingTimeoutSecond: 300 }})\r\n   *\r\n   */\n\n\n  TezosToolkit.prototype.setProvider = function (_a) {\n    var rpc = _a.rpc,\n        stream = _a.stream,\n        signer = _a.signer,\n        protocol = _a.protocol,\n        config = _a.config,\n        forger = _a.forger,\n        wallet = _a.wallet,\n        packer = _a.packer;\n    this.setRpcProvider(rpc);\n    this.setStreamProvider(stream);\n    this.setSignerProvider(signer);\n    this.setForgerProvider(forger);\n    this.setWalletProvider(wallet);\n    this.setPackerProvider(packer);\n    this._context.proto = protocol;\n    this._context.config = config;\n  };\n  /**\r\n   * @description Sets signer provider on the Tezos Taquito instance.\r\n   *\r\n   * @param options signer to use to interact with the Tezos network\r\n   *\r\n   * @example Tezos.setSignerProvider(new InMemorySigner.fromSecretKey('edsk...'))\r\n   *\r\n   */\n\n\n  TezosToolkit.prototype.setSignerProvider = function (signer) {\n    if (!this._options.signer && typeof signer === 'undefined') {\n      this._context.signer = new NoopSigner();\n      this._options.signer = signer;\n    } else if (typeof signer !== 'undefined') {\n      this._context.signer = signer;\n      this._options.signer = signer;\n    }\n  };\n  /**\r\n   * @description Sets rpc provider on the Tezos Taquito instance\r\n   *\r\n   * @param options rpc url or rpcClient to use to interact with the Tezos network\r\n   *\r\n   * @example Tezos.setRpcProvider('https://api.tez.ie/rpc/mainnet')\r\n   *\r\n   */\n\n\n  TezosToolkit.prototype.setRpcProvider = function (rpc) {\n    if (typeof rpc === 'string') {\n      this._rpcClient = new RpcClient(rpc);\n    } else if (rpc instanceof RpcClient) {\n      this._rpcClient = rpc;\n    }\n    /*     else if (this._options.rpc === undefined) {\r\n      this._rpcClient = new RpcClient();\r\n    } */\n\n\n    this._options.rpc = this._rpcClient;\n    this._context.rpc = this._rpcClient;\n  };\n  /**\r\n   * @description Sets forger provider on the Tezos Taquito instance\r\n   *\r\n   * @param options forger to use to interact with the Tezos network\r\n   *\r\n   * @example Tezos.setForgerProvider(localForger)\r\n   *\r\n   */\n\n\n  TezosToolkit.prototype.setForgerProvider = function (forger) {\n    var f = typeof forger === 'undefined' ? this.getFactory(RpcForger)() : forger;\n    this._options.forger = f;\n    this._context.forger = f;\n  };\n  /**\r\n   * @description Sets stream provider on the Tezos Taquito instance\r\n   *\r\n   * @param options stream to use to interact with the Tezos network\r\n   *\r\n   * @example Tezos.setStreamProvider(...)\r\n   *\r\n   */\n\n\n  TezosToolkit.prototype.setStreamProvider = function (stream) {\n    if (typeof stream === 'string') {\n      this._stream = new PollingSubscribeProvider(new Context(new RpcClient(stream)));\n    } else if (typeof stream !== 'undefined') {\n      this._stream = stream;\n    } else if (this._options.stream === undefined) {\n      this._stream = this.getFactory(PollingSubscribeProvider)();\n    }\n\n    this._options.stream = stream;\n  };\n  /**\r\n   * @description Sets wallet provider on the Tezos Taquito instance\r\n   *\r\n   * @param options wallet to use to interact with the Tezos network\r\n   *\r\n   * @example Tezos.setWalletProvider(...)\r\n   *\r\n   */\n\n\n  TezosToolkit.prototype.setWalletProvider = function (wallet) {\n    if (!this._options.wallet && typeof wallet === 'undefined') {\n      var w = this.getFactory(LegacyWalletProvider)();\n      this._options.wallet = w;\n      this._context.walletProvider = w;\n    } else if (typeof wallet !== 'undefined') {\n      this._options.wallet = wallet;\n      this._context.walletProvider = wallet;\n    }\n  };\n  /**\r\n   * @description Sets Packer provider on the Tezos Taquito instance\r\n   *\r\n   * @param options packer to use to interact with the Tezos network\r\n   *\r\n   * @example Tezos.setPackerProvider(new MichelCodecPacker())\r\n   *\r\n   */\n\n\n  TezosToolkit.prototype.setPackerProvider = function (packer) {\n    var p = typeof packer === 'undefined' ? this.getFactory(RpcPacker)() : packer;\n    this._options.packer = p;\n    this._context.packer = p;\n  };\n\n  Object.defineProperty(TezosToolkit.prototype, \"tz\", {\n    /**\r\n     * @description Provide access to tezos account management\r\n     */\n    get: function () {\n      return this._context.tz;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TezosToolkit.prototype, \"contract\", {\n    /**\r\n     * @description Provide access to smart contract utilities\r\n     */\n    get: function () {\n      return this._context.contract;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TezosToolkit.prototype, \"wallet\", {\n    get: function () {\n      return this._wallet;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TezosToolkit.prototype, \"operation\", {\n    get: function () {\n      return this._context.operationFactory;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TezosToolkit.prototype, \"estimate\", {\n    /**\r\n     * @description Provide access to operation estimation utilities\r\n     */\n    get: function () {\n      return this._context.estimate;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TezosToolkit.prototype, \"stream\", {\n    /**\r\n     * @description Provide access to streaming utilities backed by an streamer implementation\r\n     */\n    get: function () {\n      return this._stream;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TezosToolkit.prototype, \"rpc\", {\n    /**\r\n     * @description Provide access to the currently used rpc client\r\n     */\n    get: function () {\n      return this._context.rpc;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TezosToolkit.prototype, \"signer\", {\n    /**\r\n     * @description Provide access to the currently used signer\r\n     */\n    get: function () {\n      return this._context.signer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * @description Allow to add a module to the TezosToolkit instance. This method adds the appropriate Providers(s) required by the module to the internal context.\r\n   *\r\n   * @param module extension to add to the TezosToolkit instance\r\n   *\r\n   * @example Tezos.addExtension(new Tzip16Module());\r\n   */\n\n  TezosToolkit.prototype.addExtension = function (module) {\n    module.configureContext(this._context);\n  };\n\n  TezosToolkit.prototype.getFactory = function (ctor) {\n    var _this = this;\n\n    return function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return new (ctor.bind.apply(ctor, __spreadArray([void 0, _this._context], __read(args))))();\n    };\n  };\n  /**\r\n   * @description Gets an object containing the version of Taquito library and git sha of the commit this library is compiled from\r\n   */\n\n\n  TezosToolkit.prototype.getVersionInfo = function () {\n    return VERSION;\n  };\n\n  return TezosToolkit;\n}();\n\nexport { BatchOperation, BigMapAbstraction, ChainIds, CompositeForger, Context, ContractAbstraction, ContractMethod, ContractView, DEFAULT_FEE, DEFAULT_GAS_LIMIT, DEFAULT_STORAGE_LIMIT, DefaultLambdaAddresses, DelegateOperation, DelegationWalletOperation, InvalidCodeParameter, InvalidDelegationSource, InvalidInitParameter, InvalidParameterError, LegacyWalletProvider, MANAGER_LAMBDA, MichelCodecPacker, MichelCodecParser, MissedBlockDuringConfirmationError, NoopParser, Operation, OperationBatch, OriginationOperation, OriginationWalletOperation, PollingSubscribeProvider, Protocols, RpcForger, RpcPacker, TezosOperationError, TezosPreapplyFailureError, TezosToolkit, TransactionOperation, TransactionWalletOperation, UndefinedLambdaContractError, VIEW_LAMBDA, Wallet, WalletOperation, WalletOperationBatch, compose, createOriginationOperation, createRegisterDelegateOperation, createRevealOperation, createSetDelegateOperation, createTransferOperation, defaultConfig, protocols };","map":{"version":3,"sources":["../src/forger/rpc-forger.ts","../src/injector/rpc-injector.ts","../src/signer/noop.ts","../src/operations/types.ts","../src/operations/operation-errors.ts","../src/wallet/receipt.ts","../src/wallet/operation.ts","../src/wallet/delegation-operation.ts","../src/wallet/origination-operation.ts","../src/wallet/transaction-operation.ts","../src/wallet/operation-factory.ts","../src/constants.ts","../src/operations/operation-emitter.ts","../src/operations/operations.ts","../src/tz/rpc-tz-provider.ts","../src/contract/estimate.ts","../src/format.ts","../src/contract/errors.ts","../src/contract/prepare.ts","../src/contract/rpc-estimate-provider.ts","../src/operations/batch-operation.ts","../src/batch/rpc-batch-provider.ts","../src/operations/delegate-operation.ts","../src/operations/origination-operation.ts","../src/operations/reveal-operation.ts","../src/operations/transaction-operation.ts","../src/contract/manager-lambda.ts","../src/contract/view_lambda.ts","../src/contract/compose.ts","../src/wallet/wallet.ts","../src/wallet/legacy.ts","../src/contract/lambda-view.ts","../src/contract/contract.ts","../src/contract/big-map.ts","../src/contract/sapling-state-abstraction.ts","../src/contract/semantic.ts","../src/contract/rpc-contract-provider.ts","../src/parser/michel-codec-parser.ts","../src/packer/rpc-packer.ts","../src/context.ts","../src/subscribe/filters.ts","../src/subscribe/observable-subscription.ts","../src/subscribe/polling-provider.ts","../src/version.ts","../src/forger/composite-forger.ts","../src/parser/noop-parser.ts","../src/packer/michel-codec-packer.ts","../src/taquito.ts"],"names":[],"mappings":"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","sourcesContent":["import { Forger, ForgeParams, ForgeResponse } from './interface';\nimport { Context } from '../context';\n\nexport class RpcForger implements Forger {\n  constructor(private context: Context) {}\n\n  forge({ branch, contents }: ForgeParams): Promise<ForgeResponse> {\n    return this.context.rpc.forgeOperations({ branch, contents });\n  }\n}\n","import { Injector } from './interface';\nimport { Context } from '../context';\n\nexport class RpcInjector implements Injector {\n  constructor(private context: Context) {}\n  inject(signedOperationBytes: string): Promise<string> {\n    return this.context.rpc.injectOperation(signedOperationBytes);\n  }\n}\n","import { Signer } from './interface';\n\nexport class UnconfiguredSignerError implements Error {\n  name = 'UnconfiguredSignerError';\n  message =\n    'No signer has been configured. Please configure one by calling setProvider({signer}) on your TezosToolkit instance.';\n}\n\n/**\n * @description Default signer implementation which does nothing and produce invalid signature\n */\nexport class NoopSigner implements Signer {\n  async publicKey(): Promise<string> {\n    throw new UnconfiguredSignerError();\n  }\n  async publicKeyHash(): Promise<string> {\n    throw new UnconfiguredSignerError();\n  }\n  async secretKey(): Promise<string> {\n    throw new UnconfiguredSignerError();\n  }\n  async sign(_bytes: string, _watermark?: Uint8Array): Promise<any> {\n    throw new UnconfiguredSignerError();\n  }\n}\n","import {\n  OperationObject,\n  InternalOperationResultKindEnum,\n  OpKind,\n  TransactionOperationParameter,\n} from '@taquito/rpc';\n\nexport { OpKind } from '@taquito/rpc';\n\nexport type withKind<T, K extends OpKind> = T & { kind: K };\n\nexport type ParamsWithKind =\n  | withKind<OriginateParams, OpKind.ORIGINATION>\n  | withKind<DelegateParams, OpKind.DELEGATION>\n  | withKind<TransferParams, OpKind.TRANSACTION>\n  | withKind<ActivationParams, OpKind.ACTIVATION>;\n\nexport type ParamsWithKindExtended = ParamsWithKind | withKind<RevealParams, OpKind.REVEAL>;\n\nexport const attachKind = <T, K extends OpKind>(op: T, kind: K) => {\n  return { ...op, kind } as withKind<T, K>;\n};\n\nexport const findWithKind = <T extends { kind: OpKind }, K extends OpKind>(\n  arr: T[],\n  kind: K\n): (T & { kind: K }) | undefined => {\n  if (Array.isArray(arr)) {\n    const found = arr.find((op) => op.kind === kind);\n\n    if (found && isKind(found, kind)) {\n      return found;\n    }\n  }\n};\n\nexport const isKind = <T extends { kind: OpKind }, K extends OpKind>(\n  op: T,\n  kind: K\n): op is withKind<T, K> => {\n  return op.kind === kind;\n};\n\nexport type RPCOpWithFee =\n  | RPCTransferOperation\n  | RPCOriginationOperation\n  | RPCDelegateOperation\n  | RPCRevealOperation;\nexport type RPCOpWithSource =\n  | RPCTransferOperation\n  | RPCOriginationOperation\n  | RPCDelegateOperation\n  | RPCRevealOperation;\n\nexport const isOpWithFee = <T extends { kind: OpKind }>(\n  op: T\n): op is withKind<T, InternalOperationResultKindEnum> => {\n  return ['transaction', 'delegation', 'origination', 'reveal'].indexOf(op.kind) !== -1;\n};\n\nexport const isOpRequireReveal = <T extends { kind: OpKind }>(\n  op: T\n): op is withKind<T, Exclude<InternalOperationResultKindEnum, OpKind.REVEAL>> => {\n  return ['transaction', 'delegation', 'origination'].indexOf(op.kind) !== -1;\n};\n\nexport type SourceKinds = InternalOperationResultKindEnum;\n\nexport const isSourceOp = <T extends { kind: OpKind }>(op: T): op is withKind<T, SourceKinds> => {\n  return ['transaction', 'delegation', 'origination', 'reveal', 'ballot'].indexOf(op.kind) !== -1;\n};\n\nexport const hasMetadata = <T extends { kind: OpKind }, K>(\n  op: T\n): op is T & {\n  metadata: K;\n} => {\n  return 'metadata' in op;\n};\n\nexport const hasMetadataWithResult = <T extends { kind: OpKind }, K>(\n  op: T\n): op is T & {\n  metadata: {\n    operation_result: K;\n  };\n} => {\n  return hasMetadata<T, any>(op) && 'operation_result' in op.metadata;\n};\n\nexport const hasMetadataWithInternalOperationResult = <T extends { kind: OpKind }, K>(\n  op: T\n): op is T & {\n  metadata: {\n    internal_operation_results?: K;\n  };\n} => {\n  return hasMetadata<T, any>(op) && 'internal_operation_results' in op.metadata;\n};\n\nexport interface GasConsumingOperation {\n  consumedGas?: string;\n  gasLimit: number;\n}\n\nexport interface StorageConsumingOperation {\n  storageDiff?: string;\n  storageSize?: string;\n  storageLimit: number;\n}\n\nexport interface FeeConsumingOperation {\n  fee: number;\n}\n\nexport type OriginateParamsBase = {\n  balance?: string;\n  code: string | object[];\n  delegate?: string;\n  fee?: number;\n  gasLimit?: number;\n  storageLimit?: number;\n  mutez?: boolean;\n};\n\n/**\n * @description Parameters for originate method\n */\nexport type OriginateParams = OriginateParamsBase &\n  (\n    | {\n        init?: never;\n        /** JS representation of a storage object */\n        storage: any;\n      }\n    | {\n        /** Initial storage object value. Either Micheline or JSON encoded */\n        init: string | object;\n        storage?: never;\n      }\n  );\n\nexport interface ActivationParams {\n  pkh: string;\n  secret: string;\n}\n\n/**\n * @description RPC origination operation\n */\nexport interface RPCOriginationOperation {\n  kind: OpKind.ORIGINATION;\n  fee: number;\n  gas_limit: number;\n  storage_limit: number;\n  balance: string;\n  delegate?: string;\n  source?: string;\n  script: {\n    code: any;\n    storage: any;\n  };\n}\n\n/**\n * @description RPC reveal operation\n */\nexport interface RPCRevealOperation {\n  kind: OpKind.REVEAL;\n  fee: number;\n  public_key: string;\n  source?: string;\n  gas_limit: number;\n  storage_limit: number;\n}\n\nexport interface RevealParams {\n  fee?: number;\n  gasLimit?: number;\n  storageLimit?: number;\n}\n\n/**\n * @description Result of a forge operation contains the operation plus its encoded version\n */\nexport interface ForgedBytes {\n  opbytes: string;\n  opOb: OperationObject;\n  counter: number;\n}\n\n/**\n * @description Parameters for setDelegate method\n */\nexport interface DelegateParams {\n  source: string;\n  delegate: string;\n  fee?: number;\n  gasLimit?: number;\n  storageLimit?: number;\n}\n\n/**\n * @description Parameters for registerDelegate method\n */\nexport interface RegisterDelegateParams {\n  fee?: number;\n  gasLimit?: number;\n  storageLimit?: number;\n}\n\n/**\n * @description RPC delegation operation\n */\nexport interface RPCDelegateOperation {\n  kind: OpKind.DELEGATION;\n  source?: string;\n  fee: number;\n  gas_limit: number;\n  storage_limit: number;\n  delegate: string;\n}\n\n/**\n * @description Parameters for transfer method\n */\nexport interface TransferParams {\n  to: string;\n  source?: string;\n  amount: number;\n  fee?: number;\n  parameter?: TransactionOperationParameter;\n  gasLimit?: number;\n  storageLimit?: number;\n  mutez?: boolean;\n}\n\n/**\n * @description RPC transfer operation\n */\nexport interface RPCTransferOperation {\n  kind: OpKind.TRANSACTION;\n  fee: number;\n  gas_limit: number;\n  storage_limit: number;\n  amount: string;\n  source?: string;\n  destination: string;\n  parameters?: TransactionOperationParameter;\n}\n\n/**\n * @description RPC activate account operation\n */\nexport interface RPCActivateOperation {\n  kind: OpKind.ACTIVATION;\n  pkh: string;\n  secret: string;\n}\n\nexport type RPCOperation =\n  | RPCOriginationOperation\n  | RPCTransferOperation\n  | RPCDelegateOperation\n  | RPCRevealOperation\n  | RPCActivateOperation;\n\nexport type PrepareOperationParams = {\n  operation: RPCOperation | RPCOperation[];\n  source?: string;\n};\n","import {\n  MichelsonV1ExpressionBase,\n  OperationResultDelegation,\n  OperationResultOrigination,\n  OperationResultReveal,\n  OperationResultTransaction,\n  PreapplyResponse,\n  TezosGenericOperationError,\n} from '@taquito/rpc';\nimport {\n  hasMetadata,\n  hasMetadataWithInternalOperationResult,\n  hasMetadataWithResult,\n} from './types';\n\nexport interface TezosOperationErrorWithMessage extends TezosGenericOperationError {\n  with: MichelsonV1ExpressionBase;\n}\n\nconst isErrorWithMessage = (error: any): error is TezosOperationErrorWithMessage => {\n  return 'with' in error;\n};\n\nexport class TezosOperationError implements Error {\n  name: string = 'TezosOperationError';\n  id: string;\n  kind: string;\n  message: string;\n\n  constructor(public errors: TezosGenericOperationError[]) {\n    // Last error is 'often' the one with more detail\n    const lastError = errors[errors.length - 1];\n\n    this.id = lastError.id;\n    this.kind = lastError.kind;\n\n    this.message = `(${this.kind}) ${this.id}`;\n\n    if (isErrorWithMessage(lastError) && lastError.with.string) {\n      this.message = lastError.with.string;\n    }\n  }\n}\n\nexport class TezosPreapplyFailureError implements Error {\n  name: string = 'TezosPreapplyFailureError';\n  message: string = 'Preapply returned an unexpected result';\n\n  constructor(public result: any) {}\n}\n\nexport type MergedOperationResult = OperationResultDelegation &\n  OperationResultOrigination &\n  OperationResultTransaction &\n  OperationResultReveal & {\n    fee?: string;\n  };\n\n// Flatten all operation content results and internal operation results into a single array\n// Some cases where we can have multiple operation results or internal operation results are:\n// - When an operation includes a reveal operation\n// - When an operation is made using the batch API\n// - Smart contract call can contains internal operation results when they call other smart contract internally or originate contracts\nexport const flattenOperationResult = (response: PreapplyResponse | PreapplyResponse[]) => {\n  let results = Array.isArray(response) ? response : [response];\n\n  let returnedResults: MergedOperationResult[] = [];\n  for (let i = 0; i < results.length; i++) {\n    for (let j = 0; j < results[i].contents.length; j++) {\n      const content = results[i].contents[j];\n      if (hasMetadataWithResult(content)) {\n        returnedResults.push({\n          fee: content.fee,\n          ...content.metadata.operation_result,\n        });\n\n        if (Array.isArray(content.metadata.internal_operation_results)) {\n          content.metadata.internal_operation_results.forEach(x => returnedResults.push(x.result));\n        }\n      }\n    }\n  }\n\n  return returnedResults;\n};\n\n/***\n * @description Flatten all error from preapply response (including internal error)\n */\nexport const flattenErrors = (\n  response: PreapplyResponse | PreapplyResponse[],\n  status = 'failed'\n) => {\n  let results = Array.isArray(response) ? response : [response];\n\n  let errors: TezosGenericOperationError[] = [];\n  // Transaction that do not fail will be backtracked in case one failure occur\n  for (let i = 0; i < results.length; i++) {\n    for (let j = 0; j < results[i].contents.length; j++) {\n      const content = results[i].contents[j];\n      if (hasMetadata(content)) {\n        if (hasMetadataWithResult(content) && content.metadata.operation_result.status === status) {\n          errors = errors.concat(content.metadata.operation_result.errors || []);\n        }\n        if (\n          hasMetadataWithInternalOperationResult(content) &&\n          Array.isArray(content.metadata.internal_operation_results)\n        ) {\n          for (const internalResult of content.metadata.internal_operation_results) {\n            if ('result' in internalResult && internalResult.result.status === status) {\n              errors = errors.concat(internalResult.result.errors || []);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return errors;\n};\n","import { OperationContentsAndResult } from '@taquito/rpc';\nimport BigNumber from 'bignumber.js';\nimport { flattenOperationResult } from '../operations/operation-errors';\n\nexport interface Receipt {\n  totalFee: BigNumber;\n  totalGas: BigNumber;\n  totalStorage: BigNumber;\n  totalAllocationBurn: BigNumber;\n  totalOriginationBurn: BigNumber;\n  totalPaidStorageDiff: BigNumber;\n  totalStorageBurn: BigNumber;\n}\n\nexport const receiptFromOperation = (\n  op: OperationContentsAndResult[],\n  { ALLOCATION_BURN, ORIGINATION_BURN } = {\n    ALLOCATION_BURN: 257,\n    ORIGINATION_BURN: 257,\n  }\n): Receipt => {\n  const operationResults = flattenOperationResult({ contents: op });\n  let totalGas = new BigNumber(0);\n  let totalStorage = new BigNumber(0);\n  let totalFee = new BigNumber(0);\n  let totalOriginationBurn = new BigNumber(0);\n  let totalAllocationBurn = new BigNumber(0);\n  let totalPaidStorageDiff = new BigNumber(0);\n  operationResults.forEach(result => {\n    totalFee = totalFee.plus(result.fee || 0);\n    totalOriginationBurn = totalOriginationBurn.plus(\n      Array.isArray(result.originated_contracts)\n        ? result.originated_contracts.length * ORIGINATION_BURN\n        : 0\n    );\n    totalAllocationBurn = totalAllocationBurn.plus(\n      'allocated_destination_contract' in result ? ALLOCATION_BURN : 0\n    );\n    totalGas = totalGas.plus(result.consumed_gas || 0);\n    totalPaidStorageDiff = totalPaidStorageDiff.plus(\n      'paid_storage_size_diff' in result ? Number(result.paid_storage_size_diff) || 0 : 0\n    );\n  });\n\n  totalStorage = totalStorage\n    .plus(totalAllocationBurn)\n    .plus(totalOriginationBurn)\n    .plus(totalPaidStorageDiff);\n\n  return {\n    totalFee,\n    totalGas,\n    totalStorage,\n    totalAllocationBurn,\n    totalOriginationBurn,\n    totalPaidStorageDiff,\n    totalStorageBurn: new BigNumber(totalStorage.multipliedBy(1000)),\n  };\n};\n","import { BlockResponse, OperationContentsAndResult, OperationResultStatusEnum } from '@taquito/rpc';\nimport { combineLatest, from, Observable, ReplaySubject } from 'rxjs';\nimport {\n  distinctUntilChanged,\n  filter,\n  first,\n  map,\n  shareReplay,\n  takeWhile,\n  tap,\n} from 'rxjs/operators';\nimport { Context } from '../context';\nimport { Receipt, receiptFromOperation } from './receipt';\n\nexport type OperationStatus = 'pending' | 'unknown' | OperationResultStatusEnum;\n\nexport class MissedBlockDuringConfirmationError implements Error {\n  name: string = 'MissedBlockDuringConfirmationError';\n  message: string =\n    'Taquito missed a block while waiting for operation confirmation and was not able to find the operation';\n}\n\nconst MAX_BRANCH_ANCESTORS = 60;\n\n/**\n * @description WalletOperation allows to monitor operation inclusion on chains and surface information related to the operation\n */\nexport class WalletOperation {\n  protected _operationResult = new ReplaySubject<OperationContentsAndResult[]>(1);\n  protected _includedInBlock = new ReplaySubject<BlockResponse>(1);\n  protected _included = false;\n\n  private lastHead: BlockResponse | undefined;\n  protected newHead$: Observable<BlockResponse> = this._newHead$.pipe(\n    tap(newHead => {\n      if (\n        !this._included &&\n        this.lastHead &&\n        newHead.header.level - this.lastHead.header.level > 1\n      ) {\n        throw new MissedBlockDuringConfirmationError();\n      }\n\n      this.lastHead = newHead;\n    }),\n    shareReplay({ bufferSize: 1, refCount: true })\n  );\n\n  // Observable that emit once operation is seen in a block\n  private confirmed$ = this.newHead$.pipe(\n    map(head => {\n      for (const opGroup of head.operations) {\n        for (const op of opGroup) {\n          if (op.hash === this.opHash) {\n            this._included = true;\n            this._includedInBlock.next(head);\n            this._operationResult.next(op.contents as OperationContentsAndResult[]);\n\n            // Return the block where the operation was found\n            return head;\n          }\n        }\n      }\n    }),\n    filter<BlockResponse | undefined, BlockResponse>((x): x is BlockResponse => {\n      return typeof x !== 'undefined';\n    }),\n    first(),\n    shareReplay({ bufferSize: 1, refCount: true })\n  );\n\n  async operationResults() {\n    return this._operationResult.pipe(first()).toPromise();\n  }\n\n  /**\n   * @description Receipt expose the total amount of tezos token burn and spent on fees\n   * The promise returned by receipt will resolve only once the transaction is included\n   */\n  async receipt(): Promise<Receipt> {\n    return receiptFromOperation(await this.operationResults());\n  }\n\n  /**\n   *\n   * @param opHash Operation hash\n   * @param raw Raw operation that was injected\n   * @param context Taquito context allowing access to rpc and signer\n   */\n  constructor(\n    public readonly opHash: string,\n    protected readonly context: Context,\n    private _newHead$: Observable<BlockResponse>\n  ) {\n    this.confirmed$.pipe(first()).subscribe();\n  }\n\n  async getCurrentConfirmation() {\n    if (!this._included) {\n      return 0;\n    }\n\n    return combineLatest([this._includedInBlock, from(this.context.rpc.getBlock())])\n      .pipe(\n        map(([foundAtBlock, head]) => {\n          return head.header.level - foundAtBlock.header.level + 1;\n        }),\n        first()\n      )\n      .toPromise();\n  }\n\n  async isInCurrentBranch(tipBlockIdentifier: string = 'head') {\n    // By default it is assumed that the operation is in the current branch\n    if (!this._included) {\n      return true;\n    }\n\n    const tipBlockHeader = await this.context.rpc.getBlockHeader({ block: tipBlockIdentifier });\n    const inclusionBlock = await this._includedInBlock.pipe(first()).toPromise();\n\n    const levelDiff = tipBlockHeader.level - inclusionBlock.header.level;\n\n    // Block produced before the operation is included are assumed to be part of the current branch\n    if (levelDiff <= 0) {\n      return true;\n    }\n\n    const tipBlockLevel = Math.min(\n      inclusionBlock.header.level + levelDiff,\n      inclusionBlock.header.level + MAX_BRANCH_ANCESTORS\n    );\n\n    const blocks = new Set(await this.context.rpc.getLiveBlocks({ block: String(tipBlockLevel) }));\n    return blocks.has(inclusionBlock.hash);\n  }\n\n  confirmationObservable(confirmations?: number) {\n    if (typeof confirmations !== 'undefined' && confirmations < 1) {\n      throw new Error('Confirmation count must be at least 1');\n    }\n\n    const { defaultConfirmationCount } = this.context.config;\n\n    const conf = confirmations !== undefined ? confirmations : defaultConfirmationCount;\n\n    if (conf === undefined) {\n      throw new Error('Default confirmation count can not be undefined!');\n    }\n    \n    return combineLatest([this._includedInBlock, this.newHead$]).pipe(\n      distinctUntilChanged(([, previousHead], [, newHead]) => {\n        return previousHead.hash === newHead.hash;\n      }),\n      map(([foundAtBlock, head]) => {\n        return {\n          block: head,\n          expectedConfirmation: conf,\n          currentConfirmation: head.header.level - foundAtBlock.header.level + 1,\n          completed: head.header.level - foundAtBlock.header.level >= conf - 1,\n          isInCurrentBranch: () => this.isInCurrentBranch(head.hash),\n        };\n      }),\n      takeWhile(({ completed }) => !completed, true)\n    );\n  }\n\n  /**\n   *\n   * @param confirmations [0] Number of confirmation to wait for\n   */\n  confirmation(confirmations?: number) {\n    return this.confirmationObservable(confirmations).toPromise();\n  }\n}\n","import { BlockResponse, OperationContentsAndResultReveal, OpKind } from '@taquito/rpc';\nimport { Observable } from 'rxjs';\nimport { Context } from '../context';\nimport { WalletOperation, OperationStatus } from './operation';\n\nexport class DelegationWalletOperation extends WalletOperation {\n  constructor(\n    public readonly opHash: string,\n    protected readonly context: Context,\n    newHead$: Observable<BlockResponse>\n  ) {\n    super(opHash, context, newHead$);\n  }\n\n  public async revealOperation() {\n    const operationResult = await this.operationResults();\n    return operationResult.find(x => x.kind === OpKind.REVEAL) as\n      | OperationContentsAndResultReveal\n      | undefined;\n  }\n\n  public async delegationOperation() {\n    const operationResult = await this.operationResults();\n    return operationResult.find(x => x.kind === OpKind.DELEGATION) as\n      | OperationContentsAndResultReveal\n      | undefined;\n  }\n\n  public async status(): Promise<OperationStatus> {\n    if (!this._included) {\n      return 'pending';\n    }\n\n    const op = await this.delegationOperation();\n    if (!op) {\n      return 'unknown';\n    }\n\n    return op.metadata.operation_result.status;\n  }\n}\n","import {\n  BlockResponse,\n  OperationContentsAndResultOrigination,\n  OperationContentsAndResultReveal,\n  OpKind,\n} from '@taquito/rpc';\nimport { Observable } from 'rxjs';\nimport { Context } from '../context';\nimport { findWithKind } from '../operations/types';\nimport { WalletOperation, OperationStatus } from './operation';\n\nexport class OriginationWalletOperation extends WalletOperation {\n  constructor(\n    public readonly opHash: string,\n    protected readonly context: Context,\n    newHead$: Observable<BlockResponse>\n  ) {\n    super(opHash, context, newHead$);\n  }\n\n  public async originationOperation() {\n    const operationResult = await this.operationResults();\n    return findWithKind(operationResult, OpKind.ORIGINATION) as\n      | OperationContentsAndResultOrigination\n      | undefined;\n  }\n\n  public async revealOperation() {\n    const operationResult = await this.operationResults();\n    return findWithKind(operationResult, OpKind.REVEAL) as\n      | OperationContentsAndResultReveal\n      | undefined;\n  }\n\n  public async status(): Promise<OperationStatus> {\n    if (!this._included) {\n      return 'pending';\n    }\n\n    const op = await this.originationOperation();\n    if (!op) {\n      return 'unknown';\n    }\n\n    return op.metadata.operation_result.status;\n  }\n\n  public async contract() {\n    const op = await this.originationOperation();\n    const address = (op!.metadata.operation_result.originated_contracts || [])[0];\n    return this.context.wallet.at(address);\n  }\n}\n","import { WalletOperation, OperationStatus } from './operation';\nimport { Context } from '../context';\nimport { Observable } from 'rxjs';\nimport {\n  BlockResponse,\n  OpKind,\n  OperationContentsAndResultReveal,\n  OperationContentsAndResultTransaction,\n} from '@taquito/rpc';\n\nexport class TransactionWalletOperation extends WalletOperation {\n  constructor(\n    public readonly opHash: string,\n    protected readonly context: Context,\n    newHead$: Observable<BlockResponse>\n  ) {\n    super(opHash, context, newHead$);\n  }\n\n  public async revealOperation() {\n    const operationResult = await this.operationResults();\n    return operationResult.find(x => x.kind === OpKind.REVEAL) as\n      | OperationContentsAndResultReveal\n      | undefined;\n  }\n\n  public async transactionOperation() {\n    const operationResult = await this.operationResults();\n    return operationResult.find(x => x.kind === OpKind.TRANSACTION) as\n      | OperationContentsAndResultTransaction\n      | undefined;\n  }\n\n  public async status(): Promise<OperationStatus> {\n    if (!this._included) {\n      return 'pending';\n    }\n\n    const op = await this.transactionOperation();\n    if (!op) {\n      return 'unknown';\n    }\n\n    return op.metadata.operation_result.status;\n  }\n}\n","import { BlockResponse } from '@taquito/rpc';\nimport {\n  concat,\n  defer,\n  from,\n  MonoTypeOperatorFunction,\n  Observable,\n  of,\n  range,\n  ReplaySubject,\n  SchedulerLike,\n  throwError,\n  timer,\n} from 'rxjs';\nimport {\n  concatMap,\n  distinctUntilKeyChanged,\n  first,\n  shareReplay,\n  startWith,\n  switchMap,\n  timeoutWith,\n} from 'rxjs/operators';\nimport { Context } from '../context';\nimport { DelegationWalletOperation } from './delegation-operation';\nimport { WalletOperation } from './operation';\nimport { OriginationWalletOperation } from './origination-operation';\nimport { TransactionWalletOperation } from './transaction-operation';\n\nexport const cacheUntil = <T>(\n  cacheUntilObs: Observable<any>\n): MonoTypeOperatorFunction<T> => source => {\n  let subject: ReplaySubject<T> | null = null;\n\n  return defer(() => {\n    if (!subject) {\n      subject = new ReplaySubject<T>();\n      source.pipe(first()).subscribe(subject);\n      cacheUntilObs.pipe(first()).subscribe(() => {\n        subject = null;\n      });\n    }\n\n    return subject;\n  });\n};\n\nexport const createNewPollingBasedHeadObservable = (\n  pollingTimer: Observable<number>,\n  sharedHeadOb: Observable<BlockResponse>,\n  context: Context,\n  scheduler?: SchedulerLike\n): Observable<BlockResponse> => {  \n  \n  if (context.config.confirmationPollingTimeoutSecond === undefined) {\n    throw new Error('Confirmation polling timeout second can not be undefined!');\n  }\n\n  return pollingTimer.pipe(\n    switchMap(() => sharedHeadOb),\n    distinctUntilKeyChanged('hash'),\n    timeoutWith(\n      context.config.confirmationPollingTimeoutSecond * 1000,\n      throwError(new Error('Confirmation polling timed out')),\n      scheduler\n    ),\n    shareReplay({\n      refCount: true,\n      scheduler,\n    })\n  );\n};\n\nexport interface OperationFactoryConfig {\n  blockIdentifier?: string;\n}\n\nexport class OperationFactory {\n  constructor(private context: Context) {}\n\n  // Cache the last block for one second across all operations\n  private sharedHeadObs = defer(() => from(this.context.rpc.getBlock())).pipe(\n    cacheUntil(timer(0, 1000))\n  );\n\n  private async createNewHeadObservable() {\n    const confirmationPollingIntervalSecond = this.context.config.confirmationPollingIntervalSecond !== undefined \n                                        ? this.context.config.confirmationPollingIntervalSecond \n                                        : await this.context.getConfirmationPollingInterval();\n    return createNewPollingBasedHeadObservable(\n      timer(0, confirmationPollingIntervalSecond * 1000),\n      this.sharedHeadObs,\n      this.context\n    );\n  }\n\n  private createPastBlockWalker(startBlock: string, count: number = 1) {\n    return from(this.context.rpc.getBlock({ block: startBlock })).pipe(\n      switchMap(block => {\n        if (count === 1) {\n          return of(block);\n        }\n\n        return range(block.header.level, count - 1).pipe(\n          startWith(block),\n          concatMap(async level => {\n            return this.context.rpc.getBlock({ block: String(level) });\n          })\n        );\n      })\n    );\n  }\n\n  private async createHeadObservableFromConfig({ blockIdentifier }: OperationFactoryConfig) {\n    const observableSequence: Observable<BlockResponse>[] = [];\n\n    if (blockIdentifier) {\n      observableSequence.push(this.createPastBlockWalker(blockIdentifier));\n    }\n\n    observableSequence.push(await this.createNewHeadObservable());\n\n    return concat(...observableSequence);\n  }\n\n  async createOperation(hash: string, config: OperationFactoryConfig = {}): Promise<WalletOperation> {\n    return new WalletOperation(\n      hash,\n      this.context.clone(),\n      await this.createHeadObservableFromConfig(config)\n    );\n  }\n\n  async createTransactionOperation(\n    hash: string,\n    config: OperationFactoryConfig = {}\n  ): Promise<TransactionWalletOperation> {\n    return new TransactionWalletOperation(\n      hash,\n      this.context.clone(),\n      await this.createHeadObservableFromConfig(config)\n    );\n  }\n\n  async createDelegationOperation(\n    hash: string,\n    config: OperationFactoryConfig = {}\n  ): Promise<DelegationWalletOperation> {\n    return new DelegationWalletOperation(\n      hash,\n      this.context.clone(),\n      await this.createHeadObservableFromConfig(config)\n    );\n  }\n\n  async createOriginationOperation(\n    hash: string,\n    config: OperationFactoryConfig = {}\n  ): Promise<OriginationWalletOperation> {\n    return new OriginationWalletOperation(\n      hash,\n      this.context.clone(),\n      await this.createHeadObservableFromConfig(config)\n    );\n  }\n}\n","export enum DEFAULT_GAS_LIMIT {\n  DELEGATION = 10600,\n  ORIGINATION = 10600,\n  TRANSFER = 10600,\n  REVEAL = 10600,\n}\nexport enum DEFAULT_FEE {\n  DELEGATION = 1257,\n  ORIGINATION = 10000,\n  TRANSFER = 10000,\n  REVEAL = 1420,\n}\nexport enum DEFAULT_STORAGE_LIMIT {\n  DELEGATION = 0,\n  ORIGINATION = 257,\n  TRANSFER = 257,\n  REVEAL = 0,\n}\n\nexport enum Protocols {\n  Pt24m4xi = 'Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd',\n  PsBABY5H = 'PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU',\n  PsBabyM1 = 'PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS',\n  PsCARTHA = 'PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb',\n  PsDELPH1 = 'PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo',\n  PtEdo2Zk = 'PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA',\n  PsFLorena = 'PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i',\n  PtGRANADs = 'PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV'\n}\n\nexport const protocols = {\n  '004': [Protocols.Pt24m4xi],\n  '005': [Protocols.PsBABY5H, Protocols.PsBabyM1],\n  '006': [Protocols.PsCARTHA],\n  '007': [Protocols.PsDELPH1],\n  '008': [Protocols.PtEdo2Zk], // edonet v2\n  '009': [Protocols.PsFLorena],\n  '010': [Protocols.PtGRANADs]\n};\n\nexport enum DefaultLambdaAddresses {\n  MAINNET = 'KT1CPuTzwC7h7uLXd5WQmpMFso1HxrLBUtpE',\n  CARTHAGENET = 'KT1VAy1o1FGiXYfD3YT7x7k5eF5HSHhmc1u6',\n  DELPHINET = 'KT19abMFs3haqyKYwqdLjK9GbtofryZLvpiK',\n  EDONET = 'KT1A64nVZDccAHGAsf1ZyVajXZcbiwjV3SnN',\n  FLORENCENET = 'KT1KCe3YqGnudsiCWb5twbe2DH5T3EMdLpSE',\n  GRANADANET = 'KT1BCun2vsA4GBQvsKAuGD5x873MfW2jsN9z'\n}\n\nexport enum ChainIds {\n  MAINNET = \"NetXdQprcVkpaWU\",\n  CARTHAGENET = \"NetXjD3HPJJjmcd\",\n  DELPHINET = \"NetXm8tYqnMWky1\",\n  EDONET = \"NetXSgo1ZT2DRUG\",\n  FLORENCENET = \"NetXxkAx4woPLyu\",\n  GRANADANET = \"NetXz969SFaFn8k\" \n}\n","import {\n  OperationContents,\n  OperationContentsAndResult,\n  OperationObject,\n  OpKind,\n  PreapplyResponse,\n  RpcClient,\n  RPCRunOperationParam,\n} from '@taquito/rpc';\nimport { Protocols } from '../constants';\nimport { Context } from '../context';\nimport { Estimate } from '../contract/estimate';\nimport { flattenErrors, TezosOperationError, TezosPreapplyFailureError } from './operation-errors';\nimport {\n  ForgedBytes,\n  isOpRequireReveal,\n  ParamsWithKind,\n  PrepareOperationParams,\n  RPCOperation,\n  RPCOpWithFee,\n  RPCOpWithSource,\n} from './types';\n\n// RPC requires a signature but does not verify it\nexport const SIGNATURE_STUB =\n  'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg';\n\nexport interface PreparedOperation {\n  opOb: {\n    branch: string;\n    contents: OperationContents[];\n    protocol: string;\n  };\n  counter: number;\n}\n\nexport interface PreparedOperationSimulation {\n  opOb: {\n    branch: string;\n    contents: OperationContents[];\n  };\n  counter: number;\n}\n\nexport interface PreparedOpAndSimulation {\n  preparedOp: PreparedOperation;\n  preparedOpSimulation?: PreparedOperationSimulation;\n}\n\nexport abstract class OperationEmitter {\n  get rpc(): RpcClient {\n    return this.context.rpc;\n  }\n\n  get signer() {\n    return this.context.signer;\n  }\n\n  constructor(protected context: Context) {}\n\n  protected async isRevealOpNeeded(op: RPCOperation[] | ParamsWithKind[], pkh: string) {\n    return !(await this.isAccountRevealRequired(pkh)) || !this.isRevealRequiredForOpType(op)\n      ? false\n      : true;\n  }\n\n  protected async isAccountRevealRequired(publicKeyHash: string) {\n    const manager = await this.rpc.getManagerKey(publicKeyHash);\n    const haveManager = manager && typeof manager === 'object' ? !!manager.key : !!manager;\n    return !haveManager;\n  }\n\n  protected isRevealRequiredForOpType(op: RPCOperation[] | ParamsWithKind[]) {\n    let opRequireReveal = false;\n    for (const operation of op) {\n      if (isOpRequireReveal(operation)) {\n        opRequireReveal = true;\n      }\n    }\n    return opRequireReveal;\n  }\n\n  private constructOps = (\n    cOps: RPCOperation[],\n    publicKeyHash: string,\n    headCounter: number,\n    counterFunction: (\n      publicKeyHash: string,\n      counter: number,\n      counterScope: { [key: string]: number }\n    ) => { counter: string },\n    source?: string\n  ): OperationContents[] => {\n    const counters = {};\n    // tslint:disable strict-type-predicates\n    return cOps.map((op: RPCOperation) => {\n      switch (op.kind) {\n        case OpKind.ACTIVATION:\n          return {\n            ...op,\n          };\n        case OpKind.REVEAL:\n          return {\n            ...op,\n            ...this.getSource(op, publicKeyHash, source),\n            ...counterFunction(publicKeyHash, headCounter, counters),\n            ...this.getFee(op),\n          };\n        case OpKind.ORIGINATION:\n          return {\n            ...op,\n            balance: typeof op.balance !== 'undefined' ? `${op.balance}` : '0',\n            ...this.getSource(op, publicKeyHash, source),\n            ...counterFunction(publicKeyHash, headCounter, counters),\n            ...this.getFee(op),\n          };\n        case OpKind.TRANSACTION:\n          const cops = {\n            ...op,\n            amount: typeof op.amount !== 'undefined' ? `${op.amount}` : '0',\n            ...this.getSource(op, publicKeyHash, source),\n            ...counterFunction(publicKeyHash, headCounter, counters),\n            ...this.getFee(op),\n          };\n          if (cops.source.toLowerCase().startsWith('kt1')) {\n            throw new Error(\n              `KT1 addresses are not supported as source since ${Protocols.PsBabyM1}`\n            );\n          }\n          return cops;\n        case OpKind.DELEGATION:\n          return {\n            ...op,\n            ...this.getSource(op, publicKeyHash, source),\n            ...counterFunction(publicKeyHash, headCounter, counters),\n            ...this.getFee(op),\n          };\n        default:\n          throw new Error('Unsupported operation');\n      }\n    });\n  };\n\n  private getFee = (op: RPCOpWithFee) => {\n    return {\n      // tslint:disable-next-line: strict-type-predicates\n      fee: typeof op.fee === 'undefined' ? '0' : `${op.fee}`,\n      // tslint:disable-next-line: strict-type-predicates\n      gas_limit: typeof op.gas_limit === 'undefined' ? '0' : `${op.gas_limit}`,\n      // tslint:disable-next-line: strict-type-predicates\n      storage_limit: typeof op.storage_limit === 'undefined' ? '0' : `${op.storage_limit}`,\n    };\n  };\n\n  private getSource = (op: RPCOpWithSource, publicKeyHash: string, source?: string) => {\n    return {\n      source: typeof op.source === 'undefined' ? source || publicKeyHash : op.source,\n    };\n  };\n\n  protected async prepareOpAndSimulation({\n    operation,\n    source\n  }: PrepareOperationParams): Promise<PreparedOpAndSimulation> {\n    let ops: RPCOperation[] = [];\n\n    if (Array.isArray(operation)) {\n      ops = [...operation];\n    } else {\n      ops = [operation];\n    }\n\n    // Implicit account who emit the operation\n    const publicKeyHash = await this.signer.publicKeyHash();\n\n    const { counter, hash, protocol } = await this.getCounterHashAndProtocol(ops, publicKeyHash);\n\n    if (!this.context.counters[publicKeyHash] || this.context.counters[publicKeyHash] < counter) {\n      this.context.counters[publicKeyHash] = counter;\n    }\n\n    let preparedOpSimulation;\n    // This is a work around to the counter_in_the_future error returned by the RPC when calling the run_operation\n    // The preparedOpSimulation will be used to prevalidate the operation instead of the preparedOp\n    // The counter of an operation in preparedOpSimulation will be the head counter + 1\n    // The counter in preparedOp will be incremented accordingly if sending many operations in a row by keeping it on the context\n    if (counter !== this.context.counters[publicKeyHash]) {\n      preparedOpSimulation = {\n        opOb: {\n          branch: hash,\n          contents: this.constructOps(ops, publicKeyHash, counter, this.getScopeCounter, source),\n        },\n        counter,\n      };\n    }\n\n    const preparedOp = {\n      opOb: {\n        branch: hash,\n        contents: this.constructOps(ops, publicKeyHash, counter, this.getContextCounter, source),\n        protocol: protocol,\n      },\n      counter,\n    };\n\n    return {\n      preparedOp,\n      preparedOpSimulation,\n    };\n  }\n\n  private async getCounterHashAndProtocol(ops: RPCOperation[], publicKeyHash: string) {\n    const blockHeaderPromise = this.rpc.getBlockHeader();\n    const blockMetaPromise = this.rpc.getBlockMetadata();\n    let counterPromise: Promise<string | undefined> = Promise.resolve(undefined);\n\n    for (let i = 0; i < ops.length; i++) {\n      if (isOpRequireReveal(ops[i]) || ops[i].kind === 'reveal') {\n        const { counter } = await this.rpc.getContract(publicKeyHash);\n        counterPromise = Promise.resolve(counter);\n        break;\n      }\n    }\n\n    const [header, metadata, headCounter] = await Promise.all([\n      blockHeaderPromise,\n      blockMetaPromise,\n      counterPromise,\n    ]);\n\n    if (!header) {\n      throw new Error('Unable to fetch latest block header');\n    }\n\n    if (!metadata) {\n      throw new Error('Unable to fetch latest metadata');\n    }\n\n    const counter = parseInt(headCounter || '0', 10);\n    return {\n      counter,\n      hash: header.hash,\n      protocol: metadata.next_protocol,\n    };\n  }\n\n  private getContextCounter = (publicKeyHash: string, headCounter: number) => {\n    if (\n      !this.context.counters[publicKeyHash] ||\n      this.context.counters[publicKeyHash] < headCounter\n    ) {\n      this.context.counters[publicKeyHash] = headCounter;\n    }\n    const opCounter = ++this.context.counters[publicKeyHash];\n    return {\n      counter: `${opCounter}`,\n    };\n  };\n\n  private getScopeCounter = (\n    publicKeyHash: string,\n    headCounter: number,\n    countersScope: { [key: string]: number }\n  ) => {\n    if (!countersScope[publicKeyHash] || countersScope[publicKeyHash] < headCounter) {\n      countersScope[publicKeyHash] = headCounter;\n    }\n    return {\n      counter: `${++countersScope[publicKeyHash]}`,\n    };\n  };\n\n  protected async prepareOperationEstimation({\n    operation,\n    source\n  }: PrepareOperationParams): Promise<PreparedOperationSimulation> {\n    const countersScope: { [key: string]: number } = {};\n    let ops: RPCOperation[] = [];\n\n    if (Array.isArray(operation)) {\n      ops = [...operation];\n    } else {\n      ops = [operation];\n    }\n\n    const publicKeyHash = source? source: await this.signer.publicKeyHash();\n\n    const { counter, hash } = await this.getCounterHashAndProtocol(ops, publicKeyHash);\n\n    if (!countersScope[publicKeyHash] || countersScope[publicKeyHash] < counter) {\n      countersScope[publicKeyHash] = counter;\n    }\n\n    return {\n      opOb: {\n        branch: hash,\n        contents: this.constructOps(ops, publicKeyHash, counter, this.getScopeCounter, source),\n      },\n      counter,\n    };\n  }\n\n  protected async preValidate(prepared: PreparedOpAndSimulation, forgedOperation: ForgedBytes) {\n    return prepared.preparedOpSimulation\n      ? // If we want to inject many operations in a same block\n        // we call runOperation instead of preapply\n        // to avoid having to produce 2 signatures (op with incremented counter and op used for simulation)\n        this.runOperation({\n          operation: {\n            signature: SIGNATURE_STUB,\n            ...prepared.preparedOpSimulation.opOb,\n          },\n          chain_id: await this.rpc.getChainId(),\n        })\n      : this.preapplyOperation(forgedOperation.opOb);\n  }\n\n  protected async forgeOperation({\n    opOb: { branch, contents },\n  }: PreparedOperation | PreparedOperationSimulation) {\n    return this.context.forger.forge({ branch, contents });\n  }\n\n  protected async forge({\n    opOb: { branch, contents, protocol },\n    counter,\n  }: PreparedOperation): Promise<ForgedBytes> {\n    let forgedBytes = await this.context.forger.forge({ branch, contents });\n\n    return {\n      opbytes: forgedBytes,\n      opOb: {\n        branch,\n        contents,\n        protocol,\n      },\n      counter,\n    };\n  }\n\n  protected async simulate(op: RPCRunOperationParam) {\n    return {\n      opResponse: await this.rpc.runOperation(op),\n      op,\n      context: this.context.clone(),\n    };\n  }\n\n  protected async estimate<T extends { fee?: number; gasLimit?: number; storageLimit?: number }>(\n    { fee, gasLimit, storageLimit, ...rest }: T,\n    estimator: (param: T) => Promise<Estimate>\n  ) {\n    let calculatedFee = fee;\n    let calculatedGas = gasLimit;\n    let calculatedStorage = storageLimit;\n\n    if (fee === undefined || gasLimit === undefined || storageLimit === undefined) {\n      const estimation = await estimator({ fee, gasLimit, storageLimit, ...(rest as any) });\n\n      if (calculatedFee === undefined) {\n        calculatedFee = estimation.suggestedFeeMutez;\n      }\n\n      if (calculatedGas === undefined) {\n        calculatedGas = estimation.gasLimit;\n      }\n\n      if (calculatedStorage === undefined) {\n        calculatedStorage = estimation.storageLimit;\n      }\n    }\n\n    return {\n      fee: calculatedFee!,\n      gasLimit: calculatedGas!,\n      storageLimit: calculatedStorage!,\n    };\n  }\n\n  protected async signOperation(forgedBytes: ForgedBytes) {\n    const signed = await this.signer.sign(forgedBytes.opbytes, new Uint8Array([3]));\n    forgedBytes.opbytes = signed.sbytes;\n    forgedBytes.opOb.signature = signed.prefixSig;\n    return forgedBytes;\n  }\n\n  protected async runOperation(op: RPCRunOperationParam) {\n    const opResponse: OperationContentsAndResult[] = [];\n    const results = await this.rpc.runOperation(op);\n\n    for (let j = 0; j < results.contents.length; j++) {\n      opResponse.push(results.contents[j]);\n    }\n    const errors = flattenErrors(results);\n\n    if (errors.length) {\n      // @ts-ignore\n      throw new TezosOperationError(errors);\n    }\n\n    return opResponse;\n  }\n\n  protected async preapplyOperation(opOb: OperationObject) {\n    const opResponse: OperationContentsAndResult[] = [];\n    const results = await this.rpc.preapplyOperations([opOb]);\n\n    if (!Array.isArray(results)) {\n      throw new TezosPreapplyFailureError(results);\n    }\n\n    for (let i = 0; i < results.length; i++) {\n      for (let j = 0; j < results[i].contents.length; j++) {\n        opResponse.push(results[i].contents[j]);\n      }\n    }\n\n    const errors = flattenErrors(results);\n\n    if (errors.length) {\n      // @ts-ignore\n      throw new TezosOperationError(errors);\n    }\n    return opResponse;\n  }\n\n  protected async injectOperation(signedOperationBytes: string) {\n    return this.context.injector.inject(signedOperationBytes);\n  }\n}\n","import {\n  BlockResponse,\n  OperationContentsAndResult,\n  OperationContentsAndResultReveal,\n} from '@taquito/rpc';\nimport { defer, from, ReplaySubject, timer } from 'rxjs';\nimport {\n  filter,\n  first,\n  map,\n  mapTo,\n  shareReplay,\n  switchMap,\n  switchMapTo,\n  tap,\n} from 'rxjs/operators';\nimport { Context } from '../context';\nimport { ForgedBytes, hasMetadataWithResult } from './types';\n\ninterface PollingConfig {\n  timeout: number;\n  interval: number;\n}\n\n/**\n * @description Utility class to interact with Tezos operations\n */\nexport class Operation {\n  private _pollingConfig$ = new ReplaySubject<PollingConfig>(1);\n\n  private _currentHeadPromise: Promise<BlockResponse> | undefined = undefined;\n\n  // Caching the current head for one second\n  private currentHead$ = defer(() => {\n    if (!this._currentHeadPromise) {\n      this._currentHeadPromise = this.context.rpc.getBlock();\n      timer(1000)\n        .pipe(first())\n        .subscribe(() => {\n          this._currentHeadPromise = undefined;\n        });\n    }\n    return from(this._currentHeadPromise);\n  });\n\n  // Polling observable that emit until timeout is reached\n  private polling$ = defer(() =>\n    this._pollingConfig$.pipe(\n      tap(({ timeout, interval }) => {\n        if (timeout <= 0) {\n          throw new Error('Timeout must be more than 0');\n        }\n\n        if (interval <= 0) {\n          throw new Error('Interval must be more than 0');\n        }\n      }),\n      map((config) => ({\n        ...config,\n        timeoutAt: Math.ceil(config.timeout / config.interval) + 1,\n        count: 0,\n      })),\n      switchMap((config) => timer(0, config.interval * 1000).pipe(mapTo(config))),\n      tap((config) => {\n        config.count++;\n        if (config.count > config.timeoutAt) {\n          throw new Error(`Confirmation polling timed out`);\n        }\n      })\n    )\n  );\n\n  // Observable that emit once operation is seen in a block\n  private confirmed$ = this.polling$.pipe(\n    switchMapTo(this.currentHead$),\n    map((head) => {\n      for (let i = 3; i >= 0; i--) {\n        head.operations[i].forEach((op) => {\n          if (op.hash === this.hash) {\n            this._foundAt = head.header.level;\n          }\n        });\n      }\n\n      if (head.header.level - this._foundAt >= 0) {\n        return this._foundAt;\n      }\n    }),\n    filter((x) => x !== undefined),\n    first(),\n    shareReplay()\n  );\n\n  protected _foundAt = Number.POSITIVE_INFINITY;\n  get includedInBlock() {\n    return this._foundAt;\n  }\n  /**\n   *\n   * @param hash Operation hash\n   * @param raw Raw operation that was injected\n   * @param context Taquito context allowing access to rpc and signer\n   */\n  constructor(\n    public readonly hash: string,\n    public readonly raw: ForgedBytes,\n    public readonly results: OperationContentsAndResult[],\n    protected readonly context: Context\n  ) {\n    this.confirmed$.pipe(first()).subscribe();\n  }\n\n  get revealOperation() {\n    return (\n      Array.isArray(this.results) &&\n      (this.results.find((op) => op.kind === 'reveal') as\n        | OperationContentsAndResultReveal\n        | undefined)\n    );\n  }\n\n  public get revealStatus() {\n    if (this.revealOperation) {\n      return this.revealOperation.metadata.operation_result.status;\n    } else {\n      return 'unknown';\n    }\n  }\n\n  public get status() {\n    return (\n      this.results.map((result) => {\n        if (hasMetadataWithResult(result)) {\n          return result.metadata.operation_result.status;\n        } else {\n          return 'unknown';\n        }\n      })[0] || 'unknown'\n    );\n  }\n\n  /**\n   *\n   * @param confirmations [0] Number of confirmation to wait for\n   * @param interval [10] Polling interval\n   * @param timeout [180] Timeout\n   */\n  async confirmation(confirmations?: number, interval?: number, timeout?: number) {\n    if (typeof confirmations !== 'undefined' && confirmations < 1) {\n      throw new Error('Confirmation count must be at least 1');\n    }\n\n    const confirmationPollingIntervalSecond =\n      this.context.config.confirmationPollingIntervalSecond !== undefined\n        ? this.context.config.confirmationPollingIntervalSecond\n        : await this.context.getConfirmationPollingInterval();\n\n    const { defaultConfirmationCount, confirmationPollingTimeoutSecond } = this.context.config;\n    this._pollingConfig$.next({\n      interval: interval || confirmationPollingIntervalSecond,\n      timeout: timeout || confirmationPollingTimeoutSecond,\n    } as Required<PollingConfig>);\n\n    const conf = confirmations !== undefined ? confirmations : defaultConfirmationCount;\n\n    if (conf === undefined) {\n      throw new Error('Default confirmation count can not be undefined!');\n    }\n\n    return new Promise<number>((resolve, reject) => {\n      this.confirmed$\n        .pipe(\n          switchMap(() => this.polling$),\n          switchMap(() => this.currentHead$),\n          filter((head) => head.header.level - this._foundAt >= conf - 1),\n          first()\n        )\n        .subscribe((_) => {\n          resolve(this._foundAt + (conf - 1));\n        }, reject);\n    });\n  }\n}\n","import BigNumber from 'bignumber.js';\nimport { Context } from '../context';\nimport { OperationEmitter } from '../operations/operation-emitter';\nimport { Operation } from '../operations/operations';\nimport { RPCActivateOperation } from '../operations/types';\nimport { TzProvider } from './interface';\nimport { OpKind } from '@taquito/rpc';\n\nexport class RpcTzProvider extends OperationEmitter implements TzProvider {\n  constructor(context: Context) {\n    super(context);\n  }\n\n  async getBalance(address: string): Promise<BigNumber> {\n    return this.rpc.getBalance(address);\n  }\n\n  async getDelegate(address: string): Promise<string | null> {\n    return this.rpc.getDelegate(address);\n  }\n\n  async activate(pkh: string, secret: string) {\n    const operation: RPCActivateOperation = {\n      kind: OpKind.ACTIVATION,\n      pkh,\n      secret,\n    };\n\n    const prepared = await this.prepareOpAndSimulation({\n      operation: [operation],\n      source: pkh\n    });\n    const forgedBytes = await this.forge(prepared.preparedOp);\n    const bytes = `${forgedBytes.opbytes}00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`;\n    return new Operation(\n      await this.rpc.injectOperation(bytes),\n      { ...forgedBytes, opbytes: bytes },\n      [],\n      this.context.clone()\n    );\n  }\n}\n","const MINIMAL_FEE_MUTEZ = 100;\nconst MINIMAL_FEE_PER_BYTE_MUTEZ = 1;\nconst MINIMAL_FEE_PER_GAS_MUTEZ = 0.1;\n\nconst GAS_BUFFER = 100;\n\nexport interface EstimateProperties {\n  milligasLimit: number,\n  storageLimit: number,\n  opSize: number,\n  minimalFeePerStorageByteMutez: number,\n  baseFeeMutez?: number\n}\n\n/**\n * Examples of use :\n *\n *  Estimate a transfer operation :\n * ```\n * // Assuming that provider and signer are already configured...\n *\n * const amount = 2;\n * const address = 'tz1h3rQ8wBxFd8L9B3d7Jhaawu6Z568XU3xY';\n *\n * // Estimate gasLimit, storageLimit and fees for a transfer operation\n * const est = await Tezos.estimate.transfer({ to: address, amount: amount })\n * console.log(est.burnFeeMutez, est.gasLimit, est.minimalFeeMutez, est.storageLimit,\n *  est.suggestedFeeMutez, est.totalCost, est.usingBaseFeeMutez)\n *\n * ```\n *\n * Estimate a contract origination :\n * ```\n * // generic.json is referring to a Michelson Smart Contract\n *\n * const genericMultisigJSON = require('./generic.json')\n * const est = await Tezos.estimate.originate({\n *   code: genericMultisigJSON,\n *   storage: {\n *     stored_counter: 0,\n *     threshold: 1,\n *     keys: ['edpkuLxx9PQD8fZ45eUzrK3BhfDZJHhBuK4Zi49DcEGANwd2rpX82t']\n *   }\n * })\n * console.log(est.burnFeeMutez, est.gasLimit, est.minimalFeeMutez, est.storageLimit,\n *   est.suggestedFeeMutez, est.totalCost, est.usingBaseFeeMutez)\n *\n * ```\n */\n\nexport class Estimate {\n  constructor(\n    private readonly _milligasLimit: number | string,\n    private readonly _storageLimit: number | string,\n    private readonly opSize: number | string,\n    private readonly minimalFeePerStorageByteMutez: number | string,\n    /**\n     * @description Base fee in mutez (1 mutez = 1e10−6 tez)\n     */\n    private readonly baseFeeMutez: number | string = MINIMAL_FEE_MUTEZ\n  ) {}\n\n  /**\n   * @description The number of Mutez that will be burned for the storage of the [operation](https://tezos.gitlab.io/user/glossary.html#operations). (Storage + Allocation fees)\n   */\n  get burnFeeMutez() {\n    return this.roundUp(Number(this.storageLimit) * Number(this.minimalFeePerStorageByteMutez));\n  }\n\n  /**\n   * @description  The limit on the amount of storage an [operation](https://tezos.gitlab.io/user/glossary.html#operations) can use.\n   */\n  get storageLimit() {\n    const limit = Math.max(Number(this._storageLimit), 0);\n    return limit > 0 ? limit : 0;\n  }\n\n  /**\n   * @description The limit on the amount of [gas](https://tezos.gitlab.io/user/glossary.html#gas) a given operation can consume.\n   */\n  get gasLimit() {\n    return this.roundUp(Number(this._milligasLimit)/1000 + GAS_BUFFER);\n  }\n\n  private get operationFeeMutez() {\n    return (\n      (Number(this._milligasLimit)/1000 + GAS_BUFFER) * MINIMAL_FEE_PER_GAS_MUTEZ + Number(this.opSize) * MINIMAL_FEE_PER_BYTE_MUTEZ\n      );\n  }\n\n  private roundUp(nanotez: number) {\n    return Math.ceil(Number(nanotez));\n  }\n\n  /**\n   * @description Minimum fees for the [operation](https://tezos.gitlab.io/user/glossary.html#operations) according to [baker](https://tezos.gitlab.io/user/glossary.html#baker) defaults.\n   */\n  get minimalFeeMutez() {\n    return this.roundUp(MINIMAL_FEE_MUTEZ + this.operationFeeMutez);\n  }\n\n  /**\n   * @description The suggested fee for the operation which includes minimal fees and a small buffer.\n   */\n  get suggestedFeeMutez() {\n    return this.roundUp(this.operationFeeMutez + MINIMAL_FEE_MUTEZ * 2);\n  }\n\n  /**\n   * @description Fees according to your specified base fee will ensure that at least minimum fees are used.\n   */\n  get usingBaseFeeMutez() {\n    return (\n      Math.max(Number(this.baseFeeMutez), MINIMAL_FEE_MUTEZ) + this.roundUp(this.operationFeeMutez)\n    );\n  }\n\n  /**\n   * @description The sum of `minimalFeeMutez` + `burnFeeMutez`.\n   */\n  get totalCost() {\n    return this.minimalFeeMutez + this.burnFeeMutez;\n  }\n\n  /**\n   * @description Since Delphinet, consumed gas is provided in milligas for more precision. \n   * This function returns an estimation of the gas that operation will consume in milligas. \n   */\n  get consumedMilligas() {\n    return Number(this._milligasLimit);\n  }\n\n  static createEstimateInstanceFromProperties(estimateProperties: EstimateProperties[]) {\n    let milligasLimit = 0;\n    let storageLimit = 0;\n    let opSize = 0;\n    let minimalFeePerStorageByteMutez = 0;\n    let baseFeeMutez: number | undefined;\n\n    estimateProperties.forEach(estimate => {\n      milligasLimit += estimate.milligasLimit;\n      storageLimit += estimate.storageLimit;\n      opSize += estimate.opSize;\n      minimalFeePerStorageByteMutez = Math.max(estimate.minimalFeePerStorageByteMutez, minimalFeePerStorageByteMutez);\n      if (estimate.baseFeeMutez) {\n        baseFeeMutez = baseFeeMutez ? baseFeeMutez + estimate.baseFeeMutez : estimate.baseFeeMutez;\n      }\n    })\n    return new Estimate(milligasLimit, storageLimit, opSize, minimalFeePerStorageByteMutez, baseFeeMutez);\n  }\n\n  static createArrayEstimateInstancesFromProperties(estimateProperties: EstimateProperties[]) {\n    return estimateProperties.map(x => new Estimate(x.milligasLimit, x.storageLimit, x.opSize, x.minimalFeePerStorageByteMutez, x.baseFeeMutez))\n  }\n}\n","import BigNumber from 'bignumber.js';\n\nconst TZ_DECIMALS = 6;\nconst MTZ_DECIMALS = 3;\n\ntype Format = 'tz' | 'mtz' | 'mutez';\n\nfunction getDecimal(format: Format) {\n  switch (format) {\n    case 'tz':\n      return TZ_DECIMALS;\n    case 'mtz':\n      return MTZ_DECIMALS;\n    case 'mutez':\n    default:\n      return 0;\n  }\n}\n\nexport function format(\n  from: Format = 'mutez',\n  to: Format = 'mutez',\n  amount: number | string | BigNumber\n) {\n  const bigNum = new BigNumber(amount);\n  if (bigNum.isNaN()) {\n    return amount;\n  }\n\n  return bigNum\n    .multipliedBy(Math.pow(10, getDecimal(from)))\n    .dividedBy(Math.pow(10, getDecimal(to)));\n}\n","export class InvalidParameterError implements Error {\n  name: string = 'Invalid parameters error';\n  message: string;\n  constructor(public smartContractMethodName: string, public sigs: any[], public args: any[]) {\n    this.message = `${smartContractMethodName} Received ${\n      args.length\n    } arguments while expecting one of the following signatures (${JSON.stringify(sigs)})`;\n  }\n}\n\nexport class UndefinedLambdaContractError implements Error {\n  name: string = 'Undefined LambdaContract error';\n  message: string;\n  constructor() {\n    this.message = \"This might happen if you are using a sandbox. Please provide the address of a lambda contract as a parameter of the read method.\";\n  }\n}\nexport class InvalidDelegationSource implements Error {\n  name: string = 'Invalid delegation source error';\n  message: string;\n\n  constructor(public source: string) {\n    this.message = `Since Babylon delegation source can no longer be a contract address ${source}. Please use the smart contract abstraction to set your delegate.`;\n  }\n}\n\nexport class InvalidCodeParameter implements Error {\n  public name: string = 'InvalidCodeParameter';\n  constructor(public message: string, public readonly data: any) { }\n}\n\nexport class InvalidInitParameter implements Error {\n  public name: string = 'InvalidInitParameter';\n  constructor(public message: string, public readonly data: any) { }\n}\n","import { Schema } from '@taquito/michelson-encoder';\nimport { OpKind, MichelsonV1Expression } from '@taquito/rpc';\nimport { Prim, Expr } from '@taquito/michel-codec';\nimport {\n  OriginateParams,\n  RPCOriginationOperation,\n  TransferParams,\n  RPCTransferOperation,\n  DelegateParams,\n  RPCDelegateOperation,\n  RegisterDelegateParams,\n  RPCRevealOperation,\n  RevealParams\n} from '../operations/types';\nimport { DEFAULT_FEE, DEFAULT_GAS_LIMIT, DEFAULT_STORAGE_LIMIT } from '../constants';\nimport { format } from '../format';\nimport { InvalidCodeParameter, InvalidInitParameter } from './errors';\n\nexport const createOriginationOperation = async ({\n  code,\n  init,\n  balance = \"0\",\n  delegate,\n  storage,\n  fee = DEFAULT_FEE.ORIGINATION,\n  gasLimit = DEFAULT_GAS_LIMIT.ORIGINATION,\n  storageLimit = DEFAULT_STORAGE_LIMIT.ORIGINATION,\n  mutez = false\n}: OriginateParams) => {\n  // tslint:disable-next-line: strict-type-predicates\n  if (storage !== undefined && init !== undefined) {\n    throw new Error(\n      \"Storage and Init cannot be set a the same time. Please either use storage or init but not both.\",\n    );\n  }\n\n  if(!Array.isArray(code)){\n    throw new InvalidCodeParameter('Wrong code parameter type, expected an array', code);\n  }\n\n  let contractStorage: Expr | undefined;\n  if (storage !== undefined) {\n    const storageType = (code as Expr[]).find((p): p is Prim => ('prim' in p) && p.prim === 'storage');\n    if (storageType?.args === undefined) {\n      throw new InvalidCodeParameter('The storage section is missing from the script', code);\n    }\n    const schema = new Schema(storageType.args[0] as MichelsonV1Expression); // TODO\n    contractStorage = schema.Encode(storage);\n  } else if (init !== undefined && typeof init === 'object') {\n    contractStorage = init as Expr;\n  } else {\n    throw new InvalidInitParameter('Wrong init parameter type, expected JSON Michelson', init);\n  }\n\n  const script = {\n    code,\n    storage: contractStorage,\n  };\n\n  const operation: RPCOriginationOperation = {\n    kind: OpKind.ORIGINATION,\n    fee,\n    gas_limit: gasLimit,\n    storage_limit: storageLimit,\n    balance: mutez\n      ? balance.toString()\n      : format('tz', 'mutez', balance).toString(),\n    script,\n  };\n\n  if (delegate) {\n    operation.delegate = delegate;\n  }\n  return operation;\n};\n\nexport const createTransferOperation = async ({\n  to,\n  amount,\n  parameter,\n  fee = DEFAULT_FEE.TRANSFER,\n  gasLimit = DEFAULT_GAS_LIMIT.TRANSFER,\n  storageLimit = DEFAULT_STORAGE_LIMIT.TRANSFER,\n  mutez = false,\n}: TransferParams) => {\n  const operation: RPCTransferOperation = {\n    kind: OpKind.TRANSACTION,\n    fee,\n    gas_limit: gasLimit,\n    storage_limit: storageLimit,\n    amount: mutez\n      ? amount.toString()\n      : format(\"tz\", \"mutez\", amount).toString(),\n    destination: to,\n    parameters: parameter,\n  };\n  return operation;\n};\n\nexport const createSetDelegateOperation = async ({\n  delegate,\n  source,\n  fee = DEFAULT_FEE.DELEGATION,\n  gasLimit = DEFAULT_GAS_LIMIT.DELEGATION,\n  storageLimit = DEFAULT_STORAGE_LIMIT.DELEGATION,\n}: DelegateParams) => {\n  const operation: RPCDelegateOperation = {\n    kind: OpKind.DELEGATION,\n    source,\n    fee,\n    gas_limit: gasLimit,\n    storage_limit: storageLimit,\n    delegate,\n  };\n  return operation;\n};\n\nexport const createRegisterDelegateOperation = async (\n  {\n    fee = DEFAULT_FEE.DELEGATION,\n    gasLimit = DEFAULT_GAS_LIMIT.DELEGATION,\n    storageLimit = DEFAULT_STORAGE_LIMIT.DELEGATION,\n  }: RegisterDelegateParams,\n  source: string,\n) => {\n  return {\n    kind: OpKind.DELEGATION,\n    fee,\n    gas_limit: gasLimit,\n    storage_limit: storageLimit,\n    delegate: source,\n  } as RPCDelegateOperation;\n};\n\nexport const createRevealOperation = async (\n  {\n    fee = DEFAULT_FEE.REVEAL,\n    gasLimit = DEFAULT_GAS_LIMIT.REVEAL,\n    storageLimit = DEFAULT_STORAGE_LIMIT.REVEAL,\n  }: RevealParams,\n  source: string,\n  publicKey: string,\n) => {\n  return {\n    kind: OpKind.REVEAL,\n    fee,\n    public_key: publicKey,\n    source,\n    gas_limit: gasLimit,\n    storage_limit: storageLimit\n  } as RPCRevealOperation;\n};","import { PreapplyResponse, RPCRunOperationParam, OpKind } from '@taquito/rpc';\nimport BigNumber from 'bignumber.js';\nimport { DEFAULT_FEE, DEFAULT_GAS_LIMIT, DEFAULT_STORAGE_LIMIT } from '../constants';\nimport { OperationEmitter, SIGNATURE_STUB } from '../operations/operation-emitter';\nimport {\n  flattenErrors,\n  flattenOperationResult,\n  TezosOperationError,\n} from '../operations/operation-errors';\nimport {\n  DelegateParams,\n  isOpWithFee,\n  OriginateParams,\n  ParamsWithKind,\n  PrepareOperationParams,\n  RegisterDelegateParams,\n  RPCOperation,\n  TransferParams,\n  RevealParams,\n} from '../operations/types';\nimport { Estimate, EstimateProperties } from './estimate';\nimport { EstimationProvider } from './interface';\nimport {\n  createOriginationOperation,\n  createRegisterDelegateOperation,\n  createRevealOperation,\n  createSetDelegateOperation,\n  createTransferOperation,\n} from './prepare';\n\ninterface Limits {\n  fee?: number;\n  storageLimit?: number;\n  gasLimit?: number;\n}\n\nconst mergeLimits = (\n  userDefinedLimit: Limits,\n  defaultLimits: Required<Limits>\n): Required<Limits> => {\n  return {\n    fee: typeof userDefinedLimit.fee === 'undefined' ? defaultLimits.fee : userDefinedLimit.fee,\n    gasLimit:\n      typeof userDefinedLimit.gasLimit === 'undefined'\n        ? defaultLimits.gasLimit\n        : userDefinedLimit.gasLimit,\n    storageLimit:\n      typeof userDefinedLimit.storageLimit === 'undefined'\n        ? defaultLimits.storageLimit\n        : userDefinedLimit.storageLimit,\n  };\n};\n\nexport class RPCEstimateProvider extends OperationEmitter implements EstimationProvider {\n  private readonly ALLOCATION_STORAGE = 257;\n  private readonly ORIGINATION_STORAGE = 257;\n  private readonly OP_SIZE_REVEAL = 128;\n\n  // Maximum values defined by the protocol\n  private async getAccountLimits(pkh: string, numberOfOps?: number) {\n    const balance = await this.rpc.getBalance(pkh);\n    const {\n      hard_gas_limit_per_operation,\n      hard_gas_limit_per_block,\n      hard_storage_limit_per_operation,\n      cost_per_byte,\n    } = await this.rpc.getConstants();\n    return {\n      fee: 0,\n      gasLimit: numberOfOps\n        ? Math.floor(\n            this.ajustGasForBatchOperation(\n              hard_gas_limit_per_block,\n              hard_gas_limit_per_operation,\n              numberOfOps\n            ).toNumber()\n          )\n        : hard_gas_limit_per_operation.toNumber(),\n      storageLimit: Math.floor(\n        BigNumber.min(balance.dividedBy(cost_per_byte), hard_storage_limit_per_operation).toNumber()\n      ),\n    };\n  }\n\n  // Fix for Granada where the total gasLimit of a batch can not exceed the hard_gas_limit_per_block.\n  // If the total gasLimit of the batch is higher than the hard_gas_limit_per_block,\n  // the gasLimit is calculated by dividing the hard_gas_limit_per_block by the number of operation in the batch (numberOfOps).\n  // numberOfOps is incremented by 1 for safety in case a reveal operation is needed\n  private ajustGasForBatchOperation(\n    gasLimitBlock: BigNumber,\n    gaslimitOp: BigNumber,\n    numberOfOps: number\n  ) {\n    return BigNumber.min(gaslimitOp, gasLimitBlock.div(numberOfOps + 1));\n  }\n\n  private getEstimationPropertiesFromOperationContent(\n    content: PreapplyResponse['contents'][0],\n    size: number,\n    costPerByte: BigNumber\n  ): EstimateProperties {\n    const operationResults = flattenOperationResult({ contents: [content] });\n    let totalGas = 0;\n    let totalMilligas = 0;\n    let totalStorage = 0;\n    operationResults.forEach((result) => {\n      totalStorage +=\n        'originated_contracts' in result && typeof result.originated_contracts !== 'undefined'\n          ? result.originated_contracts.length * this.ORIGINATION_STORAGE\n          : 0;\n      totalStorage += 'allocated_destination_contract' in result ? this.ALLOCATION_STORAGE : 0;\n      totalGas += Number(result.consumed_gas) || 0;\n      totalMilligas += Number(result.consumed_milligas) || 0;\n      totalStorage +=\n        'paid_storage_size_diff' in result ? Number(result.paid_storage_size_diff) || 0 : 0;\n    });\n\n    if (totalGas !== 0 && totalMilligas === 0) {\n      // This will convert gas to milligas for Carthagenet where result does not contain consumed gas in milligas.\n      totalMilligas = totalGas * 1000;\n    }\n\n    if (isOpWithFee(content)) {\n      return {\n        milligasLimit: totalMilligas || 0,\n        storageLimit: Number(totalStorage || 0),\n        opSize: size,\n        minimalFeePerStorageByteMutez: costPerByte.toNumber(),\n      };\n    } else {\n      return {\n        milligasLimit: 0,\n        storageLimit: 0,\n        opSize: size,\n        minimalFeePerStorageByteMutez: costPerByte.toNumber(),\n        baseFeeMutez: 0,\n      };\n    }\n  }\n\n  private async prepareEstimate(params: PrepareOperationParams) {\n    const preparedSimulation = await this.prepareOperationEstimation(params);\n    const opbytes = await this.forgeOperation(preparedSimulation);\n    let operation: RPCRunOperationParam = {\n      operation: {\n        branch: preparedSimulation.opOb.branch,\n        contents: preparedSimulation.opOb.contents,\n        signature: SIGNATURE_STUB,\n      },\n      chain_id: await this.rpc.getChainId(),\n    };\n\n    const { opResponse } = await this.simulate(operation);\n    const { cost_per_byte } = await this.rpc.getConstants();\n    const errors = [...flattenErrors(opResponse, 'backtracked'), ...flattenErrors(opResponse)];\n\n    // Fail early in case of errors\n    if (errors.length) {\n      throw new TezosOperationError(errors);\n    }\n\n    let numberOfOps = 1;\n    if (Array.isArray(params.operation) && params.operation.length > 1) {\n      numberOfOps =\n        opResponse.contents[0].kind === 'reveal'\n          ? params.operation.length - 1\n          : params.operation.length;\n    }\n\n    return opResponse.contents.map((x) => {\n      return this.getEstimationPropertiesFromOperationContent(\n        x,\n        // TODO: Calculate a specific opSize for each operation.\n        x.kind === 'reveal' ? this.OP_SIZE_REVEAL / 2 : opbytes.length / 2 / numberOfOps,\n        cost_per_byte\n      );\n    });\n  }\n\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees for an origination operation\n   *\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\n   *\n   * @param OriginationOperation Originate operation parameter\n   */\n  async originate({ fee, storageLimit, gasLimit, ...rest }: OriginateParams) {\n    const pkh = await this.signer.publicKeyHash();\n    const DEFAULT_PARAMS = await this.getAccountLimits(pkh);\n    const op = await createOriginationOperation(\n      await this.context.parser.prepareCodeOrigination({\n        ...rest,\n        ...mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS),\n      })\n    );\n    const isRevealNeeded = await this.isRevealOpNeeded([op], pkh);\n    const ops = isRevealNeeded ? await this.addRevealOp([op], pkh) : op;\n    const estimateProperties = await this.prepareEstimate({\n      operation: ops,\n      source: pkh,\n    });\n    if (isRevealNeeded) {\n      estimateProperties.shift();\n    }\n    return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n  }\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees for an transfer operation\n   *\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\n   *\n   * @param TransferOperation Originate operation parameter\n   */\n  async transfer({ fee, storageLimit, gasLimit, ...rest }: TransferParams) {\n    const pkh = await this.signer.publicKeyHash();\n    const DEFAULT_PARAMS = await this.getAccountLimits(pkh);\n    const op = await createTransferOperation({\n      ...rest,\n      ...mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS),\n    });\n    const isRevealNeeded = await this.isRevealOpNeeded([op], pkh);\n    const ops = isRevealNeeded ? await this.addRevealOp([op], pkh) : op;\n    const estimateProperties = await this.prepareEstimate({\n      operation: ops,\n      source: pkh\n    });\n    if (isRevealNeeded) {\n      estimateProperties.shift();\n    }\n    return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n  }\n\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees for a delegate operation\n   *\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\n   *\n   * @param Estimate\n   */\n  async setDelegate({ fee, gasLimit, storageLimit, ...rest }: DelegateParams) {\n    const pkh = await this.signer.publicKeyHash();\n    const sourceOrDefault = rest.source || pkh;\n    const DEFAULT_PARAMS = await this.getAccountLimits(sourceOrDefault);\n    const op = await createSetDelegateOperation({\n      ...rest,\n      ...mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS),\n    });\n    const isRevealNeeded = await this.isRevealOpNeeded([op], pkh);\n    const ops = isRevealNeeded ? await this.addRevealOp([op], pkh) : op;\n    const estimateProperties = await this.prepareEstimate({\n      operation: ops,\n      source: pkh\n    });\n    if (isRevealNeeded) {\n      estimateProperties.shift();\n    }\n    return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n  }\n\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees for a each operation in the batch\n   *\n   * @returns An array of Estimate objects. If a reveal operation is needed, the first element of the array is the Estimate for the reveal operation.\n   */\n  async batch(params: ParamsWithKind[]) {\n    const pkh = await this.signer.publicKeyHash();\n    let operations: RPCOperation[] = [];\n    const DEFAULT_PARAMS = await this.getAccountLimits(pkh, params.length);\n    for (const param of params) {\n      switch (param.kind) {\n        case OpKind.TRANSACTION:\n          operations.push(\n            await createTransferOperation({\n              ...param,\n              ...mergeLimits(param, DEFAULT_PARAMS),\n            })\n          );\n          break;\n        case OpKind.ORIGINATION:\n          operations.push(\n            await createOriginationOperation(\n              await this.context.parser.prepareCodeOrigination({\n                ...param,\n                ...mergeLimits(param, DEFAULT_PARAMS),\n              })\n            )\n          );\n          break;\n        case OpKind.DELEGATION:\n          operations.push(\n            await createSetDelegateOperation({\n              ...param,\n              ...mergeLimits(param, DEFAULT_PARAMS),\n            })\n          );\n          break;\n        case OpKind.ACTIVATION:\n          operations.push({\n            ...param,\n            ...DEFAULT_PARAMS,\n          });\n          break;\n        default:\n          throw new Error(`Unsupported operation kind: ${(param as any).kind}`);\n      }\n    }\n    const isRevealNeeded = await this.isRevealOpNeeded(operations, pkh);\n    operations = isRevealNeeded ? await this.addRevealOp(operations, pkh) : operations;\n    const estimateProperties = await this.prepareEstimate({\n      operation: operations,\n      source: pkh\n    });\n\n    return Estimate.createArrayEstimateInstancesFromProperties(estimateProperties);\n  }\n\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees for a delegate operation\n   *\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\n   *\n   * @param Estimate\n   */\n  async registerDelegate(params: RegisterDelegateParams) {\n    const pkh = await this.signer.publicKeyHash();\n    const DEFAULT_PARAMS = await this.getAccountLimits(pkh);\n    const op = await createRegisterDelegateOperation({ ...params, ...DEFAULT_PARAMS }, pkh);\n    const isRevealNeeded = await this.isRevealOpNeeded([op], pkh);\n    const ops = isRevealNeeded ? await this.addRevealOp([op], pkh) : op;\n    const estimateProperties = await this.prepareEstimate({\n      operation: ops,\n      source: pkh\n    });\n    if (isRevealNeeded) {\n      estimateProperties.shift();\n    }\n    return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n  }\n\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees to reveal the current account\n   *\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation or undefined if the account is already revealed\n   *\n   * @param Estimate\n   */\n  async reveal(params?: RevealParams) {\n    const pkh = await this.signer.publicKeyHash();\n    if (await this.isAccountRevealRequired(pkh)) {\n      const DEFAULT_PARAMS = await this.getAccountLimits(pkh);\n      const op = await createRevealOperation(\n        {\n          ...params,\n          ...DEFAULT_PARAMS,\n        },\n        pkh,\n        await this.signer.publicKey()\n      );\n      const estimateProperties = await this.prepareEstimate({ operation: op, source: pkh });\n      return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n    }\n  }\n\n  private async addRevealOp(op: RPCOperation[], pkh: string) {\n    op.unshift(\n      await createRevealOperation(\n        {\n          ...{\n            fee: DEFAULT_FEE.REVEAL,\n            gasLimit: DEFAULT_GAS_LIMIT.REVEAL,\n            storageLimit: DEFAULT_STORAGE_LIMIT.REVEAL,\n          },\n        },\n        pkh,\n        await this.signer.publicKey()\n      )\n    );\n    return op;\n  }\n}\n","import { OperationContentsAndResult, OperationResultStatusEnum } from '@taquito/rpc';\nimport { BATCH_KINDS } from '../batch/rpc-batch-provider';\nimport { Context } from '../context';\nimport { flattenErrors, flattenOperationResult } from './operation-errors';\nimport { Operation } from './operations';\nimport {\n  FeeConsumingOperation,\n  ForgedBytes,\n  GasConsumingOperation,\n  RPCOperation,\n  StorageConsumingOperation,\n  hasMetadataWithResult,\n} from './types';\n\nexport class BatchOperation\n  extends Operation\n  implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n  constructor(\n    hash: string,\n    private readonly params: RPCOperation[],\n    public readonly source: string,\n    raw: ForgedBytes,\n    results: OperationContentsAndResult[],\n    context: Context\n  ) {\n    super(hash, raw, results, context);\n  }\n\n  private sumProp(arr: any[], prop: string) {\n    return arr.reduce((prev, current) => {\n      return prop in current ? Number(current[prop]) + prev : prev;\n    }, 0);\n  }\n\n  public get status() {\n    return (\n      this.results\n        .filter((result) => BATCH_KINDS.indexOf(result.kind) !== -1)\n        .map((result) => {\n          if (hasMetadataWithResult(result)) {\n            return result.metadata.operation_result.status;\n          } else {\n            return 'unknown';\n          }\n        })[0] || 'unknown'\n    );\n  }\n\n  get fee() {\n    return this.sumProp(this.params, 'fee');\n  }\n\n  get gasLimit() {\n    return this.sumProp(this.params, 'gas_limit');\n  }\n\n  get storageLimit() {\n    return this.sumProp(this.params, 'storage_limit');\n  }\n\n  get consumedGas() {\n    return String(this.sumProp(flattenOperationResult({ contents: this.results }), 'consumed_gas'));\n  }\n\n  get storageDiff() {\n    return String(\n      this.sumProp(flattenOperationResult({ contents: this.results }), 'paid_storage_size_diff')\n    );\n  }\n\n  get errors() {\n    return flattenErrors({ contents: this.results });\n  }\n}\n","import { Context } from '../context';\nimport { ContractMethod } from '../contract/contract';\nimport { EstimationProvider, ContractProvider } from '../contract/interface';\nimport {\n  createOriginationOperation,\n  createRevealOperation,\n  createSetDelegateOperation,\n  createTransferOperation,\n} from '../contract/prepare';\nimport { BatchOperation } from '../operations/batch-operation';\nimport { OperationEmitter } from '../operations/operation-emitter';\nimport {\n  ActivationParams,\n  DelegateParams,\n  OriginateParams,\n  RPCOperation,\n  TransferParams,\n  ParamsWithKind,\n  isOpWithFee,\n  withKind,\n  RevealParams,\n  isOpRequireReveal,\n} from '../operations/types';\nimport { OpKind } from '@taquito/rpc';\n\nexport const BATCH_KINDS = [\n  OpKind.ACTIVATION,\n  OpKind.ORIGINATION,\n  OpKind.TRANSACTION,\n  OpKind.DELEGATION,\n];\nexport type BatchKinds =\n  | OpKind.ACTIVATION\n  | OpKind.ORIGINATION\n  | OpKind.TRANSACTION\n  | OpKind.DELEGATION;\n\nexport class OperationBatch extends OperationEmitter {\n  private operations: ParamsWithKind[] = [];\n\n  constructor(context: Context, private estimator: EstimationProvider) {\n    super(context);\n  }\n\n  /**\n   *\n   * @description Add a transaction operation to the batch\n   *\n   * @param params Transfer operation parameter\n   */\n  withTransfer(params: TransferParams) {\n    this.operations.push({ kind: OpKind.TRANSACTION, ...params });\n    return this;\n  }\n\n  /**\n   *\n   * @description Add a transaction operation to the batch\n   *\n   * @param params Transfer operation parameter\n   */\n  withContractCall(params: ContractMethod<ContractProvider>) {\n    return this.withTransfer(params.toTransferParams());\n  }\n\n  /**\n   *\n   * @description Add a delegation operation to the batch\n   *\n   * @param params Delegation operation parameter\n   */\n  withDelegation(params: DelegateParams) {\n    this.operations.push({ kind: OpKind.DELEGATION, ...params });\n    return this;\n  }\n\n  /**\n   *\n   * @description Add an activation operation to the batch\n   *\n   * @param params Activation operation parameter\n   */\n  withActivation({ pkh, secret }: ActivationParams) {\n    this.operations.push({ kind: OpKind.ACTIVATION, pkh, secret });\n    return this;\n  }\n\n  /**\n   *\n   * @description Add an origination operation to the batch\n   *\n   * @param params Origination operation parameter\n   */\n  withOrigination(params: OriginateParams) {\n    this.operations.push({ kind: OpKind.ORIGINATION, ...params });\n    return this;\n  }\n\n  private async getRPCOp(param: ParamsWithKind) {\n    switch (param.kind) {\n      case OpKind.TRANSACTION:\n        return createTransferOperation({\n          ...param,\n        });\n      case OpKind.ORIGINATION:\n        return createOriginationOperation(\n          await this.context.parser.prepareCodeOrigination({\n            ...param,\n          })\n        );\n      case OpKind.DELEGATION:\n        return createSetDelegateOperation({\n          ...param,\n        });\n      case OpKind.ACTIVATION:\n        return {\n          ...param,\n        };\n      default:\n        throw new Error(`Unsupported operation kind: ${(param as any).kind}`);\n    }\n  }\n\n  /**\n   *\n   * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array\n   *\n   * @param params Operations parameter\n   */\n  with(params: ParamsWithKind[]) {\n    for (const param of params) {\n      switch (param.kind) {\n        case OpKind.TRANSACTION:\n          this.withTransfer(param);\n          break;\n        case OpKind.ORIGINATION:\n          this.withOrigination(param);\n          break;\n        case OpKind.DELEGATION:\n          this.withDelegation(param);\n          break;\n        case OpKind.ACTIVATION:\n          this.withActivation(param);\n          break;\n        default:\n          throw new Error(`Unsupported operation kind: ${(param as any).kind}`);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   *\n   * @description Forge and Inject the operation batch\n   *\n   * @param params Optionally specify the source of the operation\n   */\n  async send(params?: { source?: string }) {\n    const publicKeyHash = await this.signer.publicKeyHash();\n    const publicKey = await this.signer.publicKey();\n    const estimates = await this.estimator.batch(this.operations);\n\n    const revealNeeded = await this.isRevealOpNeeded(this.operations, publicKeyHash);\n    let i = revealNeeded ? 1 : 0;\n\n    const ops: RPCOperation[] = [];\n    for (const op of this.operations) {\n      if (isOpWithFee(op)) {\n        const estimated = await this.estimate(op, async () => estimates[i]);\n        ops.push(await this.getRPCOp({ ...op, ...estimated }));\n      } else {\n        ops.push({ ...op });\n      }\n      i++;\n    }\n    if (revealNeeded) {\n      const reveal: withKind<RevealParams, OpKind.REVEAL> = { kind: OpKind.REVEAL };\n      const estimatedReveal = await this.estimate(reveal, async () => estimates[0]);\n      ops.unshift(await createRevealOperation({ ...estimatedReveal }, publicKeyHash, publicKey));\n    }\n\n    const source = (params && params.source) || publicKeyHash;\n    const prepared = await this.prepareOpAndSimulation({\n      operation: ops,\n      source\n    });\n    const forgedBytes = await this.forge(prepared.preparedOp);\n    const signedOperation = await this.signOperation(forgedBytes);\n    const opResponse = await this.preValidate(prepared, signedOperation);\n    const hash = await this.injectOperation(signedOperation.opbytes);\n    return new BatchOperation(hash, ops, source, forgedBytes, opResponse, this.context.clone());\n  }\n}\n\nexport class RPCBatchProvider {\n  constructor(private context: Context, private estimator: EstimationProvider) {}\n\n  /***\n   *\n   * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch\n   *\n   * @param params List of operation to batch together\n   */\n  batch(params?: ParamsWithKind[]) {\n    const batch = new OperationBatch(this.context, this.estimator);\n\n    if (Array.isArray(params)) {\n      batch.with(params);\n    }\n\n    return batch;\n  }\n}\n","import { OperationContentsAndResult, OperationContentsAndResultDelegation } from '@taquito/rpc';\nimport { Context } from '../context';\nimport { Operation } from './operations';\nimport {\n  FeeConsumingOperation,\n  ForgedBytes,\n  GasConsumingOperation,\n  RPCDelegateOperation,\n  StorageConsumingOperation,\n} from './types';\n\n/**\n * @description Delegation operation provide utility function to fetch newly issued delegation\n *\n * @warn Currently support only one delegation per operation\n */\nexport class DelegateOperation extends Operation\n  implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n  constructor(\n    hash: string,\n    private readonly params: RPCDelegateOperation,\n    public readonly source: string,\n    raw: ForgedBytes,\n    results: OperationContentsAndResult[],\n    context: Context\n  ) {\n    super(hash, raw, results, context);\n  }\n\n  get operationResults() {\n    const delegationOp =\n      Array.isArray(this.results) &&\n      (this.results.find(op => op.kind === 'delegation') as OperationContentsAndResultDelegation);\n    const result = delegationOp && delegationOp.metadata && delegationOp.metadata.operation_result;\n    return result ? result : undefined;\n  }\n\n  get status() {\n    const operationResults = this.operationResults;\n    if (operationResults) {\n      return operationResults.status;\n    } else {\n      return 'unknown';\n    }\n  }\n\n  get delegate(): string {\n    return this.delegate;\n  }\n\n  get isRegisterOperation(): boolean {\n    return this.delegate === this.source;\n  }\n\n  get fee() {\n    return this.params.fee;\n  }\n\n  get gasLimit() {\n    return this.params.gas_limit;\n  }\n\n  get storageLimit() {\n    return this.params.storage_limit;\n  }\n\n  get consumedGas() {\n    const consumedGas = this.operationResults && this.operationResults.consumed_gas;\n    return consumedGas ? consumedGas : undefined;\n  }\n\n  get errors() {\n    return this.operationResults && this.operationResults.errors;\n  }\n}\n","import { OperationContentsAndResult, OperationContentsAndResultOrigination } from '@taquito/rpc';\nimport { Context } from '../context';\nimport { RpcContractProvider } from '../contract/rpc-contract-provider';\nimport { Operation } from './operations';\nimport {\n  FeeConsumingOperation,\n  ForgedBytes,\n  GasConsumingOperation,\n  hasMetadataWithResult,\n  RPCOriginationOperation,\n  StorageConsumingOperation,\n} from './types';\n\n/**\n * @description Origination operation provide utility function to fetch newly originated contract\n *\n * @warn Currently support only one origination per operation\n */\nexport class OriginationOperation\n  extends Operation\n  implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n  /**\n   * @description Contract address of the newly originated contract\n   */\n  public readonly contractAddress?: string;\n\n  constructor(\n    hash: string,\n    private readonly params: RPCOriginationOperation,\n    raw: ForgedBytes,\n    results: OperationContentsAndResult[],\n    context: Context,\n    private contractProvider: RpcContractProvider\n  ) {\n    super(hash, raw, results, context);\n\n    const originatedContracts = this.operationResults && this.operationResults.originated_contracts;\n    if (Array.isArray(originatedContracts)) {\n      this.contractAddress = originatedContracts[0];\n    }\n  }\n\n  get status() {\n    const operationResults = this.operationResults;\n    if (operationResults) {\n      return operationResults.status;\n    } else {\n      return 'unknown';\n    }\n  }\n\n  get operationResults() {\n    const originationOp =\n      Array.isArray(this.results) &&\n      (this.results.find((op) => op.kind === 'origination') as\n        | OperationContentsAndResultOrigination\n        | undefined);\n\n    const result =\n      originationOp &&\n      hasMetadataWithResult(originationOp) &&\n      originationOp.metadata.operation_result;\n    return result ? result : undefined;\n  }\n\n  get fee() {\n    return this.params.fee;\n  }\n\n  get gasLimit() {\n    return this.params.gas_limit;\n  }\n\n  get storageLimit() {\n    return this.params.storage_limit;\n  }\n\n  get consumedGas() {\n    const consumedGas = this.operationResults && this.operationResults.consumed_gas;\n    return consumedGas ? consumedGas : undefined;\n  }\n\n  get storageDiff() {\n    const storageDiff = this.operationResults && this.operationResults.paid_storage_size_diff;\n    return storageDiff ? storageDiff : undefined;\n  }\n\n  get storageSize() {\n    const storageSize = this.operationResults && this.operationResults.storage_size;\n    return storageSize ? storageSize : undefined;\n  }\n\n  get errors() {\n    return this.operationResults && this.operationResults.errors;\n  }\n\n  /**\n   * @description Provide the contract abstract of the newly originated contract\n   */\n  async contract(confirmations?: number, interval?: number, timeout?: number) {\n    if (!this.contractAddress) {\n      throw new Error('No contract was originated in this operation');\n    }\n\n    await this.confirmation(confirmations, interval, timeout);\n    return this.contractProvider.at(this.contractAddress);\n  }\n}\n","import { OperationContentsAndResult, OperationContentsAndResultReveal } from '@taquito/rpc';\nimport { Context } from '../context';\nimport { flattenErrors, flattenOperationResult } from './operation-errors';\nimport { Operation } from './operations';\nimport {\n  FeeConsumingOperation,\n  ForgedBytes,\n  GasConsumingOperation,\n  RPCRevealOperation,\n  StorageConsumingOperation,\n} from './types';\n\n/**\n * @description Reveal operation provides utility functions to fetch a newly issued revelation\n */\nexport class RevealOperation extends Operation\n  implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n  constructor(\n    hash: string,\n    private readonly params: RPCRevealOperation,\n    public readonly source: string,\n    raw: ForgedBytes,\n    results: OperationContentsAndResult[],\n    context: Context\n  ) {\n    super(hash, raw, results, context);\n  }\n\n  get operationResults() {\n    const revealOp =\n      Array.isArray(this.results) &&\n      (this.results.find(op => op.kind === 'reveal') as OperationContentsAndResultReveal);\n    return revealOp ? [revealOp] : [];\n  }\n\n  get status() {\n    const operationResults = this.operationResults;\n    const txResult = operationResults[0];\n    if (txResult) {\n      return txResult.metadata.operation_result.status;\n    } else {\n      return 'unknown';\n    }\n  }\n\n  get fee() {\n    return this.params.fee;\n  }\n\n  get gasLimit() {\n    return this.params.gas_limit;\n  }\n\n  get storageLimit() {\n    return this.params.storage_limit;\n  }\n\n  get publicKey() {\n    return this.params.public_key;\n  }\n\n  private sumProp(arr: any[], prop: string) {\n    return arr.reduce((prev, current) => {\n      return prop in current ? Number(current[prop]) + prev : prev;\n    }, 0);\n  }\n\n  get consumedGas() {\n    return String(\n      this.sumProp(flattenOperationResult({ contents: this.operationResults }), 'consumed_gas')\n    );\n  }\n\n  get storageDiff() {\n    return String(\n      this.sumProp(\n        flattenOperationResult({ contents: this.operationResults }),\n        'paid_storage_size_diff'\n      )\n    );\n  }\n\n  get storageSize() {\n    return String(\n      this.sumProp(flattenOperationResult({ contents: this.operationResults }), 'storage_size')\n    );\n  }\n\n  get errors() {\n    return flattenErrors({ contents: this.operationResults });\n  }\n}\n","import { OperationContentsAndResult, OperationContentsAndResultTransaction } from '@taquito/rpc';\nimport BigNumber from 'bignumber.js';\nimport { Context } from '../context';\nimport { flattenErrors, flattenOperationResult } from './operation-errors';\nimport { Operation } from './operations';\nimport {\n  FeeConsumingOperation,\n  ForgedBytes,\n  GasConsumingOperation,\n  RPCTransferOperation,\n  StorageConsumingOperation,\n} from './types';\n\n/**\n * @description Transaction operation provides utility functions to fetch a newly issued transaction\n *\n * @warn Currently supports one transaction per operation\n */\nexport class TransactionOperation extends Operation\n  implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n  constructor(\n    hash: string,\n    private readonly params: RPCTransferOperation,\n    public readonly source: string,\n    raw: ForgedBytes,\n    results: OperationContentsAndResult[],\n    context: Context\n  ) {\n    super(hash, raw, results, context);\n  }\n\n  get operationResults() {\n    const transactionOp =\n      Array.isArray(this.results) &&\n      (this.results.find(op => op.kind === 'transaction') as OperationContentsAndResultTransaction);\n    return transactionOp ? [transactionOp] : [];\n  }\n\n  get status() {\n    const operationResults = this.operationResults;\n    const txResult = operationResults[0];\n    if (txResult) {\n      return txResult.metadata.operation_result.status;\n    } else {\n      return 'unknown';\n    }\n  }\n\n  get amount() {\n    return new BigNumber(this.params.amount);\n  }\n\n  get destination() {\n    return this.params.destination;\n  }\n\n  get fee() {\n    return this.params.fee;\n  }\n\n  get gasLimit() {\n    return this.params.gas_limit;\n  }\n\n  get storageLimit() {\n    return this.params.storage_limit;\n  }\n\n  private sumProp(arr: any[], prop: string) {\n    return arr.reduce((prev, current) => {\n      return prop in current ? Number(current[prop]) + prev : prev;\n    }, 0);\n  }\n\n  get consumedGas() {\n    return String(\n      this.sumProp(flattenOperationResult({ contents: this.operationResults }), 'consumed_gas')\n    );\n  }\n\n  get storageDiff() {\n    return String(\n      this.sumProp(\n        flattenOperationResult({ contents: this.operationResults }),\n        'paid_storage_size_diff'\n      )\n    );\n  }\n\n  get storageSize() {\n    return String(\n      this.sumProp(flattenOperationResult({ contents: this.operationResults }), 'storage_size')\n    );\n  }\n\n  get errors() {\n    return flattenErrors({ contents: this.operationResults });\n  }\n}\n","const setDelegate = (key: string) => {\n  return [\n    { prim: 'DROP' },\n    { prim: 'NIL', args: [{ prim: 'operation' }] },\n    {\n      prim: 'PUSH',\n      args: [{ prim: 'key_hash' }, { string: key }],\n    },\n    { prim: 'SOME' },\n    { prim: 'SET_DELEGATE' },\n    { prim: 'CONS' },\n  ];\n};\n\nconst transferImplicit = (key: string, mutez: number) => {\n  return [\n    { prim: 'DROP' },\n    { prim: 'NIL', args: [{ prim: 'operation' }] },\n    {\n      prim: 'PUSH',\n      args: [{ prim: 'key_hash' }, { string: key }],\n    },\n    { prim: 'IMPLICIT_ACCOUNT' },\n    {\n      prim: 'PUSH',\n      args: [{ prim: 'mutez' }, { int: `${mutez}` }],\n    },\n    { prim: 'UNIT' },\n    { prim: 'TRANSFER_TOKENS' },\n    { prim: 'CONS' },\n  ];\n};\n\nconst removeDelegate = () => {\n  return [\n    { prim: 'DROP' },\n    { prim: 'NIL', args: [{ prim: 'operation' }] },\n    { prim: 'NONE', args: [{ prim: 'key_hash' }] },\n    { prim: 'SET_DELEGATE' },\n    { prim: 'CONS' },\n  ];\n};\n\nconst transferToContract = (key: string, amount: number) => {\n  return [\n    { prim: 'DROP' },\n    { prim: 'NIL', args: [{ prim: 'operation' }] },\n    {\n      prim: 'PUSH',\n      args: [{ prim: 'address' }, { string: key }],\n    },\n    { prim: 'CONTRACT', args: [{ prim: 'unit' }] },\n    [\n      {\n        prim: 'IF_NONE',\n        args: [[[{ prim: 'UNIT' }, { prim: 'FAILWITH' }]], []],\n      },\n    ],\n    {\n      prim: 'PUSH',\n      args: [{ prim: 'mutez' }, { int: `${amount}` }],\n    },\n    { prim: 'UNIT' },\n    { prim: 'TRANSFER_TOKENS' },\n    { prim: 'CONS' },\n  ];\n};\n\nexport const MANAGER_LAMBDA = {\n  setDelegate,\n  removeDelegate,\n  transferImplicit,\n  transferToContract,\n};\n","const code = [\n  {\n    prim: 'parameter',\n    args: [\n      {\n        prim: 'lambda',\n        args: [\n          { prim: 'unit' },\n          {\n            prim: 'pair',\n            args: [{ prim: 'list', args: [{ prim: 'operation' }] }, { prim: 'unit' }],\n          },\n        ],\n      },\n    ],\n  },\n  { prim: 'storage', args: [{ prim: 'unit' }] },\n  { prim: 'code', args: [[{ prim: 'CAR' }, { prim: 'UNIT' }, { prim: 'EXEC' }]] },\n];\n\nconst storage = 'Unit';\n\nexport const VIEW_LAMBDA = {\n  code,\n  storage\n}\n","import { Wallet } from '../wallet/wallet';\nimport { Context } from '../context';\nimport { ContractAbstraction } from './contract';\nimport { ContractProvider } from './interface';\n\nexport function compose<\n    ContractAbsComposer1 extends ContractAbstraction<ContractProvider | Wallet>,\n    ContractAbsComposer2 extends ContractAbstraction<ContractProvider | Wallet>,\n    ContractAbstractionComposed\n>(\n    functioncomposer1: (abs: ContractAbsComposer1, context: Context) => ContractAbsComposer2,\n    functioncomposer2: (abs: ContractAbsComposer2, context: Context) => ContractAbstractionComposed\n): (abs: ContractAbsComposer1, context: Context) => ContractAbstractionComposed {\n    return (contractAbstraction, context) =>\n        functioncomposer2(functioncomposer1(contractAbstraction, context), context);\n}\n","import { Protocols } from '../constants';\nimport { Context } from '../context';\nimport { ContractAbstraction, ContractMethod } from '../contract';\nimport { OpKind, withKind } from '../operations/types';\nimport {\n  WalletDelegateParams,\n  WalletOriginateParams,\n  WalletProvider,\n  WalletTransferParams,\n} from './interface';\n\nexport interface PKHOption {\n  forceRefetch?: boolean;\n}\n\nexport type WalletParamsWithKind =\n  | withKind<WalletTransferParams, OpKind.TRANSACTION>\n  | withKind<WalletOriginateParams, OpKind.ORIGINATION>\n  | withKind<WalletDelegateParams, OpKind.DELEGATION>;\n\nexport class WalletOperationBatch {\n  private operations: WalletParamsWithKind[] = [];\n\n  constructor(private walletProvider: WalletProvider, private context: Context) {}\n\n  /**\n   *\n   * @description Add a transaction operation to the batch\n   *\n   * @param params Transfer operation parameter\n   */\n  withTransfer(params: WalletTransferParams) {\n    this.operations.push({ kind: OpKind.TRANSACTION, ...params });\n    return this;\n  }\n\n  /**\n   *\n   * @description Add a transaction operation to the batch\n   *\n   * @param params Transfer operation parameter\n   */\n  withContractCall(params: ContractMethod<Wallet>) {\n    return this.withTransfer(params.toTransferParams());\n  }\n\n  /**\n   *\n   * @description Add a delegation operation to the batch\n   *\n   * @param params Delegation operation parameter\n   */\n  withDelegation(params: WalletDelegateParams) {\n    this.operations.push({ kind: OpKind.DELEGATION, ...params });\n    return this;\n  }\n\n  /**\n   *\n   * @description Add an origination operation to the batch\n   *\n   * @param params Origination operation parameter\n   */\n  withOrigination(params: WalletOriginateParams) {\n    this.operations.push({ kind: OpKind.ORIGINATION, ...params });\n    return this;\n  }\n\n  private async mapOperation(param: WalletParamsWithKind) {\n\t\tswitch (param.kind) {\n\t\t\tcase OpKind.TRANSACTION:\n\t\t\t\treturn this.walletProvider.mapTransferParamsToWalletParams({\n\t\t\t\t\t...param\n\t\t\t\t});\n\t\t\tcase OpKind.ORIGINATION:\n\t\t\t\treturn this.walletProvider.mapOriginateParamsToWalletParams(\n\t\t\t\t\tawait this.context.parser.prepareCodeOrigination({\n\t\t\t\t\t\t...param\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\tcase OpKind.DELEGATION:\n\t\t\t\treturn this.walletProvider.mapDelegateParamsToWalletParams({\n\t\t\t\t\t...param\n\t\t\t\t});\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unsupported operation kind: ${(param as any).kind}`);\n\t\t}\n\t}\n\n  /**\n   *\n   * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array\n   *\n   * @param params Operations parameter\n   */\n  with(params: WalletParamsWithKind[]) {\n    for (const param of params) {\n      switch (param.kind) {\n        case OpKind.TRANSACTION:\n          this.withTransfer(param);\n          break;\n        case OpKind.ORIGINATION:\n          this.withOrigination(param);\n          break;\n        case OpKind.DELEGATION:\n          this.withDelegation(param);\n          break;\n        default:\n          throw new Error(`Unsupported operation kind: ${(param as any).kind}`);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   *\n   * @description Submit batch operation to wallet\n   *\n   */\n  async send() {\n    const ops: WalletParamsWithKind[] = [];\n\n    for (const op of this.operations) {\n      ops.push(await this.mapOperation(op));\n    }\n\n    const opHash = await this.walletProvider.sendOperations(ops);\n\n    return this.context.operationFactory.createOperation(opHash);\n  }\n}\n\nexport class Wallet {\n  constructor(private context: Context) {}\n\n  private get walletProvider() {\n    return this.context.walletProvider;\n  }\n\n  private _pkh?: string;\n\n  /**\n   * @description Retrieve the PKH of the account that is currently in use by the wallet\n   *\n   * @param option Option to use while fetching the PKH.\n   * If forceRefetch is specified the wallet provider implementation will refetch the PKH from the wallet\n   */\n  async pkh({ forceRefetch }: PKHOption = {}) {\n    if (!this._pkh || forceRefetch) {\n      this._pkh = await this.walletProvider.getPKH();\n    }\n\n    return this._pkh;\n  }\n\n  private walletCommand = <T>(send: () => Promise<T>) => {\n    return {\n      send,\n    };\n  };\n\n  /**\n   *\n   * @description Originate a new contract according to the script in parameters.\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   * @param originateParams Originate operation parameter\n   */\n  originate(params: WalletOriginateParams) {\n\t\treturn this.walletCommand(async () => {\n\t\t\tconst mappedParams = await this.walletProvider.mapOriginateParamsToWalletParams(\n\t\t\t\tawait this.context.parser.prepareCodeOrigination({\n\t\t\t\t\t...params\n\t\t\t\t})\n\t\t\t);\n\t\t\tconst opHash = await this.walletProvider.sendOperations([ mappedParams ]);\n\t\t\tif (!this.context.proto) {\n\t\t\t\tthis.context.proto = (await this.context.rpc.getBlock()).protocol as Protocols;\n\t\t\t}\n\t\t\treturn this.context.operationFactory.createOriginationOperation(opHash);\n\t\t});\n\t}\n\n  /**\n   *\n   * @description Set the delegate for a contract.\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   * @param delegateParams operation parameter\n   */\n  setDelegate(params: WalletDelegateParams) {\n    return this.walletCommand(async () => {\n      const mappedParams = await this.walletProvider.mapDelegateParamsToWalletParams({ ...params });\n      const opHash = await this.walletProvider.sendOperations([mappedParams]);\n      return this.context.operationFactory.createDelegationOperation(opHash);\n    });\n  }\n\n  /**\n   *\n   * @description Register the current address as delegate.\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   */\n  registerDelegate() {\n    return this.walletCommand(async () => {\n      const mappedParams = await this.walletProvider.mapDelegateParamsToWalletParams({\n        delegate: await this.pkh(),\n      });\n      const opHash = await this.walletProvider.sendOperations([mappedParams]);\n      return this.context.operationFactory.createDelegationOperation(opHash);\n    });\n  }\n\n  /**\n   *\n   * @description Transfer tezos tokens from current address to a specific address or call a smart contract.\n   *\n   * @returns A wallet command from which we can send the operation to the wallet\n   *\n   * @param params operation parameter\n   */\n  transfer(params: WalletTransferParams) {\n    return this.walletCommand(async () => {\n      const mappedParams = await this.walletProvider.mapTransferParamsToWalletParams(params);\n      const opHash = await this.walletProvider.sendOperations([mappedParams]);\n      return this.context.operationFactory.createTransactionOperation(opHash);\n    });\n  }\n\n  /**\n   *\n   * @description Create a batch of operation\n   *\n   * @returns A batch object from which we can add more operation or send a command to the wallet to execute the batch\n   *\n   * @param params List of operation to initialize the batch with\n   */\n  batch(params?: Parameters<WalletOperationBatch['with']>[0]) {\n    const batch = new WalletOperationBatch(this.walletProvider, this.context);\n    \n    if (Array.isArray(params)) {\n      batch.with(params);\n    }\n    \n    return batch;\n  }\n\n  /**\n   *\n   * @description Create an smart contract abstraction for the address specified. Calling entrypoints with the returned\n   * smart contract abstraction will leverage the wallet provider to make smart contract calls\n   *\n   * @param address Smart contract address\n   */\n  async at<T extends ContractAbstraction<Wallet>>(address: string, contractAbstractionComposer: (abs: ContractAbstraction<Wallet>, context: Context) => T = x => x as any): Promise<T> {\n    const script = await this.context.rpc.getScript(address);\n    const entrypoints = await this.context.rpc.getEntrypoints(address);\n    const blockHeader = await this.context.rpc.getBlockHeader();\n    const chainId = blockHeader.chain_id;\n    const abs = new ContractAbstraction(address, script, this, this.context.contract, entrypoints, chainId);\n    return contractAbstractionComposer(abs, this.context);\n  }\n}","import { Context } from '../context';\nimport { attachKind, OpKind } from '../operations/types';\nimport {\n  WalletDelegateParams,\n  WalletOriginateParams,\n  WalletProvider,\n  WalletTransferParams,\n} from './interface';\nimport { WalletParamsWithKind } from './wallet';\n\nexport class LegacyWalletProvider implements WalletProvider {\n  constructor(private context: Context) {}\n\n  async getPKH(): Promise<string> {\n    return this.context.signer.publicKeyHash();\n  }\n\n  async mapTransferParamsToWalletParams(params: WalletTransferParams) {\n    return attachKind(params, OpKind.TRANSACTION);\n  }\n\n  async mapOriginateParamsToWalletParams(params: WalletOriginateParams) {\n    return attachKind(params, OpKind.ORIGINATION);\n  }\n\n  async mapDelegateParamsToWalletParams(params: WalletDelegateParams) {\n    return attachKind(params, OpKind.DELEGATION);\n  }\n\n  async sendOperations(params: WalletParamsWithKind[]) {\n    const op = await this.context.batch.batch(params as any).send();\n    return op.hash;\n  }\n}\n","import { MichelsonV1Expression } from '@taquito/rpc';\nimport { Contract, ContractAbstraction, WalletContract } from './contract';\nimport { TezosOperationError } from '../operations/operation-errors';\nimport { ContractProvider } from './interface';\nimport { Wallet } from '../wallet';\n\nexport default class LambdaView {\n  public readonly voidLambda: Object;\n\n  constructor(\n    private lambdaContract: Contract | WalletContract,\n    private viewContract: ContractAbstraction< ContractProvider | Wallet > ,\n    public readonly viewMethod: string = 'default',\n    private contractParameter: MichelsonV1Expression = { prim: 'Unit' }\n  ) {\n    this.voidLambda = this.createVoidLambda();\n  }\n\n  async execute(): Promise<any> {\n    try {\n      await this.lambdaContract.methods.default(this.voidLambda).send();\n    } catch (ex) {\n      if (ex instanceof TezosOperationError) {\n        const lastError: any = ex.errors[ex.errors.length - 1];\n\n        const failedWith = lastError.with;\n        return failedWith;\n      } else { \n        throw ex;\n      }\n    }\n  }\n\n  private createVoidLambda(): Object {\n    const [parameter, callback] = this.getView();\n\n    let contractArgs: MichelsonV1Expression[] = [\n      {\n        prim: 'pair',\n        args: [parameter, { prim: 'contract', args: [callback] }],\n      },\n    ];\n\n    if (this.viewMethod === 'default') {\n      contractArgs = ([{ string: '%default' }] as MichelsonV1Expression[]).concat(contractArgs);\n    }\n\n    return [\n      { prim: 'PUSH', args: [{ prim: 'mutez' }, { int: '0' }] },\n      { prim: 'NONE', args: [{ prim: 'key_hash' }] },\n      {\n        prim: 'CREATE_CONTRACT',\n        args: [\n          [\n            { prim: 'parameter', args: [callback] },\n            { prim: 'storage', args: [{ prim: 'unit' }] },\n            {\n              prim: 'code',\n              args: [[{ prim: 'CAR' }, { prim: 'FAILWITH' }]],\n            },\n          ],\n        ],\n      },\n      {\n        prim: 'DIP',\n        args: [\n          [\n            {\n              prim: 'DIP',\n              args: [\n                [\n                  {\n                    prim: 'LAMBDA',\n                    args: [\n                      {\n                        prim: 'pair',\n                        args: [{ prim: 'address' }, { prim: 'unit' }],\n                      },\n                      {\n                        prim: 'pair',\n                        args: [{ prim: 'list', args: [{ prim: 'operation' }] }, { prim: 'unit' }],\n                      },\n                      [\n                        { prim: 'CAR' },\n                        { prim: 'CONTRACT', args: [callback] },\n                        {\n                          prim: 'IF_NONE',\n                          args: [\n                            [\n                              {\n                                prim: 'PUSH',\n                                args: [{ prim: 'string' }, { string: `Callback type unmatched` }],\n                              },\n                              { prim: 'FAILWITH' },\n                            ],\n                            [],\n                          ],\n                        },\n                        {\n                          prim: 'PUSH',\n                          args: [parameter, this.contractParameter],\n                        },\n                        { prim: 'PAIR' },\n                        {\n                          prim: 'DIP',\n                          args: [\n                            [\n                              {\n                                prim: 'PUSH',\n                                args: [\n                                  { prim: 'address' },\n                                  { string: `${this.viewContract.address}%${this.viewMethod}` },\n                                ],\n                              },\n                              { prim: 'DUP' },\n                              { prim: 'CONTRACT', args: contractArgs },\n                              {\n                                prim: 'IF_NONE',\n                                args: [\n                                  [\n                                    {\n                                      prim: 'PUSH',\n                                      args: [\n                                        { prim: 'string' },\n                                        { string: `Contract does not exist` },\n                                      ],\n                                    },\n                                    { prim: 'FAILWITH' },\n                                  ],\n                                  [{ prim: 'DIP', args: [[{ prim: 'DROP' }]] }],\n                                ],\n                              },\n                              {\n                                prim: 'PUSH',\n                                args: [{ prim: 'mutez' }, { int: '0' }],\n                              },\n                            ],\n                          ],\n                        },\n                        { prim: 'TRANSFER_TOKENS' },\n                        {\n                          prim: 'DIP',\n                          args: [[{ prim: 'NIL', args: [{ prim: 'operation' }] }]],\n                        },\n                        { prim: 'CONS' },\n                        { prim: 'DIP', args: [[{ prim: 'UNIT' }]] },\n                        { prim: 'PAIR' },\n                      ],\n                    ],\n                  },\n                ],\n              ],\n            },\n            { prim: 'APPLY' },\n            {\n              prim: 'DIP',\n              args: [\n                [\n                  {\n                    prim: 'PUSH',\n                    args: [{ prim: 'address' }, { string: this.lambdaContract.address }],\n                  },\n                  { prim: 'DUP' },\n                  {\n                    prim: 'CONTRACT',\n                    args: [\n                      {\n                        prim: 'lambda',\n                        args: [\n                          { prim: 'unit' },\n                          {\n                            prim: 'pair',\n                            args: [\n                              { prim: 'list', args: [{ prim: 'operation' }] },\n                              { prim: 'unit' },\n                            ],\n                          },\n                        ],\n                      },\n                    ],\n                  },\n                  {\n                    prim: 'IF_NONE',\n                    args: [\n                      [\n                        {\n                          prim: 'PUSH',\n                          args: [{ prim: 'string' }, { string: `Contract does not exists` }],\n                        },\n                        { prim: 'FAILWITH' },\n                      ],\n                      [{ prim: 'DIP', args: [[{ prim: 'DROP' }]] }],\n                    ],\n                  },\n                  { prim: 'PUSH', args: [{ prim: 'mutez' }, { int: '0' }] },\n                ],\n              ],\n            },\n            { prim: 'TRANSFER_TOKENS' },\n            {\n              prim: 'DIP',\n              args: [[{ prim: 'NIL', args: [{ prim: 'operation' }] }]],\n            },\n            { prim: 'CONS' },\n          ],\n        ],\n      },\n      { prim: 'CONS' },\n      { prim: 'DIP', args: [[{ prim: 'UNIT' }]] },\n      { prim: 'PAIR' },\n    ];\n  }\n\n  private getView(): [MichelsonV1Expression, MichelsonV1Expression] {\n    const entrypoints = this.viewContract.entrypoints.entrypoints;\n    const entrypoint = entrypoints[this.viewMethod] as MichelsonV1Expression;\n\n    if (!entrypoint) {\n      throw Error(\n        `Contract at ${this.viewContract.address} does not have entrypoint: ${this.viewMethod}`\n      );\n    }\n\n    if (!('prim' in entrypoint) || !entrypoint.args) {\n      // TODO: Enhance this error message to be more descriptive\n      throw Error('Entrypoint args undefined');\n    }\n\n    const args = Array.from(entrypoint.args) as [MichelsonV1Expression, MichelsonV1Expression];\n    const [parameter, callbackContract] = args;\n    if( 'annots' in parameter ) {\n      delete parameter['annots']\n    }\n\n    if (!('prim' in callbackContract) || !callbackContract.args) {\n      // TODO: Enhance this error message to be more descriptive\n      throw Error('Callback contract args undefined');\n    }\n\n    let message;\n    if (entrypoint.prim !== 'pair') {\n      message = `Expected {'prim': 'pair', ..} but found {'prim': ${entrypoint.prim}, ..}`;\n    } else if (args.length !== 2) {\n      message = `Expected an Array of length 2, but found: ${args}`;\n    } else if (callbackContract.prim !== 'contract') {\n      message = `Expected a {prim: 'contract', ...}, but found: ${callbackContract.prim}`;\n    } else if (callbackContract.args && callbackContract.args.length !== 1) {\n      message = `Expected a single argument to 'contract', but found: ${callbackContract.args}`;\n    }\n\n    if (message) throw Error(message);\n\n    return [parameter, callbackContract.args[0]] as [MichelsonV1Expression, MichelsonV1Expression];\n  }\n}\n","import { ParameterSchema, Schema } from '@taquito/michelson-encoder';\nimport { EntrypointsResponse, ScriptResponse } from '@taquito/rpc';\nimport { ChainIds, DefaultLambdaAddresses } from '../constants';\nimport { TransactionOperation } from '../operations/transaction-operation';\nimport { TransferParams } from '../operations/types';\nimport { TransactionWalletOperation, Wallet } from '../wallet';\nimport { InvalidParameterError, UndefinedLambdaContractError } from './errors';\nimport { ContractProvider, StorageProvider } from './interface';\nimport LambdaView from './lambda-view';\n\ninterface SendParams {\n  fee?: number;\n  storageLimit?: number;\n  gasLimit?: number;\n  amount: number;\n  source?: string;\n  mutez?: boolean;\n}\n\n// Ensure that all parameter that are not in SendParams are defined\ntype ExplicitTransferParams = Required<Omit<TransferParams, keyof SendParams>> & SendParams;\n\nconst DEFAULT_SMART_CONTRACT_METHOD_NAME = 'default';\n\n/**\n * @description Utility class to send smart contract operation\n */\nexport class ContractMethod<T extends ContractProvider | Wallet> {\n  constructor(\n    private provider: T,\n    private address: string,\n    private parameterSchema: ParameterSchema,\n    private name: string,\n    private args: any[],\n    private isMultipleEntrypoint = true,\n    private isAnonymous = false\n  ) { }\n\n  /**\n   * @description Get the schema of the smart contract method\n   */\n  get schema() {\n    return this.isAnonymous\n      ? this.parameterSchema.ExtractSchema()[this.name]\n      : this.parameterSchema.ExtractSchema();\n  }\n\n  /**\n   *\n   * @description Send the smart contract operation\n   *\n   * @param Options generic operation parameter\n   */\n  send(\n    params: Partial<SendParams> = {}\n  ): Promise<T extends Wallet ? TransactionWalletOperation : TransactionOperation> {\n    if (this.provider instanceof Wallet) {\n      // TODO got around TS2352: Conversion of type 'T & Wallet' to type 'Wallet' by adding `as unknown`. Needs clarification\n      return (this.provider as unknown as Wallet).transfer(this.toTransferParams(params)).send() as any;\n    } else {\n      return this.provider.transfer(this.toTransferParams(params)) as any;\n    }\n  }\n\n  /**\n   *\n   * @description Create transfer params to be used with TezosToolkit.contract.transfer methods\n   *\n   * @param Options generic transfer operation parameters\n   */\n  toTransferParams({\n    fee,\n    gasLimit,\n    storageLimit,\n    source,\n    amount = 0,\n    mutez = false,\n  }: Partial<SendParams> = {}): TransferParams {\n    const fullTransferParams: ExplicitTransferParams = {\n      to: this.address,\n      amount,\n      fee,\n      mutez,\n      source,\n      gasLimit,\n      storageLimit,\n      parameter: {\n        entrypoint: this.isMultipleEntrypoint ? this.name : 'default',\n        value: this.isAnonymous\n          ? this.parameterSchema.Encode(this.name, ...this.args)\n          : this.parameterSchema.Encode(...this.args),\n      },\n    };\n    return fullTransferParams;\n  }\n}\n\n/**\n * @description Utility class to retrieve data from a smart contract's storage without incurring fees via a contract's view method\n */\nexport class ContractView {\n  constructor(\n    private currentContract: ContractAbstraction<ContractProvider | Wallet>,\n    private provider: ContractProvider,\n    private name: string,\n    private chainId: string,\n    private callbackParametersSchema: ParameterSchema,\n    private parameterSchema: ParameterSchema,\n    private args: any[]\n  ) { }\n\n  /**\n   *\n   * @description Find which lambda contract to use based on the current network, \n   * encode parameters to Michelson, \n   * create an instance of Lambdaview to retrive data, and\n   * Decode Michelson response \n   *\n   * @param Options Address of a lambda contract (sandbox users)\n   */\n  async read(customLambdaAddress?: string) {\n\n    let lambdaAddress;\n\n    // TODO Verify if the 'customLambdaAdress' is a valid originated contract and if not, return an appropriate error message. \n    if (customLambdaAddress) {\n      lambdaAddress = customLambdaAddress\n    } else if (this.chainId === ChainIds.EDONET) {\n      lambdaAddress = DefaultLambdaAddresses.EDONET\n    } else if (this.chainId === ChainIds.FLORENCENET) {\n      lambdaAddress = DefaultLambdaAddresses.FLORENCENET\n    } else if (this.chainId === ChainIds.GRANADANET) {\n      lambdaAddress = DefaultLambdaAddresses.GRANADANET\n    } else if (this.chainId === ChainIds.MAINNET) {\n      lambdaAddress = DefaultLambdaAddresses.MAINNET\n    } else {\n      throw new UndefinedLambdaContractError()\n    }\n\n    const lambdaContract = await this.provider.at(lambdaAddress);\n    const arg = this.parameterSchema.Encode(...this.args);\n    const lambdaView = new LambdaView(lambdaContract, this.currentContract, this.name, arg);\n    const failedWith = await lambdaView.execute();\n    const response = this.callbackParametersSchema.Execute(failedWith);\n    return response;\n  }\n\n}\n\nconst validateArgs = (args: any[], schema: ParameterSchema, name: string) => {\n  const sigs = schema.ExtractSignatures();\n\n  if (!sigs.find((x: any[]) => x.length === args.length)) {\n    throw new InvalidParameterError(name, sigs, args);\n  }\n};\n\nconst isView = (schema: ParameterSchema): boolean => {\n  let isView = false;\n  const sigs = schema.ExtractSignatures();\n  if ((sigs[0][sigs[0].length - 1] === 'contract')) {\n    isView = true;\n  }\n  return isView;\n};\n\nexport type Contract = ContractAbstraction<ContractProvider>;\nexport type WalletContract = ContractAbstraction<Wallet>;\n\nconst isContractProvider = (variableToCheck: any): variableToCheck is ContractProvider =>\n  variableToCheck.contractProviderTypeSymbol !== undefined;\n\n/**\n * @description Smart contract abstraction\n */\nexport class ContractAbstraction<T extends ContractProvider | Wallet> {\n  /**\n   * @description Contains methods that are implemented by the target Tezos Smart Contract, and offers the user to call the Smart Contract methods as if they were native TS/JS methods.\n   * NB: if the contract contains annotation it will include named properties; if not it will be indexed by a number.\n   *\n   */\n  public methods: { [key: string]: (...args: any[]) => ContractMethod<T> } = {};\n\n  public views: { [key: string]: (...args: any[]) => ContractView } = {};\n\n  public readonly schema: Schema;\n\n  public readonly parameterSchema: ParameterSchema;\n\n  constructor(\n    public readonly address: string,\n    public readonly script: ScriptResponse,\n    provider: T,\n    private storageProvider: StorageProvider,\n    public readonly entrypoints: EntrypointsResponse,\n    private chainId: string\n  ) {\n    this.schema = Schema.fromRPCResponse({ script: this.script });\n    this.parameterSchema = ParameterSchema.fromRPCResponse({ script: this.script });\n    this._initializeMethods(this, address, provider, this.entrypoints.entrypoints, this.chainId);\n  }\n\n  private _initializeMethods(\n    currentContract: ContractAbstraction<T>,\n    address: string,\n    provider: T,\n    entrypoints: {\n      [key: string]: object;\n    },\n    chainId: string\n  ) {\n    const parameterSchema = this.parameterSchema;\n    const keys = Object.keys(entrypoints);\n    if (parameterSchema.isMultipleEntryPoint) {\n      keys.forEach(smartContractMethodName => {\n        const smartContractMethodSchema = new ParameterSchema(\n          entrypoints[smartContractMethodName]\n        );\n        const method = function (...args: any[]) {\n\n          validateArgs(args, smartContractMethodSchema, smartContractMethodName);\n\n          return new ContractMethod<T>(\n            provider,\n            address,\n            smartContractMethodSchema,\n            smartContractMethodName,\n            args\n          );\n        };\n        this.methods[smartContractMethodName] = method;\n\n        if (isContractProvider(provider)) {\n          if (isView(smartContractMethodSchema)) {\n            const view = function (...args: any[]) {\n              const entrypointParamWithoutCallback = (entrypoints[smartContractMethodName] as any).args[0];\n              const smartContractMethodSchemaWithoutCallback = new ParameterSchema(\n                entrypointParamWithoutCallback\n              );\n              const parametersCallback = (entrypoints[smartContractMethodName] as any).args[1].args[0];\n              const smartContractMethodCallbackSchema = new ParameterSchema(\n                parametersCallback\n              );\n\n              validateArgs(args, smartContractMethodSchemaWithoutCallback, smartContractMethodName);\n              return new ContractView(\n                currentContract,\n                provider,\n                smartContractMethodName,\n                chainId,\n                smartContractMethodCallbackSchema,\n                smartContractMethodSchemaWithoutCallback,\n                args\n              );\n            };\n            this.views[smartContractMethodName] = view;\n          }\n        }\n\n      });\n\n      // Deal with methods with no annotations which were not discovered by the RPC endpoint\n      // Methods with no annotations are discovered using parameter schema\n      const anonymousMethods = Object.keys(parameterSchema.ExtractSchema()).filter(\n        key => Object.keys(entrypoints).indexOf(key) === -1\n      );\n\n      anonymousMethods.forEach(smartContractMethodName => {\n        const method = function (...args: any[]) {\n          validateArgs(\n            [smartContractMethodName, ...args],\n            parameterSchema,\n            smartContractMethodName\n          );\n          return new ContractMethod<T>(\n            provider,\n            address,\n            parameterSchema,\n            smartContractMethodName,\n            args,\n            false,\n            true\n          );\n        };\n        this.methods[smartContractMethodName] = method;\n      });\n    } else {\n      const smartContractMethodSchema = this.parameterSchema;\n      const method = function (...args: any[]) {\n        validateArgs(args, parameterSchema, DEFAULT_SMART_CONTRACT_METHOD_NAME);\n        return new ContractMethod<T>(\n          provider,\n          address,\n          smartContractMethodSchema,\n          DEFAULT_SMART_CONTRACT_METHOD_NAME,\n          args,\n          false\n        );\n      };\n      this.methods[DEFAULT_SMART_CONTRACT_METHOD_NAME] = method;\n    }\n  }\n\n  /**\n   * @description Return a friendly representation of the smart contract storage\n   */\n  public storage<T>() {\n    return this.storageProvider.getStorage<T>(this.address, this.schema);\n  }\n\n  /**\n   *\n   * @description Return a friendly representation of the smart contract big map value\n   *\n   * @param key BigMap key to fetch\n   *\n   * @deprecated getBigMapKey has been deprecated in favor of getBigMapKeyByID\n   *\n   * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get\n   */\n  public bigMap(key: string) {\n    // tslint:disable-next-line: deprecation\n    return this.storageProvider.getBigMapKey(this.address, key, this.schema);\n  }\n}\n","import { Schema, BigMapKeyType } from '@taquito/michelson-encoder';\nimport BigNumber from 'bignumber.js';\nimport { ContractProvider } from './interface';\nimport { HttpResponseError, STATUS_CODE } from '@taquito/http-utils';\n\nexport class BigMapAbstraction {\n  constructor(private id: BigNumber, private schema: Schema, private provider: ContractProvider) {}\n\n  /**\n   *\n   * @description Fetch one value in a big map\n   * \n   * @param keysToEncode Key to query (will be encoded properly according to the schema)\n   * @param block optional block level to fetch the values from (head will be use by default)\n   * @returns Return a well formatted json object of a big map value or undefined if the key is not found in the big map\n   *\n   */\n  async get<T>(keyToEncode: BigMapKeyType , block?: number) {\n    try {\n      const id = await this.provider.getBigMapKeyByID<T>(this.id.toString(), keyToEncode, this.schema, block);\n      return id;\n    } catch (e) {\n      if (e instanceof HttpResponseError && e.status === STATUS_CODE.NOT_FOUND) {\n        return undefined;\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   *\n   * @description Fetch multiple values in a big map\n   * All values will be fetched on the same block level. If a block is specified in the request, the values will be fetched at it. \n   * Otherwise, a first request will be done to the node to fetch the level of the head and all values will be fetched at this level.\n   * If one of the keys does not exist in the big map, its value will be set to undefined.\n   *\n   * @param keysToEncode Array of keys to query (will be encoded properly according to the schema)\n   * @param block optional block level to fetch the values from\n   * @param batchSize optional batch size representing the number of requests to execute in parallel\n   * @returns A MichelsonMap containing the keys queried in the big map and their value in a well-formatted JSON object format\n   *\n   */\n  async getMultipleValues<T>(keysToEncode: Array<BigMapKeyType>, block?: number, batchSize: number = 5) {\n    return this.provider.getBigMapKeysByID<T>(this.id.toString(), keysToEncode, this.schema, block, batchSize);\n  }\n\n  toJSON() {\n    return this.id.toString();\n  }\n\n  toString() {\n    return this.id.toString();\n  }\n}\n","import BigNumber from 'bignumber.js';\nimport { ContractProvider } from './interface';\n\nexport class SaplingStateAbstraction {\n    constructor(private id: BigNumber, private provider: ContractProvider) { }\n\n    /**\n     *\n     * @description Fetch the sapling state\n     * \n     * @param block optional block level to fetch the values from (head will be use by default)\n     * @returns Return a json object of the sapling_state\n     *\n     */\n    async getSaplingDiff(block?: number) {\n        return this.provider.getSaplingDiffByID(this.id.toString(), block);\n    }\n\n    getId() {\n        return this.id.toString();\n    }\n}\n","import { Schema, Semantic } from '@taquito/michelson-encoder';\nimport { BigMapAbstraction } from './big-map';\nimport { ContractProvider } from './interface';\nimport BigNumber from 'bignumber.js';\nimport { MichelsonV1Expression } from '@taquito/rpc';\nimport { SaplingStateAbstraction } from './sapling-state-abstraction';\n\n// Override the default michelson encoder semantic to provide richer abstraction over storage properties\nexport const smartContractAbstractionSemantic: (p: ContractProvider) => Semantic = (\n  provider: ContractProvider\n) => ({\n  // Provide a specific abstraction for BigMaps\n  big_map: (val: MichelsonV1Expression, code: MichelsonV1Expression) => {\n    if (!val || !('int' in val) || val.int === undefined) {\n      // Return an empty object in case of missing big map ID\n      return {};\n    } else {\n      const schema = new Schema(code);\n      return new BigMapAbstraction(new BigNumber(val.int), schema, provider);\n    }\n  },\n  sapling_state: (val: MichelsonV1Expression) => {\n    if (!val || !('int' in val) || val.int === undefined) {\n      // Return an empty object in case of missing sapling state ID\n      return {};\n    } else {\n      return new SaplingStateAbstraction(new BigNumber(val.int), provider);\n    }\n  }\n  /*\n  // TODO: embed useful other abstractions\n  'contract':  () => {},\n  'address':  () => {}\n  */\n});\n","import { HttpResponseError, STATUS_CODE } from '@taquito/http-utils';\nimport { BigMapKeyType, MichelsonMap, MichelsonMapKey, Schema } from '@taquito/michelson-encoder';\nimport { OpKind, ScriptResponse } from '@taquito/rpc';\nimport { encodeExpr } from '@taquito/utils';\nimport { OperationBatch } from '../batch/rpc-batch-provider';\nimport { Context } from '../context';\nimport { DelegateOperation } from '../operations/delegate-operation';\nimport { OperationEmitter } from '../operations/operation-emitter';\nimport { OriginationOperation } from '../operations/origination-operation';\nimport { RevealOperation } from '../operations/reveal-operation';\nimport { TransactionOperation } from '../operations/transaction-operation';\nimport {\n  DelegateParams,\n  isOpRequireReveal,\n  OriginateParams,\n  ParamsWithKind,\n  RegisterDelegateParams,\n  RevealParams,\n  RPCOperation,\n  TransferParams,\n  withKind,\n} from '../operations/types';\nimport { ContractAbstraction } from './contract';\nimport { InvalidDelegationSource } from './errors';\nimport { ContractProvider, ContractSchema, EstimationProvider, StorageProvider } from './interface';\nimport {\n  createOriginationOperation,\n  createRegisterDelegateOperation,\n  createRevealOperation,\n  createSetDelegateOperation,\n  createTransferOperation,\n} from './prepare';\nimport { smartContractAbstractionSemantic } from './semantic';\n\nexport class RpcContractProvider\n  extends OperationEmitter\n  implements ContractProvider, StorageProvider\n{\n  constructor(context: Context, private estimator: EstimationProvider) {\n    super(context);\n  }\n  contractProviderTypeSymbol = Symbol.for('taquito--provider-type-symbol');\n\n  /**\n   *\n   * @description Return a well formatted json object of the contract storage\n   *\n   * @param contract contract address you want to get the storage from\n   * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\n   *\n   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\n   */\n  async getStorage<T>(contract: string, schema?: ContractSchema): Promise<T> {\n    if (!schema) {\n      schema = await this.rpc.getScript(contract);\n    }\n\n    let contractSchema: Schema;\n    if (Schema.isSchema(schema)) {\n      contractSchema = schema;\n    } else {\n      contractSchema = Schema.fromRPCResponse({ script: schema as ScriptResponse });\n    }\n\n    const storage = await this.rpc.getStorage(contract);\n\n    return contractSchema.Execute(storage, smartContractAbstractionSemantic(this)) as T; // Cast into T because only the caller can know the true type of the storage\n  }\n\n  /**\n   *\n   * @description Return a well formatted json object of the contract big map storage\n   *\n   * @param contract contract address you want to get the storage from\n   * @param key contract big map key to fetch value from\n   * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\n   *\n   * @deprecated Deprecated in favor of getBigMapKeyByID\n   *\n   * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get\n   */\n  async getBigMapKey<T>(contract: string, key: string, schema?: ContractSchema): Promise<T> {\n    if (!schema) {\n      schema = await this.rpc.getScript(contract);\n    }\n\n    let contractSchema: Schema;\n    if (Schema.isSchema(schema)) {\n      contractSchema = schema;\n    } else {\n      contractSchema = Schema.fromRPCResponse({ script: schema as ScriptResponse });\n    }\n\n    const encodedKey = contractSchema.EncodeBigMapKey(key);\n\n    // tslint:disable-next-line: deprecation\n    const val = await this.rpc.getBigMapKey(contract, encodedKey);\n\n    return contractSchema.ExecuteOnBigMapValue(val) as T; // Cast into T because only the caller can know the true type of the storage\n  }\n\n  /**\n   *\n   * @description Return a well formatted json object of a big map value\n   *\n   * @param id Big Map ID\n   * @param keyToEncode key to query (will be encoded properly according to the schema)\n   * @param schema Big Map schema (can be determined using your contract type)\n   * @param block optional block level to fetch the values from\n   *\n   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr\n   */\n  async getBigMapKeyByID<T>(id: string, keyToEncode: BigMapKeyType, schema: Schema, block?: number): Promise<T> {\n    const { key, type } = schema.EncodeBigMapKey(keyToEncode);\n    const { packed } = await this.context.packer.packData({ data: key, type });\n\n    const encodedExpr = encodeExpr(packed);\n\n    const bigMapValue = block? await this.context.rpc.getBigMapExpr(id.toString(), encodedExpr, { block: String(block) }) : await this.context.rpc.getBigMapExpr(id.toString(), encodedExpr);\n\n    return schema.ExecuteOnBigMapValue(bigMapValue, smartContractAbstractionSemantic(this)) as T;\n  }\n\n  /**\n   *\n   * @description Fetch multiple values in a big map\n   * All values will be fetched on the same block level. If a block is specified in the request, the values will be fetched at it.\n   * Otherwise, a first request will be done to the node to fetch the level of the head and all values will be fetched at this level.\n   * If one of the keys does not exist in the big map, its value will be set to undefined.\n   *\n   * @param id Big Map ID\n   * @param keys Array of keys to query (will be encoded properly according to the schema)\n   * @param schema Big Map schema (can be determined using your contract type)\n   * @param block optional block level to fetch the values from\n   * @param batchSize optional batch size representing the number of requests to execute in parallel\n   * @returns A MichelsonMap containing the keys queried in the big map and their value in a well-formatted JSON object format\n   *\n   */\n  async getBigMapKeysByID<T>(id: string, keys: Array<BigMapKeyType>, schema: Schema, block?: number, batchSize: number = 5): Promise<MichelsonMap<MichelsonMapKey, T | undefined>> {\n    const level = await this.getBlockForRequest(keys, block)\n    const bigMapValues = new MichelsonMap<MichelsonMapKey, T | undefined>();\n\n    // Execute batch of promises in series\n    let position = 0;\n    let results: Array<(T | undefined)> = [];\n\n    while (position < keys.length) {\n      const keysBatch = keys.slice(position, position + batchSize);\n      const batch = keysBatch.map((keyToEncode) => this.getBigMapValueOrUndefined<T>(keyToEncode, id, schema, level))\n      results = [...results, ...await Promise.all(batch)]\n      position += batchSize;\n    }\n\n    for (let i = 0; i < results.length; i++) {\n      bigMapValues.set(keys[i], results[i]);\n    }\n\n    return bigMapValues;\n  }\n\n  private async getBlockForRequest(keys: Array<BigMapKeyType>, block?: number) {\n    return keys.length === 1 || typeof block !== 'undefined' ? block : (await this.rpc.getBlock())?.header.level\n  }\n\n  private async getBigMapValueOrUndefined<T>(keyToEncode: BigMapKeyType, id: string, schema: Schema, level?: number) {\n    try {\n      return await this.getBigMapKeyByID<T>(id, keyToEncode, schema, level);\n    } catch (ex) {\n      if (ex instanceof HttpResponseError && ex.status === STATUS_CODE.NOT_FOUND) {\n        return\n      } else {\n        throw ex;\n      }\n    }\n  }\n\n  /**\n   *\n   * @description Return a well formatted json object of a sapling state\n   *\n   * @param id Sapling state ID\n   * @param block optional block level to fetch the value from\n   *\n   */\n  async getSaplingDiffByID(id: string, block?: number) {\n    const saplingState = block ? await this.context.rpc.getSaplingDiffById(id.toString(), { block: String(block) }) : await this.context.rpc.getSaplingDiffById(id.toString());\n    return saplingState;\n  }\n\n  private async addRevealOperationIfNeeded(operation: RPCOperation, publicKeyHash: string){\n    if(isOpRequireReveal(operation)){\n      const ops: RPCOperation[] = [operation];\n      const publicKey = await this.signer.publicKey();\n      const estimateReveal = await this.estimator.reveal();\n      if(estimateReveal){\n        const reveal: withKind<RevealParams, OpKind.REVEAL> = { kind: OpKind.REVEAL };\n        const estimatedReveal = await this.estimate(reveal, async () => estimateReveal);\n        ops.unshift(await createRevealOperation({ ...estimatedReveal }, publicKeyHash, publicKey));\n        return ops;\n      }\n    }\n    return operation;\n  }\n\n  /**\n   *\n   * @description Originate a new contract according to the script in parameters. Will sign and inject an operation using the current context\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   * @warn You cannot specify storage and init at the same time (use init to pass the raw michelson representation of storage)\n   *\n   * @param OriginationOperation Originate operation parameter\n   */\n  async originate(params: OriginateParams) {\n    const estimate = await this.estimate(params, this.estimator.originate.bind(this.estimator));\n\n    const publicKeyHash = await this.signer.publicKeyHash();\n    const operation = await createOriginationOperation(\n      await this.context.parser.prepareCodeOrigination({\n        ...params,\n      ...estimate,\n    }));\n    const ops = await this.addRevealOperationIfNeeded(operation, publicKeyHash);\n    const preparedOrigination = await this.prepareOpAndSimulation({\n      operation: ops,\n      source: publicKeyHash\n    });\n    const forgedOrigination = await this.forge(preparedOrigination.preparedOp);\n    const signedOperation = await this.signOperation(forgedOrigination);\n    const opResponse = await this.preValidate(preparedOrigination, signedOperation);\n    const hash = await this.injectOperation(signedOperation.opbytes);\n    return new OriginationOperation(\n      hash,\n      operation,\n      signedOperation,\n      opResponse,\n      this.context.clone(),\n      this\n    );\n  }\n\n  /**\n   *\n   * @description Set the delegate for a contract. Will sign and inject an operation using the current context\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   * @param SetDelegate operation parameter\n   */\n  async setDelegate(params: DelegateParams) {\n    // Since babylon delegation source cannot smart contract\n    if (/kt1/i.test(params.source)) {\n      throw new InvalidDelegationSource(params.source);\n    }\n\n    const estimate = await this.estimate(params, this.estimator.setDelegate.bind(this.estimator));\n    const publicKeyHash = await this.signer.publicKeyHash();\n    const operation = await createSetDelegateOperation({ ...params, ...estimate });\n    const sourceOrDefault = params.source || publicKeyHash;\n    const ops = await this.addRevealOperationIfNeeded(operation, publicKeyHash);\n    const prepared = await this.prepareOpAndSimulation({\n      operation: ops,\n      source: sourceOrDefault\n    });\n    const opBytes = await this.forge(prepared.preparedOp);\n    const signedOperation = await this.signOperation(opBytes);\n    const opResponse = await this.preValidate(prepared, signedOperation);\n    const hash = await this.injectOperation(signedOperation.opbytes);\n    return new DelegateOperation(\n      hash,\n      operation,\n      sourceOrDefault,\n      signedOperation,\n      opResponse,\n      this.context.clone()\n    );\n  }\n\n  /**\n   *\n   * @description Register the current address as delegate. Will sign and inject an operation using the current context\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   * @param RegisterDelegate operation parameter\n   */\n  async registerDelegate(params: RegisterDelegateParams) {\n    const estimate = await this.estimate(\n      params,\n      this.estimator.registerDelegate.bind(this.estimator)\n    );\n    const source = await this.signer.publicKeyHash();\n    const operation = await createRegisterDelegateOperation({ ...params, ...estimate }, source);\n    const ops = await this.addRevealOperationIfNeeded(operation, source);\n    const prepared = await this.prepareOpAndSimulation({ operation: ops, source });\n    const opBytes = await this.forge(prepared.preparedOp);\n    const signedOperation = await this.signOperation(opBytes);\n    const opResponse = await this.preValidate(prepared, signedOperation);\n    const hash = await this.injectOperation(signedOperation.opbytes);\n    return new DelegateOperation(\n      hash,\n      operation,\n      source,\n      signedOperation,\n      opResponse,\n      this.context.clone()\n    );\n  }\n\n  /**\n   *\n   * @description Transfer tz from current address to a specific address. Will sign and inject an operation using the current context\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   * @param Transfer operation parameter\n   */\n  async transfer(params: TransferParams) {\n    const publicKeyHash = await this.signer.publicKeyHash();\n    const estimate = await this.estimate(params, this.estimator.transfer.bind(this.estimator));\n    const operation = await createTransferOperation({\n      ...params,\n      ...estimate,\n    });\n    const source = params.source || publicKeyHash;\n    const ops = await this.addRevealOperationIfNeeded(operation, publicKeyHash);\n    const prepared = await this.prepareOpAndSimulation({\n      operation: ops,\n      source\n    });\n    const forgedOperation = await this.forge(prepared.preparedOp);\n    const signedOperation = await this.signOperation(forgedOperation);\n    const opResponse = await this.preValidate(prepared, signedOperation);\n    const hash = await this.injectOperation(signedOperation.opbytes);\n    return new TransactionOperation(\n      hash,\n      operation,\n      source,\n      signedOperation,\n      opResponse,\n      this.context.clone()\n    );\n  }\n\n  /**\n   *\n   * @description Reveal the current address. Will throw an error if the address is already revealed.\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   * @param RevealParams operation parameter\n   */\n  async reveal(params: RevealParams) {\n    const publicKeyHash = await this.signer.publicKeyHash();\n    const estimateReveal = await this.estimator.reveal(params);\n    if (estimateReveal) {\n      const estimated = await this.estimate(params, async () => estimateReveal);\n      const operation = await createRevealOperation(\n        {\n          ...estimated,\n        },\n        publicKeyHash,\n        await this.signer.publicKey()\n      );\n      const prepared = await this.prepareOpAndSimulation({ operation, source: publicKeyHash });\n      const opBytes = await this.forge(prepared.preparedOp);\n      const signedOperation = await this.signOperation(opBytes);\n      const opResponse = await this.preValidate(prepared, signedOperation);\n      const hash = await this.injectOperation(signedOperation.opbytes);\n      return new RevealOperation(\n        hash,\n        operation,\n        publicKeyHash,\n        signedOperation,\n        opResponse,\n        this.context.clone()\n      );\n    } else {\n      throw new Error('The current address is already revealed.');\n    }\n  }\n\n  async at<T extends ContractAbstraction<ContractProvider>>(\n    address: string,\n    contractAbstractionComposer: ContractAbstractionComposer<T> = (x) => x as any\n  ): Promise<T> {\n    const script = await this.rpc.getScript(address);\n    const entrypoints = await this.rpc.getEntrypoints(address);\n    const blockHeader = await this.rpc.getBlockHeader();\n    const chainId = blockHeader.chain_id;\n    const abs = new ContractAbstraction(address, script, this, this, entrypoints, chainId);\n    return contractAbstractionComposer(abs, this.context);\n  }\n\n  /**\n   *\n   * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch\n   *\n   * @returns A batch object from which we can add more operation or send a command to execute the batch\n   *\n   * @param params List of operation to batch together\n   */\n  batch(params?: ParamsWithKind[]) {\n    const batch = new OperationBatch(this.context, this.estimator);\n\n    if (Array.isArray(params)) {\n      batch.with(params);\n    }\n\n    return batch;\n  }\n}\n\ntype ContractAbstractionComposer<T> = (\n  abs: ContractAbstraction<ContractProvider>,\n  context: Context\n) => T;\n","import { Context } from '../context';\nimport { ParserProvider } from './interface';\nimport { Expr, Parser, Prim } from '@taquito/michel-codec';\nimport { Protocols } from '../constants';\nimport { OriginateParams } from '../operations/types';\nimport { InvalidInitParameter, InvalidCodeParameter } from '../contract/errors';\n\nexport class MichelCodecParser implements ParserProvider {\n    constructor(private context: Context) { }\n\n    private async getNextProto() {\n        const { next_protocol } = await this.context.rpc.getBlockMetadata();\n        return next_protocol as Protocols;\n    }\n\n    async parseScript(src: string): Promise<Expr[] | null> {\n        const parser = new Parser({ protocol: await this.getNextProto() });\n        return parser.parseScript(src);\n    }\n\n    async parseMichelineExpression(src: string): Promise<Expr | null> {\n        const parser = new Parser({ protocol: await this.getNextProto() });\n        return parser.parseMichelineExpression(src);\n    }\n\n    async parseJSON(src: object): Promise<Expr> {\n        const parser = new Parser({ protocol: await this.getNextProto() });\n        return parser.parseJSON(src);\n    }\n\n    async prepareCodeOrigination(params: OriginateParams): Promise<OriginateParams> {\n        const parsedParams = params;\n        parsedParams.code = await this.formatCodeParam(params.code);\n        if (params.init) {\n            parsedParams.init = await this.formatInitParam(params.init);\n        }\n        return parsedParams;\n    }\n\n    private async formatCodeParam(code: string | object[]) {\n        let parsedCode: Expr[];\n        if (typeof code === 'string') {\n            const c = await this.parseScript(code);\n            if (c === null) {\n                throw new InvalidCodeParameter('Invalid code parameter', code);\n            }\n            parsedCode = c;\n        } else {\n            const c = await this.parseJSON(code);\n            const order = ['parameter', 'storage', 'code'];\n            // Ensure correct ordering for RPC\n            parsedCode = (c as Prim[]).sort((a, b) => order.indexOf(a.prim) - order.indexOf(b.prim));\n        }\n        return parsedCode;\n    }\n\n    private async formatInitParam(init: string | object) {\n        let parsedInit: Expr;\n        if (typeof init === 'string') {\n            const c = await this.parseMichelineExpression(init);\n            if (c === null) {\n                throw new InvalidInitParameter('Invalid init parameter', init);\n            }\n            parsedInit = c;\n        } else {\n            parsedInit = await this.parseJSON(init);\n        }\n        return parsedInit;\n    }\n}\n","import { Packer } from './interface';\nimport { Context } from '../context';\nimport { PackDataParams, PackDataResponse } from '@taquito/rpc';\n\nexport class RpcPacker implements Packer {\n  constructor(private context: Context) {}\n  \n  async packData(data: PackDataParams): Promise<PackDataResponse> {\n    return this.context.rpc.packData(data);\n  }\n}\n","import { RpcClient } from '@taquito/rpc';\nimport { Protocols } from './constants';\nimport { Forger } from './forger/interface';\nimport { RpcForger } from './forger/rpc-forger';\nimport { Injector } from './injector/interface';\nimport { RpcInjector } from './injector/rpc-injector';\nimport { Signer } from './signer/interface';\nimport { NoopSigner } from './signer/noop';\nimport { OperationFactory } from './wallet/operation-factory';\nimport { RpcTzProvider } from './tz/rpc-tz-provider';\nimport { RPCEstimateProvider } from './contract/rpc-estimate-provider';\nimport { RpcContractProvider } from './contract/rpc-contract-provider';\nimport { RPCBatchProvider } from './batch/rpc-batch-provider';\n\nimport { Wallet, LegacyWalletProvider, WalletProvider } from './wallet';\nimport { ParserProvider } from './parser/interface';\nimport { MichelCodecParser } from './parser/michel-codec-parser';\nimport { Packer } from './packer/interface';\nimport { RpcPacker } from './packer/rpc-packer';\nimport BigNumber from 'bignumber.js';\nimport { retry } from 'rxjs/operators';\nimport { OperatorFunction } from 'rxjs';\n\nexport interface TaquitoProvider<T, K extends Array<any>> {\n  new (context: Context, ...rest: K): T;\n}\n\n// The shouldObservableSubscriptionRetry parameter is related to the observable in ObservableSubsription class.\n// When set to true, the observable won't die when getBlock rpc call fails; the error will be reported via the error callback,\n// and it will continue to poll for new blocks.\nexport interface Config {\n  confirmationPollingIntervalSecond?: number;\n  confirmationPollingTimeoutSecond?: number;\n  defaultConfirmationCount?: number;\n  shouldObservableSubscriptionRetry?: boolean;\n  observableSubscriptionRetryFunction?: OperatorFunction<any, any>;\n}\n\nexport const defaultConfig: Partial<Config> = {\n  defaultConfirmationCount: 1,\n  confirmationPollingTimeoutSecond: 180,\n  shouldObservableSubscriptionRetry: false,\n  observableSubscriptionRetryFunction: retry(),\n};\n\n/**\n * @description Encapsulate common service used throughout different part of the library\n */\nexport class Context {\n  private _counters: { [key: string]: number } = {};\n  private _rpcClient: RpcClient;\n  private _forger: Forger;\n  private _parser: ParserProvider;\n  private _injector: Injector;\n  private _walletProvider: WalletProvider;\n  public readonly operationFactory: OperationFactory;\n  private _packer: Packer;\n\n  public readonly tz = new RpcTzProvider(this);\n  public readonly estimate = new RPCEstimateProvider(this);\n  public readonly contract = new RpcContractProvider(this, this.estimate);\n  public readonly batch = new RPCBatchProvider(this, this.estimate);\n  public readonly wallet = new Wallet(this);\n\n  constructor(\n    private _rpc: RpcClient | string,\n    private _signer: Signer = new NoopSigner(),\n    private _proto?: Protocols,\n    private _config?: Partial<Config>,\n    forger?: Forger,\n    injector?: Injector,\n    packer?: Packer,\n    wallet?: WalletProvider,\n    parser?: ParserProvider\n  ) {\n    if (typeof this._rpc === 'string') {\n      this._rpcClient = new RpcClient(this._rpc);\n    } else {\n      this._rpcClient = this._rpc;\n    }\n    this.config = _config as any;\n    this._forger = forger ? forger : new RpcForger(this);\n    this._injector = injector ? injector : new RpcInjector(this);\n    this.operationFactory = new OperationFactory(this);\n    this._walletProvider = wallet ? wallet : new LegacyWalletProvider(this);\n    this._parser = parser ? parser : new MichelCodecParser(this);\n    this._packer = packer ? packer : new RpcPacker(this);\n  }\n\n  get config(): Partial<Config> {\n    return this._config as any;\n  }\n\n  set config(value: Partial<Config>) {\n    this._config = {\n      ...defaultConfig,\n      ...value,\n    };\n  }\n\n  get rpc(): RpcClient {\n    return this._rpcClient;\n  }\n\n  set rpc(value: RpcClient) {\n    this._rpcClient = value;\n  }\n\n  get injector() {\n    return this._injector;\n  }\n\n  set injector(value: Injector) {\n    this._injector = value;\n  }\n\n  get forger() {\n    return this._forger;\n  }\n\n  set forger(value: Forger) {\n    this._forger = value;\n  }\n\n  get signer() {\n    return this._signer;\n  }\n\n  get walletProvider() {\n    return this._walletProvider;\n  }\n\n  set walletProvider(value: WalletProvider) {\n    this._walletProvider = value;\n  }\n\n  set signer(value: Signer) {\n    this._signer = value;\n  }\n\n  set proto(value: Protocols | undefined) {\n    this._proto = value;\n  }\n\n  get proto() {\n    return this._proto;\n  }\n\n  get parser() {\n    return this._parser;\n  }\n\n  set parser(value: ParserProvider) {\n    this._parser = value;\n  }\n\n  get packer() {\n    return this._packer;\n  }\n\n  set packer(value: Packer) {\n    this._packer = value;\n  }\n\n  get counters() {\n    return this._counters;\n  }\n\n  set counters(value: { [key: string]: number }) {\n    this._counters[value.key] = value.counter;\n  }\n\n  async isAnyProtocolActive(protocol: string[] = []) {\n    if (this._proto) {\n      return protocol.includes(this._proto);\n    } else {\n      const { next_protocol } = await this.rpc.getBlockMetadata();\n      return protocol.includes(next_protocol);\n    }\n  }\n\n  async getConfirmationPollingInterval() {\n    try {\n      const constants = await this.rpc.getConstants();\n      let blockTime = constants.time_between_blocks[0];\n      if (constants.minimal_block_delay !== undefined) {\n        blockTime = constants.minimal_block_delay;\n      }\n      let confirmationPollingInterval = BigNumber.sum(blockTime, \n        new BigNumber(constants.delay_per_missing_endorsement!)\n        .multipliedBy(Math.max(0, constants.initial_endorsers! - constants.endorsers_per_block))\n      );\n\n      // Divide the polling interval by a constant 3\n      // to improvise for polling time to work in prod,\n      // testnet and sandbox enviornment.   \n      confirmationPollingInterval = confirmationPollingInterval.dividedBy(3);  \n      this.config.confirmationPollingIntervalSecond = confirmationPollingInterval.toNumber() === 0 ?\n                                                      0.1 :\n                                                      confirmationPollingInterval.toNumber();\n      return this.config.confirmationPollingIntervalSecond;\n    } catch (exception) {\n      // Return default value if there is\n      // an issue returning from constants\n      // file.\n      return 10;\n    }\n  }\n\n  /**\n   * @description Create a copy of the current context. Useful when you have long running operation and you do not want a context change to affect the operation\n   */\n  clone(): Context {\n    return new Context(\n      this.rpc,\n      this.signer,\n      this.proto,\n      this.config,\n      this.forger,\n      this._injector,\n      this.packer\n    );\n  }\n}\n","import { OpFilter, FilterExpression, Filter, OpHashFilter, SourceFilter, KindFilter, DestinationFilter, OperationContent } from './interface';\n\nconst opHashFilter = (op: OperationContent, filter: OpHashFilter) => op.hash === filter.opHash;\n\nconst sourceFilter = (x: OperationContent, filter: SourceFilter) => {\n  switch (x.kind) {\n    case 'endorsement':\n      return 'metadata' in x && x.metadata.delegate === filter.source\n    case 'activate_account':\n      return 'metadata' in x && x.pkh === filter.source\n    default:\n      return 'source' in x && x.source === filter.source\n  }\n}\n\nconst kindFilter = (x: OperationContent, filter: KindFilter) => 'kind' in x && x.kind === filter.kind;\n\nconst destinationFilter = (x: OperationContent, filter: DestinationFilter) => {\n  switch (x.kind) {\n    case 'delegation':\n      return x.delegate === filter.destination;\n    case 'origination':\n      if (\n        'metadata' in x &&\n        'operation_result' in x.metadata &&\n        'originated_contracts' in x.metadata.operation_result &&\n        Array.isArray(x.metadata.operation_result.originated_contracts)\n      ) {\n        return x.metadata.operation_result.originated_contracts.some(\n          contract => contract === filter.destination\n        );\n      }\n      break;\n    case 'transaction':\n      return x.destination === filter.destination;\n    default:\n      return false;\n  }\n};\n\nexport const evaluateOpFilter = (op: OperationContent, filter: OpFilter) => {\n  if ('opHash' in filter) {\n    return opHashFilter(op, filter);\n  } else if ('source' in filter) {\n    return sourceFilter(op, filter)\n  } else if ('kind' in filter) {\n    return kindFilter(op, filter);\n  } else if ('destination' in filter) {\n    return destinationFilter(op, filter)\n  }\n\n  return false;\n};\n\nexport const evaluateExpression = (op: OperationContent, exp: FilterExpression): boolean => {\n  if (Array.isArray(exp.and)) {\n    return exp.and.every((x: OpFilter | FilterExpression) => evaluateFilter(op, x));\n  } else if (Array.isArray(exp.or)) {\n    return exp.or.some((x: OpFilter | FilterExpression) => evaluateFilter(op, x));\n  } else {\n    throw new Error('Filter expression must contains either and/or property');\n  }\n};\n\nexport const evaluateFilter = (op: OperationContent, filter: Filter): boolean => {\n  const filters: OpFilter[] | FilterExpression[] = [];\n  if (!Array.isArray(filter)) {\n    filters.push(filter as any);\n  } else {\n    filters.push(...(filter as any));\n  }\n\n  return (filters as any[]).every((filterOrExp: OpFilter | FilterExpression) => {\n    if ('and' in filterOrExp || 'or' in filterOrExp) {\n      return evaluateExpression(op, filterOrExp);\n    } else {\n      return evaluateOpFilter(op, filterOrExp as OpFilter);\n    }\n  });\n};\n","import { Observable, Subscription as RXJSSubscription, Subject, NEVER, OperatorFunction } from 'rxjs';\nimport { Subscription } from './interface';\nimport { takeUntil, tap, catchError, retry } from 'rxjs/operators';\n\nexport class ObservableSubscription<T> implements Subscription<T> {\n  private errorListeners: Array<(error: Error) => void> = [];\n  private messageListeners: Array<(data: T) => void> = [];\n  private closeListeners: Array<() => void> = [];\n  private completed$ = new Subject();\n\n  constructor(obs: Observable<T>, \n              private shouldRetry: boolean = false, \n              private operatorFunction: OperatorFunction<T,T> = retry<T>()) {\n    \n    obs\n      .pipe(\n        takeUntil(this.completed$),\n        tap(\n          (data: T) => {\n            this.call(this.messageListeners, data);\n          },\n          (error) => {\n            this.call(this.errorListeners, error);\n          },\n          () => {\n            this.call(this.closeListeners);\n          }\n        ),\n        this.shouldRetry ? operatorFunction : tap(),\n        catchError(() => NEVER)\n      )\n      .subscribe();\n  }\n\n  private call<K>(listeners: Array<(val: K) => void>, value?: K) {\n    for (const l of listeners) {\n      try {\n        l(value!);\n      } catch (ex) {\n        console.error(ex);\n      }\n    }\n  }\n\n  private remove(listeners: Array<any>, value: any) {\n    const idx = listeners.indexOf(value);\n    if (idx !== -1) {\n      listeners.splice(idx, 1);\n    }\n  }\n\n  public on(type: 'error', cb: (error: Error) => void): void;\n  // tslint:disable-next-line: unified-signatures\n  public on(type: 'data', cb: (data: T) => void): void;\n  public on(type: 'close', cb: () => void): void;\n\n  public on(type: 'data' | 'error' | 'close', cb: any): void {\n    switch (type) {\n      case 'data':\n        this.messageListeners.push(cb);\n        break;\n      case 'error':\n        this.errorListeners.push(cb);\n        break;\n      case 'close':\n        this.closeListeners.push(cb);\n        break;\n      default:\n        throw new Error(`Trying to register on an unsupported event: ${type}`);\n    }\n  }\n\n  public off(type: 'error', cb: (error: Error) => void): void;\n  // tslint:disable-next-line: unified-signatures\n  public off(type: 'data', cb: (data: T) => void): void;\n  public off(type: 'close', cb: () => void): void;\n\n  public off(type: 'data' | 'error' | 'close', cb: any): void {\n    switch (type) {\n      case 'data':\n        this.remove(this.messageListeners, cb);\n        break;\n      case 'error':\n        this.remove(this.errorListeners, cb);\n        break;\n      case 'close':\n        this.remove(this.closeListeners, cb);\n        break;\n      default:\n        throw new Error(`Trying to unregister on an unsupported event: ${type}`);\n    }\n  }\n\n  public close() {\n    this.completed$.next();\n  }\n}\n","import { BlockResponse } from '@taquito/rpc';\nimport { from, Observable, ObservableInput, timer } from 'rxjs';\nimport {\n  concatMap,\n  distinctUntilKeyChanged,\n  first,\n  map,\n  pluck,\n  publishReplay,\n  refCount,\n  switchMap,\n} from 'rxjs/operators';\nimport { Context } from '../context';\nimport { evaluateFilter } from './filters';\nimport { Filter, SubscribeProvider, Subscription, OperationContent } from './interface';\nimport { ObservableSubscription } from './observable-subscription';\n\nconst getLastBlock = (context: Context) => {\n  return from(context.rpc.getBlock()).pipe(first());\n};\n\nconst applyFilter = (filter: Filter) =>\n  concatMap<BlockResponse, ObservableInput<OperationContent>>(block => {\n    return new Observable<OperationContent>(sub => {\n      for (const ops of block.operations) {\n        for (const op of ops) {\n          for (const content of op.contents) {\n            if (evaluateFilter({hash: op.hash, ...content}, filter)) {\n              sub.next({hash: op.hash, ...content});\n            }\n          }\n        }\n      }\n      sub.complete();\n    });\n  });\n\nexport class PollingSubscribeProvider implements SubscribeProvider {\n  private newBlock$ = timer(0, this.POLL_INTERVAL).pipe(\n    map(() => this.context),\n    switchMap(getLastBlock),\n    distinctUntilKeyChanged('hash'),\n    publishReplay(),\n    refCount()\n  );\n\n  constructor(private context: Context, public readonly POLL_INTERVAL = 20000) {}\n\n  subscribe(_filter: 'head'): Subscription<string> {\n    return new ObservableSubscription(this.newBlock$.pipe(pluck('hash')), \n                                      this.context.config.shouldObservableSubscriptionRetry,\n                                      this.context.config.observableSubscriptionRetryFunction);\n  }\n\n  subscribeOperation(filter: Filter): Subscription<OperationContent> {\n    return new ObservableSubscription(this.newBlock$.pipe(applyFilter(filter)),\n                                      this.context.config.shouldObservableSubscriptionRetry,\n                                      this.context.config.observableSubscriptionRetryFunction);\n  }\n}\n","\n// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\n/* tslint:disable */\nexport const VERSION = {\n    \"commitHash\": \"a8e9548e650215186f661033b59299ace72c9ee6\",\n    \"version\": \"9.2.0\"\n};\n/* tslint:enable */\n","import { Forger, ForgeParams, ForgeResponse } from './interface';\n\nexport class ForgingMismatchError implements Error {\n  name: string = 'ForgingMismatchError';\n  message: string = 'Forging mismatch error';\n  constructor(public results: string[]) {}\n}\n\nexport class CompositeForger implements Forger {\n  constructor(private forgers: Forger[]) {\n    if (forgers.length === 0) {\n      throw new Error('At least one forger must be specified');\n    }\n  }\n\n  async forge({ branch, contents }: ForgeParams): Promise<ForgeResponse> {\n    const results = await Promise.all(\n      this.forgers.map(forger => {\n        return forger.forge({ branch, contents });\n      })\n    );\n\n    if (results.length === 0) {\n      throw new Error('At least one forger must be specified');\n    }\n\n    let lastResult: string = results.pop()!; // Assumed to be more than one since we\n    while (results.length) {\n      const currentResult = results.pop()!;\n\n      if (currentResult !== lastResult) {\n        throw new ForgingMismatchError([lastResult, currentResult]);\n      }\n      lastResult = currentResult;\n    }\n\n    return lastResult;\n  }\n}\n","import { OriginateParams } from \"../operations/types\";\nimport { ParserProvider } from \"./interface\";\n\nexport class NoopParser implements ParserProvider {\n    async prepareCodeOrigination(params: OriginateParams): Promise<OriginateParams> {\n        return params;\n    }\n}","import { Packer } from './interface';\nimport { packDataBytes, MichelsonData, MichelsonType } from '@taquito/michel-codec'\nimport { PackDataResponse, PackDataParams } from '@taquito/rpc';\n\nexport class MichelCodecPacker implements Packer {\n\n  async packData(data: PackDataParams): Promise<PackDataResponse> {\n    const { bytes } = packDataBytes(data.data as MichelsonData, data.type as MichelsonType);\n    return { packed: bytes }\n  }\n}\n","/**\n * @packageDocumentation\n * @module @taquito/taquito\n */\n\nimport { RpcClient } from '@taquito/rpc';\nimport { RPCBatchProvider } from './batch/rpc-batch-provider';\nimport { Protocols } from './constants';\nimport { Config, Context, TaquitoProvider } from './context';\nimport { ContractProvider, EstimationProvider } from './contract/interface';\nimport { Extension } from './extension/extension';\nimport { Forger } from './forger/interface';\nimport { RpcForger } from './forger/rpc-forger';\nimport { format } from './format';\nimport { Packer } from './packer/interface';\nimport { RpcPacker } from './packer/rpc-packer';\nimport { Signer } from './signer/interface';\nimport { NoopSigner } from './signer/noop';\nimport { SubscribeProvider } from './subscribe/interface';\nimport { PollingSubscribeProvider } from './subscribe/polling-provider';\nimport { TzProvider } from './tz/interface';\nimport { VERSION } from './version';\nimport { LegacyWalletProvider, Wallet, WalletProvider } from './wallet';\nimport { OperationFactory } from './wallet/operation-factory';\n\nexport { MichelsonMap, UnitValue } from '@taquito/michelson-encoder';\nexport * from './constants';\nexport * from './context';\nexport { TaquitoProvider } from './context';\nexport * from './contract';\nexport * from './contract/big-map';\nexport { CompositeForger } from './forger/composite-forger';\nexport * from './forger/interface';\nexport { RpcForger } from './forger/rpc-forger';\nexport * from './operations';\nexport { OperationBatch } from './batch/rpc-batch-provider';\nexport * from './signer/interface';\nexport * from './subscribe/interface';\nexport { SubscribeProvider } from './subscribe/interface';\nexport { PollingSubscribeProvider } from './subscribe/polling-provider';\nexport * from './tz/interface';\nexport * from './wallet';\nexport { Extension } from './extension/extension';\nexport * from './parser/interface';\nexport * from './parser/michel-codec-parser';\nexport * from './parser/noop-parser';\nexport * from './packer/interface';\nexport * from './packer/michel-codec-packer';\nexport * from './packer/rpc-packer';\n\nexport interface SetProviderOptions {\n  forger?: Forger;\n  wallet?: WalletProvider;\n  rpc?: string | RpcClient;\n  stream?: string | SubscribeProvider;\n  signer?: Signer;\n  protocol?: Protocols;\n  config?: Config;\n  packer?: Packer;\n}\n\nexport interface VersionInfo {\n  commitHash: string;\n  version: string;\n}\n\n/**\n * @description Facade class that surfaces all of the libraries capability and allow it's configuration\n *\n * @param _rpc The RPC server to use\n */\nexport class TezosToolkit {\n  private _stream!: SubscribeProvider;\n  private _options: SetProviderOptions = {};\n  private _rpcClient: RpcClient;\n  private _wallet: Wallet;\n  private _context: Context;\n  /**\n   * @deprecated TezosToolkit.batch has been deprecated in favor of TezosToolkit.contract.batch\n   *\n   */\n  public batch: RPCBatchProvider['batch'];\n\n  public readonly format = format;\n\n  constructor(private _rpc: RpcClient | string) {\n    if (typeof this._rpc === 'string') {\n      this._rpcClient = new RpcClient(this._rpc);\n    } else {\n      this._rpcClient = this._rpc;\n    }\n    this._context = new Context(_rpc);\n    this._wallet = new Wallet(this._context);\n    this.setProvider({ rpc: this._rpcClient });\n    // tslint:disable-next-line: deprecation\n    this.batch = this._context.batch.batch.bind(this._context.batch);\n  }\n\n  /**\n   * @description Sets configuration on the Tezos Taquito instance. Allows user to choose which signer, rpc client, rpc url, forger and so forth\n   *\n   * @param options rpc url or rpcClient to use to interact with the Tezos network\n   *\n   * @example Tezos.setProvider({rpc: 'https://api.tez.ie/rpc/mainnet', signer: new InMemorySigner.fromSecretKey(“edsk...”)})\n   * @example Tezos.setProvider({ config: { confirmationPollingTimeoutSecond: 300 }})\n   *\n   */\n\n  setProvider({\n    rpc,\n    stream,\n    signer,\n    protocol,\n    config,\n    forger,\n    wallet,\n    packer,\n  }: SetProviderOptions) {\n    this.setRpcProvider(rpc);\n    this.setStreamProvider(stream);\n    this.setSignerProvider(signer);\n    this.setForgerProvider(forger);\n    this.setWalletProvider(wallet);\n    this.setPackerProvider(packer);\n\n    this._context.proto = protocol;\n    this._context.config = config as Partial<Config>;\n  }\n\n  /**\n   * @description Sets signer provider on the Tezos Taquito instance.\n   *\n   * @param options signer to use to interact with the Tezos network\n   *\n   * @example Tezos.setSignerProvider(new InMemorySigner.fromSecretKey('edsk...'))\n   *\n   */\n  setSignerProvider(signer?: SetProviderOptions['signer']) {\n    if (!this._options.signer && typeof signer === 'undefined') {\n      this._context.signer = new NoopSigner();\n      this._options.signer = signer;\n    } else if (typeof signer !== 'undefined') {\n      this._context.signer = signer;\n      this._options.signer = signer;\n    }\n  }\n\n  /**\n   * @description Sets rpc provider on the Tezos Taquito instance\n   *\n   * @param options rpc url or rpcClient to use to interact with the Tezos network\n   *\n   * @example Tezos.setRpcProvider('https://api.tez.ie/rpc/mainnet')\n   *\n   */\n  setRpcProvider(rpc?: SetProviderOptions['rpc']) {\n    if (typeof rpc === 'string') {\n      this._rpcClient = new RpcClient(rpc);\n    } else if (rpc instanceof RpcClient) {\n      this._rpcClient = rpc;\n    }\n    /*     else if (this._options.rpc === undefined) {\n      this._rpcClient = new RpcClient();\n    } */\n    this._options.rpc = this._rpcClient;\n    this._context.rpc = this._rpcClient;\n  }\n\n  /**\n   * @description Sets forger provider on the Tezos Taquito instance\n   *\n   * @param options forger to use to interact with the Tezos network\n   *\n   * @example Tezos.setForgerProvider(localForger)\n   *\n   */\n  setForgerProvider(forger?: SetProviderOptions['forger']) {\n    const f = typeof forger === 'undefined' ? this.getFactory(RpcForger)() : forger;\n    this._options.forger = f;\n    this._context.forger = f;\n  }\n\n  /**\n   * @description Sets stream provider on the Tezos Taquito instance\n   *\n   * @param options stream to use to interact with the Tezos network\n   *\n   * @example Tezos.setStreamProvider(...)\n   *\n   */\n  setStreamProvider(stream?: SetProviderOptions['stream']) {\n    if (typeof stream === 'string') {\n      this._stream = new PollingSubscribeProvider(new Context(new RpcClient(stream)));\n    } else if (typeof stream !== 'undefined') {\n      this._stream = stream;\n    } else if (this._options.stream === undefined) {\n      this._stream = this.getFactory(PollingSubscribeProvider)();\n    }\n    this._options.stream = stream;\n  }\n\n  /**\n   * @description Sets wallet provider on the Tezos Taquito instance\n   *\n   * @param options wallet to use to interact with the Tezos network\n   *\n   * @example Tezos.setWalletProvider(...)\n   *\n   */\n  setWalletProvider(wallet?: SetProviderOptions['wallet']) {\n    if (!this._options.wallet && typeof wallet === 'undefined') {\n      const w = this.getFactory(LegacyWalletProvider)();\n      this._options.wallet = w;\n      this._context.walletProvider = w;\n    } else if (typeof wallet !== 'undefined') {\n      this._options.wallet = wallet;\n      this._context.walletProvider = wallet;\n    }\n  }\n\n  /**\n   * @description Sets Packer provider on the Tezos Taquito instance\n   *\n   * @param options packer to use to interact with the Tezos network\n   *\n   * @example Tezos.setPackerProvider(new MichelCodecPacker())\n   *\n   */\n  setPackerProvider(packer?: SetProviderOptions['packer']) {\n    const p = typeof packer === 'undefined' ? this.getFactory(RpcPacker)() : packer;\n    this._options.packer = p;\n    this._context.packer = p;\n  }\n\n  /**\n   * @description Provide access to tezos account management\n   */\n  get tz(): TzProvider {\n    return this._context.tz;\n  }\n\n  /**\n   * @description Provide access to smart contract utilities\n   */\n  get contract(): ContractProvider {\n    return this._context.contract;\n  }\n\n  get wallet(): Wallet {\n    return this._wallet;\n  }\n\n  get operation(): OperationFactory {\n    return this._context.operationFactory;\n  }\n\n  /**\n   * @description Provide access to operation estimation utilities\n   */\n  get estimate(): EstimationProvider {\n    return this._context.estimate;\n  }\n\n  /**\n   * @description Provide access to streaming utilities backed by an streamer implementation\n   */\n  get stream(): SubscribeProvider {\n    return this._stream;\n  }\n\n  /**\n   * @description Provide access to the currently used rpc client\n   */\n  get rpc(): RpcClient {\n    return this._context.rpc;\n  }\n\n  /**\n   * @description Provide access to the currently used signer\n   */\n  get signer() {\n    return this._context.signer;\n  }\n\n  /**\n   * @description Allow to add a module to the TezosToolkit instance. This method adds the appropriate Providers(s) required by the module to the internal context.\n   *\n   * @param module extension to add to the TezosToolkit instance\n   *\n   * @example Tezos.addExtension(new Tzip16Module());\n   */\n  addExtension(module: Extension) {\n    module.configureContext(this._context);\n  }\n\n  getFactory<T, K extends Array<any>>(ctor: TaquitoProvider<T, K>) {\n    return (...args: K) => {\n      return new ctor(this._context, ...args);\n    };\n  }\n\n  /**\n   * @description Gets an object containing the version of Taquito library and git sha of the commit this library is compiled from\n   */\n  getVersionInfo(): VersionInfo {\n    return VERSION;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}