{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ExposedPromise } from '../../utils/exposed-promise';\nimport { generateGUID } from '../../utils/generate-uuid';\nimport { getKeypairFromSeed, toHex } from '../../utils/crypto';\nimport { StorageKey } from '../..';\nimport { BeaconEventHandler } from '../../events';\nimport { SDK_VERSION } from '../../constants';\nimport { windowRef } from '../../MockWindow';\n/**\n * @internalapi\n *\n * The beacon client is an abstract client that handles everything that is shared between all other clients.\n * Specifically, it handles managing the beaconId and and the local keypair.\n */\n\nexport class BeaconClient {\n  constructor(config) {\n    /** The beaconId is a public key that is used to identify one specific application (dapp or wallet).\n     * This is used inside a message to specify the sender, for example.\n     */\n    this._beaconId = new ExposedPromise();\n    this.events = new BeaconEventHandler();\n    /**\n     * The local keypair that is used for the communication encryption\n     */\n\n    this._keyPair = new ExposedPromise();\n\n    if (!config.name) {\n      throw new Error('Name not set');\n    }\n\n    if (!config.storage) {\n      throw new Error('Storage not set');\n    }\n\n    this.name = config.name;\n    this.iconUrl = config.iconUrl;\n    this.appUrl = config.appUrl;\n    this.storage = config.storage; // TODO: This is a temporary \"fix\" to prevent users from creating multiple Client instances\n\n    if (windowRef.beaconCreatedClientInstance) {\n      console.warn('[BEACON] It looks like you created multiple Beacon SDK Client instances. This can lead to problems. Only create one instance and re-use it everywhere.');\n    } else {\n      ;\n      windowRef.beaconCreatedClientInstance = true;\n    }\n\n    this.initSDK().catch(console.error);\n  }\n\n  get beaconId() {\n    return this._beaconId.promise;\n  }\n\n  get keyPair() {\n    return this._keyPair.promise;\n  }\n  /**\n   * This resets the SDK. After using this method, this instance is no longer usable. You will have to instanciate a new client.\n   */\n\n\n  destroy() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.removeBeaconEntriesFromStorage();\n      windowRef.beaconCreatedClientInstance = false;\n    });\n  }\n  /**\n   * This method initializes the SDK by setting some values in the storage and generating a keypair.\n   */\n\n\n  initSDK() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.storage.set(StorageKey.BEACON_SDK_VERSION, SDK_VERSION).catch(console.error);\n      this.loadOrCreateBeaconSecret().catch(console.error);\n      return this.keyPair.then(keyPair => {\n        this._beaconId.resolve(toHex(keyPair.publicKey));\n      });\n    });\n  }\n  /**\n   * Removes all beacon values from the storage.\n   */\n\n\n  removeBeaconEntriesFromStorage() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const allKeys = Object.values(StorageKey);\n      yield Promise.all(allKeys.map(key => this.storage.delete(key)));\n    });\n  }\n  /**\n   * This method tries to load the seed from storage, if it doesn't exist, a new one will be created and persisted.\n   */\n\n\n  loadOrCreateBeaconSecret() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const storageValue = yield this.storage.get(StorageKey.BEACON_SDK_SECRET_SEED);\n\n      if (storageValue && typeof storageValue === 'string') {\n        this._keyPair.resolve(yield getKeypairFromSeed(storageValue));\n      } else {\n        const key = yield generateGUID();\n        yield this.storage.set(StorageKey.BEACON_SDK_SECRET_SEED, key);\n\n        this._keyPair.resolve(yield getKeypairFromSeed(key));\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../../src/clients/beacon-client/BeaconClient.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SAAS,cAAT,QAA+B,6BAA/B;AACA,SAAS,YAAT,QAA6B,2BAA7B;AACA,SAAS,kBAAT,EAA6B,KAA7B,QAA0C,oBAA1C;AACA,SAAkB,UAAlB,QAAoC,OAApC;AACA,SAAS,kBAAT,QAAmC,cAAnC;AACA,SAAS,WAAT,QAA4B,iBAA5B;AACA,SAAS,SAAT,QAA0B,kBAA1B;AAGA;;;;;AAKG;;AACH,OAAM,MAAgB,YAAhB,CAA4B;AAoChC,EAAA,WAAA,CAAY,MAAZ,EAAuC;AApBvC;;AAEG;AACO,SAAA,SAAA,GAAoC,IAAI,cAAJ,EAApC;AAOS,SAAA,MAAA,GAA6B,IAAI,kBAAJ,EAA7B;AAEnB;;AAEG;;AACO,SAAA,QAAA,GAA2C,IAAI,cAAJ,EAA3C;;AAMR,QAAI,CAAC,MAAM,CAAC,IAAZ,EAAkB;AAChB,YAAM,IAAI,KAAJ,CAAU,cAAV,CAAN;AACD;;AACD,QAAI,CAAC,MAAM,CAAC,OAAZ,EAAqB;AACnB,YAAM,IAAI,KAAJ,CAAU,iBAAV,CAAN;AACD;;AACD,SAAK,IAAL,GAAY,MAAM,CAAC,IAAnB;AACA,SAAK,OAAL,GAAe,MAAM,CAAC,OAAtB;AACA,SAAK,MAAL,GAAc,MAAM,CAAC,MAArB;AACA,SAAK,OAAL,GAAe,MAAM,CAAC,OAAtB,CAVqC,CAYrC;;AACA,QAAK,SAAiB,CAAC,2BAAvB,EAAoD;AAClD,MAAA,OAAO,CAAC,IAAR,CACE,wJADF;AAGD,KAJD,MAIO;AACL;AAAE,MAAA,SAAiB,CAAC,2BAAlB,GAAgD,IAAhD;AACH;;AAED,SAAK,OAAL,GAAe,KAAf,CAAqB,OAAO,CAAC,KAA7B;AACD;;AAtCkB,MAAR,QAAQ,GAAA;AACjB,WAAO,KAAK,SAAL,CAAe,OAAtB;AACD;;AAUoB,MAAP,OAAO,GAAA;AACnB,WAAO,KAAK,QAAL,CAAc,OAArB;AACD;AA0BD;;AAEG;;;AACU,EAAA,OAAO,GAAA;;AAClB,YAAM,KAAK,8BAAL,EAAN;AACE,MAAA,SAAiB,CAAC,2BAAlB,GAAgD,KAAhD;AACH,K;AAAA;AAED;;AAEG;;;AACW,EAAA,OAAO,GAAA;;AACnB,WAAK,OAAL,CAAa,GAAb,CAAiB,UAAU,CAAC,kBAA5B,EAAgD,WAAhD,EAA6D,KAA7D,CAAmE,OAAO,CAAC,KAA3E;AAEA,WAAK,wBAAL,GAAgC,KAAhC,CAAsC,OAAO,CAAC,KAA9C;AAEA,aAAO,KAAK,OAAL,CAAa,IAAb,CAAmB,OAAD,IAAY;AACnC,aAAK,SAAL,CAAe,OAAf,CAAuB,KAAK,CAAC,OAAO,CAAC,SAAT,CAA5B;AACD,OAFM,CAAP;AAGD,K;AAAA;AAED;;AAEG;;;AACW,EAAA,8BAA8B,GAAA;;AAC1C,YAAM,OAAO,GAAiB,MAAM,CAAC,MAAP,CAAc,UAAd,CAA9B;AACA,YAAM,OAAO,CAAC,GAAR,CAAY,OAAO,CAAC,GAAR,CAAa,GAAD,IAAS,KAAK,OAAL,CAAa,MAAb,CAAoB,GAApB,CAArB,CAAZ,CAAN;AACD,K;AAAA;AAED;;AAEG;;;AACW,EAAA,wBAAwB,GAAA;;AACpC,YAAM,YAAY,GAAY,MAAM,KAAK,OAAL,CAAa,GAAb,CAAiB,UAAU,CAAC,sBAA5B,CAApC;;AACA,UAAI,YAAY,IAAI,OAAO,YAAP,KAAwB,QAA5C,EAAsD;AACpD,aAAK,QAAL,CAAc,OAAd,CAAsB,MAAM,kBAAkB,CAAC,YAAD,CAA9C;AACD,OAFD,MAEO;AACL,cAAM,GAAG,GAAG,MAAM,YAAY,EAA9B;AACA,cAAM,KAAK,OAAL,CAAa,GAAb,CAAiB,UAAU,CAAC,sBAA5B,EAAoD,GAApD,CAAN;;AACA,aAAK,QAAL,CAAc,OAAd,CAAsB,MAAM,kBAAkB,CAAC,GAAD,CAA9C;AACD;AACF,K;AAAA;;AArG+B","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ExposedPromise } from '../../utils/exposed-promise';\nimport { generateGUID } from '../../utils/generate-uuid';\nimport { getKeypairFromSeed, toHex } from '../../utils/crypto';\nimport { StorageKey } from '../..';\nimport { BeaconEventHandler } from '../../events';\nimport { SDK_VERSION } from '../../constants';\nimport { windowRef } from '../../MockWindow';\n/**\n * @internalapi\n *\n * The beacon client is an abstract client that handles everything that is shared between all other clients.\n * Specifically, it handles managing the beaconId and and the local keypair.\n */\nexport class BeaconClient {\n    constructor(config) {\n        /** The beaconId is a public key that is used to identify one specific application (dapp or wallet).\n         * This is used inside a message to specify the sender, for example.\n         */\n        this._beaconId = new ExposedPromise();\n        this.events = new BeaconEventHandler();\n        /**\n         * The local keypair that is used for the communication encryption\n         */\n        this._keyPair = new ExposedPromise();\n        if (!config.name) {\n            throw new Error('Name not set');\n        }\n        if (!config.storage) {\n            throw new Error('Storage not set');\n        }\n        this.name = config.name;\n        this.iconUrl = config.iconUrl;\n        this.appUrl = config.appUrl;\n        this.storage = config.storage;\n        // TODO: This is a temporary \"fix\" to prevent users from creating multiple Client instances\n        if (windowRef.beaconCreatedClientInstance) {\n            console.warn('[BEACON] It looks like you created multiple Beacon SDK Client instances. This can lead to problems. Only create one instance and re-use it everywhere.');\n        }\n        else {\n            ;\n            windowRef.beaconCreatedClientInstance = true;\n        }\n        this.initSDK().catch(console.error);\n    }\n    get beaconId() {\n        return this._beaconId.promise;\n    }\n    get keyPair() {\n        return this._keyPair.promise;\n    }\n    /**\n     * This resets the SDK. After using this method, this instance is no longer usable. You will have to instanciate a new client.\n     */\n    destroy() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.removeBeaconEntriesFromStorage();\n            windowRef.beaconCreatedClientInstance = false;\n        });\n    }\n    /**\n     * This method initializes the SDK by setting some values in the storage and generating a keypair.\n     */\n    initSDK() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.storage.set(StorageKey.BEACON_SDK_VERSION, SDK_VERSION).catch(console.error);\n            this.loadOrCreateBeaconSecret().catch(console.error);\n            return this.keyPair.then((keyPair) => {\n                this._beaconId.resolve(toHex(keyPair.publicKey));\n            });\n        });\n    }\n    /**\n     * Removes all beacon values from the storage.\n     */\n    removeBeaconEntriesFromStorage() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const allKeys = Object.values(StorageKey);\n            yield Promise.all(allKeys.map((key) => this.storage.delete(key)));\n        });\n    }\n    /**\n     * This method tries to load the seed from storage, if it doesn't exist, a new one will be created and persisted.\n     */\n    loadOrCreateBeaconSecret() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const storageValue = yield this.storage.get(StorageKey.BEACON_SDK_SECRET_SEED);\n            if (storageValue && typeof storageValue === 'string') {\n                this._keyPair.resolve(yield getKeypairFromSeed(storageValue));\n            }\n            else {\n                const key = yield generateGUID();\n                yield this.storage.set(StorageKey.BEACON_SDK_SECRET_SEED, key);\n                this._keyPair.resolve(yield getKeypairFromSeed(key));\n            }\n        });\n    }\n}\n//# sourceMappingURL=BeaconClient.js.map"]},"metadata":{},"sourceType":"module"}