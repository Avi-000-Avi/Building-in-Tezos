{"ast":null,"code":"import { EventEmitter } from 'events';\nimport { keys } from '../utils/utils';\nimport { MatrixRoomStatus } from './models/MatrixRoom';\nimport { MatrixClientEventType } from './models/MatrixClientEvent';\nexport class MatrixClientEventEmitter extends EventEmitter {\n  constructor() {\n    super(...arguments);\n    this.eventEmitProviders = new Map([[MatrixClientEventType.INVITE, () => [this.isInvite, this.emitInvite.bind(this)]], [MatrixClientEventType.MESSAGE, () => [this.isMessage, this.emitMessage.bind(this)]]]);\n  }\n  /**\n   * This method is called every time the state is changed\n   *\n   * @param _oldState\n   * @param _newState\n   * @param stateChange\n   */\n\n\n  onStateChanged(_oldState, _newState, stateChange) {\n    for (const event of keys(MatrixClientEventType)) {\n      this.emitIfEvent(MatrixClientEventType[event], stateChange);\n    }\n  }\n  /**\n   * Emit the message if we have listeners registered for that type\n   *\n   * @param eventType\n   * @param object\n   */\n\n\n  emitIfEvent(eventType, object) {\n    const provider = this.eventEmitProviders.get(eventType);\n\n    if (provider) {\n      const [predicate, emitter] = provider();\n\n      if (predicate(object)) {\n        emitter(eventType, object);\n      }\n    }\n  }\n  /**\n   * Emit a client event\n   *\n   * @param eventType\n   * @param content\n   */\n\n\n  emitClientEvent(eventType, content, timestamp) {\n    this.emit(eventType, {\n      type: eventType,\n      content,\n      timestamp\n    });\n  }\n  /**\n   * Check if event is an invite\n   *\n   * @param stateChange\n   */\n\n\n  isInvite(stateChange) {\n    return stateChange.rooms ? stateChange.rooms.some(room => room.status === MatrixRoomStatus.INVITED) : false;\n  }\n  /**\n   * Emit an invite\n   *\n   * @param eventType\n   * @param stateChange\n   */\n\n\n  emitInvite(eventType, stateChange) {\n    stateChange.rooms.filter(room => room.status === MatrixRoomStatus.INVITED).map(room => [room.id, room.members]).forEach(([id, members]) => {\n      this.emitClientEvent(eventType, {\n        roomId: id,\n        members: members\n      });\n    });\n  }\n  /**\n   * Check if event is a message\n   *\n   * @param stateChange\n   */\n\n\n  isMessage(stateChange) {\n    return stateChange.rooms ? stateChange.rooms.some(room => room.messages.length > 0) : false;\n  }\n  /**\n   * Emit an event to all rooms\n   *\n   * @param eventType\n   * @param stateChange\n   */\n\n\n  emitMessage(eventType, stateChange) {\n    stateChange.rooms.filter(room => room.messages.length > 0).map(room => room.messages.map(message => [room.id, message, message.timestamp])).reduce((flatten, toFlatten) => flatten.concat(toFlatten), []).forEach(([roomId, message, timestamp]) => {\n      this.emitClientEvent(eventType, {\n        roomId,\n        message\n      }, timestamp);\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/matrix-client/MatrixClientEventEmitter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { EventEmitter } from 'events';\nimport { keys } from '../utils/utils';\nimport { MatrixRoomStatus } from './models/MatrixRoom';\nimport { MatrixClientEventType } from './models/MatrixClientEvent';\nexport class MatrixClientEventEmitter extends EventEmitter {\n    constructor() {\n        super(...arguments);\n        this.eventEmitProviders = new Map([\n            [MatrixClientEventType.INVITE, () => [this.isInvite, this.emitInvite.bind(this)]],\n            [MatrixClientEventType.MESSAGE, () => [this.isMessage, this.emitMessage.bind(this)]]\n        ]);\n    }\n    /**\n     * This method is called every time the state is changed\n     *\n     * @param _oldState\n     * @param _newState\n     * @param stateChange\n     */\n    onStateChanged(_oldState, _newState, stateChange) {\n        for (const event of keys(MatrixClientEventType)) {\n            this.emitIfEvent(MatrixClientEventType[event], stateChange);\n        }\n    }\n    /**\n     * Emit the message if we have listeners registered for that type\n     *\n     * @param eventType\n     * @param object\n     */\n    emitIfEvent(eventType, object) {\n        const provider = this.eventEmitProviders.get(eventType);\n        if (provider) {\n            const [predicate, emitter] = provider();\n            if (predicate(object)) {\n                emitter(eventType, object);\n            }\n        }\n    }\n    /**\n     * Emit a client event\n     *\n     * @param eventType\n     * @param content\n     */\n    emitClientEvent(eventType, content, timestamp) {\n        this.emit(eventType, {\n            type: eventType,\n            content,\n            timestamp\n        });\n    }\n    /**\n     * Check if event is an invite\n     *\n     * @param stateChange\n     */\n    isInvite(stateChange) {\n        return stateChange.rooms\n            ? stateChange.rooms.some((room) => room.status === MatrixRoomStatus.INVITED)\n            : false;\n    }\n    /**\n     * Emit an invite\n     *\n     * @param eventType\n     * @param stateChange\n     */\n    emitInvite(eventType, stateChange) {\n        stateChange.rooms\n            .filter((room) => room.status === MatrixRoomStatus.INVITED)\n            .map((room) => [room.id, room.members])\n            .forEach(([id, members]) => {\n            this.emitClientEvent(eventType, {\n                roomId: id,\n                members: members\n            });\n        });\n    }\n    /**\n     * Check if event is a message\n     *\n     * @param stateChange\n     */\n    isMessage(stateChange) {\n        return stateChange.rooms ? stateChange.rooms.some((room) => room.messages.length > 0) : false;\n    }\n    /**\n     * Emit an event to all rooms\n     *\n     * @param eventType\n     * @param stateChange\n     */\n    emitMessage(eventType, stateChange) {\n        stateChange.rooms\n            .filter((room) => room.messages.length > 0)\n            .map((room) => room.messages.map((message) => [room.id, message, message.timestamp]))\n            .reduce((flatten, toFlatten) => flatten.concat(toFlatten), [])\n            .forEach(([roomId, message, timestamp]) => {\n            this.emitClientEvent(eventType, {\n                roomId,\n                message\n            }, timestamp);\n        });\n    }\n}\n//# sourceMappingURL=MatrixClientEventEmitter.js.map"]},"metadata":{},"sourceType":"module"}